import{_ as c}from"./fixed_increment_advance-Be9dYTkx.js";import{_ as r,c as d,e as p,f as a,b as l,a as s,g as t,r as o,o as u}from"./app-IsHl6ERv.js";const k={};function m(v,n){const i=o("FlowChart"),e=o("RouteLink");return u(),d("div",null,[n[9]||(n[9]=p('<h1 id="仿真时间推进" tabindex="-1"><a class="header-anchor" href="#仿真时间推进"><span>仿真时间推进</span></a></h1><p>仿真中的时间推进是指在仿真过程中，通过什么方法推进仿真时间。</p><h2 id="时间推进法的分类" tabindex="-1"><a class="header-anchor" href="#时间推进法的分类"><span>时间推进法的分类</span></a></h2><p>常见的仿真时间推进方法有三大类：</p><ul><li><strong>事件调度法</strong>：事件调度法是一种基于事件的仿真方法，它通过对仿真系统中各个事件进行排序，按照事件发生的先后顺序依次推进时间执行活动，进而实现仿真。</li><li><strong>固定增量推进法</strong>：固定增量推进法是指在仿真过程中，固定一个时间增量。在设定起始时间后，在起始时间的基础上根据时间的增量来对时间进行推进仿真。</li><li>活动事件扫描法：针对不确定性较强的系统，通过扫描系统中发生的事件并执行相应的活动实现时间推进。感觉实现起来比较难（容易出现时间推进不准（有误差）的问题，可能是我的水平不够😥）</li></ul><h2 id="实例" tabindex="-1"><a class="header-anchor" href="#实例"><span>实例</span></a></h2><h3 id="事件调度法" tabindex="-1"><a class="header-anchor" href="#事件调度法"><span>事件调度法</span></a></h3><p>事件调度法是一种基于事件的仿真方法，它通过对仿真系统中各个事件进行排序，按照事件发生的先后顺序来进行仿真。在仿真过程中，仿真系统根据当前仿真时间和剩余事件，<strong>将时间推进到下一个事件，执行相应的活动</strong>。</p><p>事件调度法主要分为以下3个主要步骤，这3个步骤也是控制事件调度法的主控程序的主要步骤：</p><ul><li>时间扫描：确定下一事件发生时间并将仿真时钟推进到该时刻</li><li>事件辨识：正确地辨识当前要发生的事件</li><li>事件执行：正确地执行当前发生的事件</li></ul><p>事件调度法基本原理流程图如下：</p>',11)),a(i,{id:"flowchart-61",code:"eJzLzMsssbUrLkksKrFSeNox9+ny7qc907iKkxPzbO3yC1KLEksy8/OsFJ7s6n6ye9uzztXP+vu5UitSk7HKLn+xsIcrszjV1i45Py8lEyL5tGPJs2lrn81Y/3TCsue7Jz+bO58LqCA1LwWob/f+53PmQwW5QG7RtQNZrWsHskLXDmgUyDiNvHxNiASYV5laDOSmcgEApctWxQ==",preset:"vue"}),l("p",null,[n[1]||(n[1]=s("事件调度法在MicroCityWeb中的具体实现参见 ")),a(e,{to:"/notes/event-scheduling.html"},{default:t(()=>n[0]||(n[0]=[s("离散事件仿真和程序控制 - 协程")])),_:1})]),n[10]||(n[10]=p('<h3 id="固定增量推进法" tabindex="-1"><a class="header-anchor" href="#固定增量推进法"><span>固定增量推进法</span></a></h3><p>固定增量推进法是指在仿真过程中，从起始时间开始，<strong>每次推进一个固定步长的时间</strong>。在每个步长内，若无事件发生，则仿真钟再推进一个单位时间T；若在该步内有若干个事件发生，则依次执行，且认为这些事件均发生在该步的结束时刻。</p><div style="text-align:center;"><p><img src="'+c+`" alt="固定增量推进法"></p><p>例题</p></div><h4 id="代码流程示例" tabindex="-1"><a class="header-anchor" href="#代码流程示例"><span>代码流程示例</span></a></h4><div class="language-lua line-numbers-mode" data-highlighter="prismjs" data-ext="lua" data-title="lua"><pre><code><span class="line"><span class="token keyword">while</span> scene<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">do</span></span>
<span class="line">    t <span class="token operator">=</span> t <span class="token operator">+</span> dt</span>
<span class="line">    <span class="token keyword">if</span> t <span class="token operator">%</span> cycle <span class="token operator">~=</span> work_time <span class="token keyword">then</span></span>
<span class="line">        d <span class="token operator">=</span> d <span class="token operator">+</span> v <span class="token operator">*</span> dt</span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;出发后&quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token string">&quot;小时&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">else</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;出发后&quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token string">&quot;小时,休息&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">end</span></span>
<span class="line"></span>
<span class="line">    car<span class="token punctuation">:</span><span class="token function">setpos</span><span class="token punctuation">(</span><span class="token function">CastToLine</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--直线轨迹</span></span>
<span class="line"></span>
<span class="line">    os<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">end</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>此为代码主要流程，无法直接使用</p></blockquote>`,6)),l("p",null,[a(e,{to:"/notes/warehouse-simulation.html"},{default:t(()=>n[2]||(n[2]=[s("自动化仓库仿真思路")])),_:1}),n[4]||(n[4]=s("的最后一部分提到了")),a(e,{to:"/notes/warehouse-simulation.html#%E6%94%B9%E8%BF%9B%E7%A9%BA%E9%97%B4"},{default:t(()=>n[3]||(n[3]=[s("改进空间")])),_:1}),n[5]||(n[5]=s("，实现了全局的仿真钟，最终实现了时间推进法。最终还实现了非固定增量推进，详细见下文介绍。"))]),n[11]||(n[11]=p(`<h4 id="自动化仓库仿真向主导时钟推进法的改变" tabindex="-1"><a class="header-anchor" href="#自动化仓库仿真向主导时钟推进法的改变"><span>自动化仓库仿真向主导时钟推进法的改变</span></a></h4><p>具体来说，只在原来的基础上做了如下改动：</p><ul><li>删除大部分与事件调度法有关的 <code>os.sleep()</code>。由于仿真流程比较简单，保留了与装卸货有关的事件调度法，优化资源占用。</li><li>设置全局仿真时钟，将 <code>Agv:Move()</code> 函数的思路从“固定步长执行任务并刷新场景”的改为“监测仿真时钟时长变化，根据时长变化执行任务并刷新场景”</li><li>新增仿真速度调整。</li></ul><p>从以上的改动可以看出，仿真的核心从事件任务转向了仿真时钟。其中，场景刷新的部分使用了 <code>os.clock()</code> 实现。</p><h3 id="非固定增量推进法" tabindex="-1"><a class="header-anchor" href="#非固定增量推进法"><span>非固定增量推进法</span></a></h3><p>下面是一个有关于时间推进法和 <code>os.clock()</code> 函数的简单的示例，修改自MicroCityWeb中内置的方块旋转案例。其中，<code>os.clock()</code> 用于计算CPU运行时间，以此实现仿真时间与真实世界时间成一定比例。而具体的比例可以通过 <code>simspeed</code> （仿真速度）进行调整。</p><div class="language-lua line-numbers-mode" data-highlighter="prismjs" data-ext="lua" data-title="lua"><pre><code><span class="line"><span class="token keyword">local</span> obj <span class="token operator">=</span> scene<span class="token punctuation">.</span><span class="token function">addobj</span><span class="token punctuation">(</span><span class="token string">&#39;box&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">-- 初始位置</span></span>
<span class="line"><span class="token keyword">local</span> x <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">local</span> y <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">local</span> z <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">local</span> rx<span class="token punctuation">,</span> ry <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.1</span> <span class="token comment">-- x方向和y方向的旋转速度</span></span>
<span class="line"><span class="token keyword">local</span> simspeed <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">-- 仿真速度</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">local</span> t <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">-- 全局仿真时钟</span></span>
<span class="line"><span class="token keyword">local</span> t0 <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- 记录仿真开始的时间</span></span>
<span class="line"><span class="token keyword">while</span> scene<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">do</span></span>
<span class="line">    <span class="token keyword">local</span> dt <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t0 <span class="token comment">-- 计算自上次记录时间以来的时间差</span></span>
<span class="line">    t <span class="token operator">=</span> t <span class="token operator">+</span> dt <span class="token comment">-- 仿真时钟走过相应时间差长度的时间</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">-- 设置方块此刻的旋转位置</span></span>
<span class="line">	x <span class="token operator">=</span> x <span class="token operator">+</span> rx <span class="token operator">*</span> dt <span class="token operator">*</span> simspeed </span>
<span class="line">	y <span class="token operator">=</span> y <span class="token operator">+</span> ry <span class="token operator">*</span> dt <span class="token operator">*</span> simspeed </span>
<span class="line">	obj<span class="token punctuation">:</span><span class="token function">setrot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span></span>
<span class="line">	</span>
<span class="line">    t0 <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- 记录仿真时间</span></span>
<span class="line"><span class="token keyword">end</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相关说明</p><ul><li>当仿真速度 <code>simspeed</code> 为1时，表示仿真时钟与真实世界时钟的速度相同。<code>simspeed</code> 可以视作加速倍率。</li><li><code>dt</code> 表示两次记录时间之间的时间差，仿真中的时间步进根据 <code>dt*simspeed</code> 计算得到。<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>需要注意的是，时间增量 <code>dt</code> 的数值在每个循环周期一般都不相同，<code>dt</code> 的具体大小一般取决于电脑的运算能力</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>有时两次记录时间之间没有太多耗时的操作，计算得到的 <code>dt</code> 可能为0。一般两次时间记录之间存在一个 <code>scene.render()</code>，这样一般能够保证两次采样的时间之间能够计算得到一个不为0的时间差值。</p></div></li></ul>`,9)),l("p",null,[n[7]||(n[7]=s("对于 MicroCity Web，非固定增量的时间推进法还可以参考 Gallery 部分")),a(e,{to:"/notes/gallery/build-a-clock.html"},{default:t(()=>n[6]||(n[6]=[s("绘制一个时钟")])),_:1}),n[8]||(n[8]=s("的案例，比较详细地介绍了如何控制时钟的指针，以及如何根据当前时间来控制指针的位置。"))])])}const g=r(k,[["render",m],["__file","timelapse.html.vue"]]),y=JSON.parse('{"path":"/notes/timelapse.html","title":"仿真时间推进","lang":"zh-CN","frontmatter":{"description":"仿真时间推进 仿真中的时间推进是指在仿真过程中，通过什么方法推进仿真时间。 时间推进法的分类 常见的仿真时间推进方法有三大类： 事件调度法：事件调度法是一种基于事件的仿真方法，它通过对仿真系统中各个事件进行排序，按照事件发生的先后顺序依次推进时间执行活动，进而实现仿真。 固定增量推进法：固定增量推进法是指在仿真过程中，固定一个时间增量。在设定起始时间后...","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://huuhghhgyg.github.io/MicroCityNotes/en/notes/timelapse.html"}],["meta",{"property":"og:url","content":"https://huuhghhgyg.github.io/MicroCityNotes/notes/timelapse.html"}],["meta",{"property":"og:site_name","content":"MicroCity笔记"}],["meta",{"property":"og:title","content":"仿真时间推进"}],["meta",{"property":"og:description","content":"仿真时间推进 仿真中的时间推进是指在仿真过程中，通过什么方法推进仿真时间。 时间推进法的分类 常见的仿真时间推进方法有三大类： 事件调度法：事件调度法是一种基于事件的仿真方法，它通过对仿真系统中各个事件进行排序，按照事件发生的先后顺序依次推进时间执行活动，进而实现仿真。 固定增量推进法：固定增量推进法是指在仿真过程中，固定一个时间增量。在设定起始时间后..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-08-23T03:03:04.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-23T03:03:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"仿真时间推进\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-23T03:03:04.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"时间推进法的分类","slug":"时间推进法的分类","link":"#时间推进法的分类","children":[]},{"level":2,"title":"实例","slug":"实例","link":"#实例","children":[{"level":3,"title":"事件调度法","slug":"事件调度法","link":"#事件调度法","children":[]},{"level":3,"title":"固定增量推进法","slug":"固定增量推进法","link":"#固定增量推进法","children":[]},{"level":3,"title":"非固定增量推进法","slug":"非固定增量推进法","link":"#非固定增量推进法","children":[]}]}],"git":{"updatedTime":1724382184000,"contributors":[{"name":"huuhghhgyg","email":"huuhghhgyg@outlook.com","commits":10,"url":"https://github.com/huuhghhgyg"}]},"filePathRelative":"notes/timelapse.md","autoDesc":true,"excerpt":"\\n<p>仿真中的时间推进是指在仿真过程中，通过什么方法推进仿真时间。</p>\\n<h2>时间推进法的分类</h2>\\n<p>常见的仿真时间推进方法有三大类：</p>\\n<ul>\\n<li><strong>事件调度法</strong>：事件调度法是一种基于事件的仿真方法，它通过对仿真系统中各个事件进行排序，按照事件发生的先后顺序依次推进时间执行活动，进而实现仿真。</li>\\n<li><strong>固定增量推进法</strong>：固定增量推进法是指在仿真过程中，固定一个时间增量。在设定起始时间后，在起始时间的基础上根据时间的增量来对时间进行推进仿真。</li>\\n<li>活动事件扫描法：针对不确定性较强的系统，通过扫描系统中发生的事件并执行相应的活动实现时间推进。感觉实现起来比较难（容易出现时间推进不准（有误差）的问题，可能是我的水平不够😥）</li>\\n</ul>"}');export{g as comp,y as data};
