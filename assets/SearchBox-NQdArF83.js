import{f as b,g as j,h as L,i as I,t as D,u as _,j as O,_ as z,o as u,c as p,k as N,v as R,a as f,n as y,l as x,F as T,m as M,p as G,q as w,s as E}from"./app-WB5ROtMu.js";const F=[{path:"/",title:"é¦–é¡µ",pathLocale:"/",contents:[{header:"å¼€å§‹ä½¿ç”¨MicroCity Web",slug:"å¼€å§‹ä½¿ç”¨microcity-web",content:"æ‰“å¼€MicroCity Webï¼Œé»˜è®¤åŠ è½½æ–¹å—æ—‹è½¬çš„ç¤ºä¾‹ä»£ç ã€‚ ç‚¹å‡»è¿è¡ŒæŒ‰é’®è¿è¡Œä»£ç  ç¨‹åºè¿è¡Œï¼Œçœ‹åˆ°å³ä¾§è§†å›¾ä¸­æ–¹å—æ—‹è½¬ã€‚ å¦‚æœæƒ³è¦æ·±å…¥äº†è§£ MicroCity Web çš„ç”¨æ³•å’Œä½¿ç”¨æŠ€å·§ï¼Œå¯ä»¥å‚é˜…æœ¬ç«™æä¾›çš„ å­¦ä¹ ç¬”è®°"},{header:"å¼€å§‹ä½¿ç”¨MicroCity Desktop",slug:"å¼€å§‹ä½¿ç”¨microcity-desktop",content:'è½¬åˆ°MicroCityçš„æ–‡æ¡£ä»“åº“ä¸‹è½½ MicroCityçš„æœ€æ–°ç‰ˆæœ¬ æ‰“å¼€ ScriptEditor å¹¶è¾“å…¥: Print("hello, world!") å°†è„šæœ¬å¦å­˜ä¸º test.mcs å¹¶å°†å…¶æ‹–å…¥ MicroCity åœ¨ç¨‹åºä¸»ç•Œé¢å·¦ä¾§è½¬åˆ° Modules æ ‡ç­¾é¡µï¼Œæ‰“å¼€ test ï¼ŒåŒå‡»å…¶ä¸­çš„ main ï¼Œæ‰§è¡Œåˆšåˆšç¼–å†™çš„è„šæœ¬ã€‚ ç¨‹åºç•Œé¢ä¸‹æ–¹çš„ Messages æ ä¸­ä¼šè¾“å‡ºæ‰§è¡Œè„šæœ¬çš„ä¿¡æ¯ã€‚ æ›´å¤šMicroCityçš„ä½¿ç”¨æ–¹æ³•å¯ä»¥å‚è€ƒæœ¬ç«™æ¬è¿è‡ªGitHubçš„æ–‡æ¡£ï¼šMicroCityæ–‡æ¡£ï¼Œä¹Ÿå¯ä»¥å‚è€ƒ MicroCtiy åœ¨GitHubä¸Šçš„æ–‡æ¡£ã€‚'},{header:"MicroCityNotes ä»“åº“",slug:"microcitynotes-ä»“åº“",content:`å›½å†…ç”¨æˆ·å¦‚æœä¸æ–¹ä¾¿è®¿é—® GitHub ä¹Ÿå¯ä»¥è®¿é—®æœ¬ç«™åœ¨ Netlify ä¸Šæ­å»ºçš„ åŒæ­¥ç«™ç‚¹
å¦‚æœå‘ç°æ–‡æ¡£æˆ–ç¬”è®°æœ‰é—®é¢˜ï¼Œæ¬¢è¿ Pull Request æˆ–è€…æä¾› Issues è®©å®ƒå˜å¾—æ›´å®Œå–„ğŸ˜‹`}]},{path:"/docs/1.1_what_microcity_can_do.html",title:"1.1 MicroCityçš„åŠŸèƒ½",pathLocale:"/",contents:[{header:"1.1 MicroCityçš„åŠŸèƒ½",slug:"_1-1-microcityçš„åŠŸèƒ½",content:"MicroCityè¢«è®¾è®¡ä¸ºä¸€æ¬¾æ–¹ä¾¿çš„ç©ºé—´è§„åˆ’å·¥å…·ï¼Œå…·æœ‰ä¾¿æºã€ç´§å‡‘å’Œå¿«é€Ÿçš„ç‰¹ç‚¹ã€‚"},{header:"ä¸€ä¸ªå»ºæ¨¡æ¡†æ¶",slug:"ä¸€ä¸ªå»ºæ¨¡æ¡†æ¶",content:"åŸºäºGISã€ç½‘ç»œå’Œæ··åˆæ•´æ•°è§„åˆ’åº“ï¼ŒMicroCityå¯ä»¥ä½œä¸ºä¸€ä¸ªå»ºæ¨¡æ¡†æ¶æ¥è§£å†³äº¤é€šè¿è¾“é—®é¢˜ï¼Œä¾‹å¦‚åŸå¸‚ç‰©æµå’Œèˆªè¿è§„åˆ’ï¼š"},{header:"ä¸€ä¸ªä»¿çœŸå¹³å°",slug:"ä¸€ä¸ªä»¿çœŸå¹³å°",content:"åŸºäº3Dè®¡ç®—æœºå›¾å½¢å’Œç¦»æ•£äº‹ä»¶ä»¿çœŸå¼•æ“ï¼ŒMicroCityå¯ä»¥ä½œä¸ºä¸€ä¸ªä»¿çœŸå¹³å°æ¥è¯„ä¼°ç‰©æµåœºæ™¯ï¼Œä¾‹å¦‚è‡ªåŠ¨åŒ–ä»“åº“å’Œé›†è£…ç®±ç å¤´ï¼š"},{header:"é€šè¿‡è„šæœ¬æ¨¡å—å®šåˆ¶",slug:"é€šè¿‡è„šæœ¬æ¨¡å—å®šåˆ¶",content:"MicroCityå¯ä»¥é€šè¿‡æ¨¡å—æ¥æ‰©å±•å…¶åŠŸèƒ½ï¼Œè¿™äº›æ¨¡å—å¯ä»¥ä»SAGAç»§æ‰¿æˆ–åœ¨è„šæœ¬ç¼–è¾‘å™¨ä¸­è¿›è¡Œè„šæœ¬ç¼–å†™å’Œè°ƒè¯•ï¼š ç›®å‰ï¼ŒMicroCityä¸»è¦ç”¨äºæ•™å­¦å’Œç ”ç©¶ï¼Œå¯ä»¥è‡ªç”±åˆ†å‘ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/2.1_showing_a_world_map.html",title:"2.1 æ˜¾ç¤ºä¸–ç•Œåœ°å›¾",pathLocale:"/",contents:[{header:"2.1 æ˜¾ç¤ºä¸–ç•Œåœ°å›¾",slug:"_2-1-æ˜¾ç¤ºä¸–ç•Œåœ°å›¾",content:"æœ¬æ•™ç¨‹å°†æŒ‡å¯¼æ‚¨åœ¨ MicroCity ä¸­æ“ä½œå’Œå¯è§†åŒ–åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰æ•°æ®ã€‚"},{header:"åŠ è½½æ•°æ®å’Œåˆ›å»ºåœ°å›¾",slug:"åŠ è½½æ•°æ®å’Œåˆ›å»ºåœ°å›¾",content:"ä¸‹è½½ countries.shpï¼ˆArcGIS shapefileï¼‰å’Œ countries.dbfï¼ˆdBase æ–‡ä»¶ï¼‰åˆ°åŒä¸€ä¸ªæ–‡ä»¶å¤¹ä¸­ã€‚æ‰“å¼€ MicroCityï¼Œç‚¹å‡» æˆ–å°† countries.shp æ‹–å…¥ MicroCityï¼Œç„¶ååœ¨å·¥ä½œåŒºé¢æ¿ä¸­é€‰æ‹© Data Tabã€‚åŒå‡»å·¥ä½œåŒºé¢æ¿ä¸­çš„ Data->Shapes->Polygon->01. countriesã€‚"},{header:"å¯è§†åŒ–å›½å®¶å±æ€§",slug:"å¯è§†åŒ–å›½å®¶å±æ€§",content:"å³é”®ç‚¹å‡» 01. countries åœ¨å·¥ä½œåŒºé¢æ¿ä¸­ã€‚åœ¨å¼¹å‡ºèœå•ä¸­é€‰æ‹© Attributes->Table->Showã€‚åœ¨ Settings é¢æ¿ä¸­ï¼Œæ‰¾åˆ° Colors->Type é€‰é¡¹å¹¶é€‰æ‹© Graduated Colorã€‚åœ¨å…¶å­é€‰é¡¹ Attribute ä¸­ï¼Œé€‰æ‹©å›½å®¶çš„äººå£å±æ€§ POP_ESTã€‚åœ¨ Settings é¢æ¿ä¸­ï¼Œæ‰¾åˆ° Chart é€‰é¡¹å¹¶ç‚¹å‡» ... æŒ‰é’®ã€‚åœ¨å¼¹å‡ºå¯¹è¯æ¡†ä¸­ï¼Œé€‰æ‹©é¥¼å›¾ï¼ˆpieï¼‰ä½œä¸ºå›¾è¡¨ç±»å‹ï¼Œé€‰æ‹© GDP_MD_EST ä½œä¸ºå±æ€§ï¼ˆå¤§å°ï¼‰ï¼Œå¹¶åœ¨ Fields é€‰é¡¹ä¸­é€‰æ‹© EXPORT å’Œ IMPORT å¤é€‰æ¡†ï¼Œç„¶åç‚¹å‡» Okay æŒ‰é’®ã€‚"},{header:"ç¼–è¾‘å½¢çŠ¶",slug:"ç¼–è¾‘å½¢çŠ¶",content:"åœ¨å·¥å…·æ ä¸Šé€‰æ‹© Action æŒ‰é’®ã€‚å·¦é”®ç‚¹å‡»æŸä¸ªå›½å®¶ï¼Œå³é”®ç‚¹å‡»å®ƒå¹¶åœ¨å¼¹å‡ºèœå•ä¸­é€‰æ‹© Edit Selected Shapeï¼Œç„¶åè¯¥å½¢çŠ¶å°†è¿›å…¥ç¼–è¾‘æ¨¡å¼ã€‚æ‚¨å¯ä»¥æ›´æ”¹å…¶å¤šè¾¹å½¢çš„ç‚¹ï¼Œå¹¶åœ¨å³é”®ç‚¹å‡»å¹¶å†æ¬¡é€‰æ‹© Edit Selected Shape æ¥å®Œæˆç¼–è¾‘ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/2.2_searching_for_countries.html",title:"2.2 å¯»æ‰¾å›½å®¶",pathLocale:"/",contents:[{header:"2.2 å¯»æ‰¾å›½å®¶",slug:"_2-2-å¯»æ‰¾å›½å®¶",content:"æœ¬æ•™ç¨‹å°†æŒ‡å¯¼æ‚¨ä½¿ç”¨ MicroCity Script å¯¹GISæ•°æ®è¿›è¡Œç¼–ç æ“ä½œã€‚æ‚¨éœ€è¦å®Œæˆ 2.1 å†…å®¹ä»¥ç»§ç»­ã€‚"},{header:"GIS æ•°æ®ç»“æ„",slug:"gis-æ•°æ®ç»“æ„",content:"åœ¨ MicroCity ä¸­ï¼ŒGIS æ•°æ®ç”±ä¸‰ç§ç±»å‹çš„å½¢çŠ¶ç»„æˆï¼šç‚¹ã€æŠ˜çº¿å’Œå¤šè¾¹å½¢ï¼Œæ¯ç§ç±»å‹éƒ½å¯ä»¥è§†ä¸ºåœ°å›¾å›¾å±‚ã€‚åœ¨å›¾å±‚ä¸­ï¼Œå½¢çŠ¶å¯¹è±¡ç”±ä¸€ä¸ªæˆ–å¤šä¸ªéƒ¨åˆ†ç»„æˆï¼Œè€Œæ¯ä¸ªéƒ¨åˆ†åˆç”±ä¸€ä¸ªæˆ–å¤šä¸ªç‚¹ç»„æˆã€‚å½¢çŠ¶å¯¹è±¡è¿˜ä¸å±æ€§è¡¨ä¸­çš„è®°å½•ç›¸å…³è”ã€‚æ‚¨è¿˜å¯ä»¥ç¼–è¾‘å½¢çŠ¶æˆ–å…¶å±æ€§ï¼ˆè¯·å‚é˜… 3.2ï¼‰ã€‚ å¦‚æœæ‚¨æƒ³è¦æ‰§è¡Œå¤æ‚çš„ç¼–è¾‘æˆ–å¤„ç†ä¸€æ‰¹å½¢çŠ¶ï¼Œå¯ä»¥ä½¿ç”¨ MicroCity Scriptï¼Œå…¶ä¸­åŒ…å«è®¸å¤šå†…ç½®å‡½æ•°å¯ä¾›ä½¿ç”¨ã€‚"},{header:"è¿›è¡ŒæŸ¥è¯¢",slug:"è¿›è¡ŒæŸ¥è¯¢",content:`å‡è®¾æˆ‘ä»¬æƒ³è¦æ‰¾å‡ºäººå£è¶…è¿‡1äº¿ä¸”å®Œå…¨ä½äºåŒ—åŠçƒçš„å›½å®¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥æ¯ä¸ªå½¢çŠ¶ä¸­æ¯ä¸ªç‚¹çš„åæ ‡ä»¥åŠå½¢çŠ¶çš„äººå£å±æ€§ã€‚æ‰“å¼€ ScriptEditor ï¼Œç„¶åè¾“å…¥ä»¥ä¸‹ä»£ç ï¼š
local Countries = Open("countries.shp") --å°è¯•æ‰“å¼€å½¢çŠ¶å›¾å±‚
for i = 1, GetRecCount(Countries) do --å¾ªç¯éå†å›¾å±‚ä¸­çš„æ‰€æœ‰å½¢çŠ¶å¯¹è±¡ local country = GetShape(Countries, i) --è·å–ä¸€ä¸ªå›½å®¶çš„å½¢çŠ¶å¯¹è±¡ local north = true --å‡è®¾è¯¥å›½å®¶ä½äºåŒ—åŠçƒ for j = 1, GetPartCount(country) do --å¾ªç¯éå†æ‰€æœ‰å½¢çŠ¶ä¸­çš„éƒ¨åˆ† for k = 1, GetPointCount(country, j) do --å¾ªç¯éå†è¯¥éƒ¨åˆ†ä¸­çš„æ‰€æœ‰ç‚¹ local x, y = GetPointXY(country, k, j) --è·å–ç‚¹çš„åæ ‡ if y < 0 then --å¦‚æœçº¬åº¦å°äº0 north = false --åŒ—åŠçƒçš„å‡è®¾ä¸ºå‡ end end end local pop = GetValue(country, "POP_EST") --è·å–äººå£å±æ€§ local name = GetValue(country, "NAME") --è·å–å›½å®¶åç§° if pop > 100000000 and north then --æ£€æŸ¥ä¸¤ä¸ªæ¡ä»¶ Print(name, ": ", pop/100000000) --æ‰“å°ç»“æœ end
end`},{header:"è¿è¡Œè„šæœ¬",slug:"è¿è¡Œè„šæœ¬",content:"å°†è„šæœ¬ä¿å­˜ä¸º query.mcsï¼Œå¹¶ä½¿ç”¨ MicroCity æ‰“å¼€å®ƒï¼Œæˆ–å°†å…¶æ‹–åˆ° MicroCityã€‚ç„¶åæ‚¨å°†åœ¨ Workspace é¢æ¿çš„æ¨¡å—é€‰é¡¹å¡ä¸­æ‰¾åˆ°ä¸€ä¸ªåä¸ºqueryçš„é¡¹ç›®ã€‚åŒå‡»å­é¡¹mainã€‚å¦‚æœå¼¹å‡ºå¯¹è¯æ¡†ï¼Œè¯·é€‰æ‹©01. countriesï¼Œç„¶åç‚¹å‡»ç¡®å®šã€‚ç»“æœå°†æ˜¾ç¤ºåœ¨æ¶ˆæ¯é¢æ¿ä¸­ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/3.1_ui_overview.html",title:"3.1 ç”¨æˆ·ç•Œé¢æ¦‚è§ˆ",pathLocale:"/",contents:[{header:"3.1 ç”¨æˆ·ç•Œé¢æ¦‚è§ˆ",slug:"_3-1-ç”¨æˆ·ç•Œé¢æ¦‚è§ˆ",content:"MicroCityæä¾›äº†ä¸€ä¸ªç®€æ´çš„å›¾å½¢çª—å£ç•Œé¢ï¼Œä»¥ä¾¿äºå¯¹æ•°æ®å’Œæ¨¡å—è¿›è¡Œæ“ä½œã€‚"},{header:"ä¸»çª—å£åŠå…¶ç»„ä»¶",slug:"ä¸»çª—å£åŠå…¶ç»„ä»¶",content:""},{header:"æ”¯æŒçš„æ–‡ä»¶ç±»å‹",slug:"æ”¯æŒçš„æ–‡ä»¶ç±»å‹",content:"MicroCityå¯ä»¥æ‰“å¼€ArcGIS shapefileæ–‡ä»¶(*.shp)ï¼ŒGridsæ–‡ä»¶(*.sgrd)ï¼ŒdBaseæ–‡ä»¶(*.dbf)ï¼ŒTabularæ–‡æœ¬æ–‡ä»¶(*.csv, *.txt)ï¼ŒPoint cloudsç‚¹äº‘æ–‡ä»¶(*.spc)ï¼Œå½±åƒæ–‡ä»¶(*.bmp, *.gif, *.jpg, *.png, *.tif, *.pcx)ä»¥åŠMicroCity 3Dåœºæ™¯æ–‡ä»¶(*.m3d)ã€‚è¿™äº›æ•°æ®æ–‡ä»¶å¯ä»¥åœ¨å·¥ä½œåŒºé¢æ¿çš„æ•°æ®é€‰é¡¹å¡ä¸­è¿›è¡Œç®¡ç†ã€‚æ¨¡å—åº“æ–‡ä»¶(*.dll, *.mcs)å¯ä»¥åœ¨å·¥ä½œåŒºé¢æ¿çš„æ¨¡å—é€‰é¡¹å¡ä¸­è¿›è¡Œç®¡ç†å’Œæ‰§è¡Œã€‚"},{header:"é¡¹ç›®ç®¡ç†",slug:"é¡¹ç›®ç®¡ç†",content:"å·²æ‰“å¼€çš„æ•°æ®æ–‡ä»¶ã€æ¨¡å—åº“æ–‡ä»¶ã€è®¾ç½®å’Œå­çª—å£ä¿¡æ¯å¯ä»¥é€šè¿‡æ–‡ä»¶->é¡¹ç›®èœå•ä¿å­˜æˆ–æ‰“å¼€ä¸€ä¸ªMicroCityé¡¹ç›®(*.mprj)ã€‚mprjæ–‡ä»¶ä¸åŒ…å«ä»»ä½•æ–‡ä»¶æ•°æ®ã€‚ä¸ºæ–¹ä¾¿ç»´æŠ¤ï¼Œé¡¹ç›®ä¸­çš„æ–‡ä»¶åº”æ”¾ç½®åœ¨åŒä¸€æ–‡ä»¶å¤¹æˆ–mprjæ–‡ä»¶çš„å­æ–‡ä»¶å¤¹ä¸­ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/3.2_vector_shapes.html",title:"3.2 çŸ¢é‡å›¾",pathLocale:"/",contents:[{header:"3.2 çŸ¢é‡å›¾",slug:"_3-2-çŸ¢é‡å›¾",content:"MicroCityå¯ä»¥æ‰“å¼€ã€åˆ›å»ºå’Œç¼–è¾‘ArcGIS shapefilesï¼ˆ*.shpï¼‰ï¼Œå³æ‰€è°“çš„Shapesï¼Œå¹¶åœ¨Workspaceé¢æ¿çš„Dataé€‰é¡¹å¡ä¸­è¿›è¡Œç»´æŠ¤ã€‚é€šè¿‡ä½¿ç”¨æ¨¡å—ï¼ˆå‚è§3.7ï¼‰ï¼Œè¿˜å¯ä»¥å¯¼å…¥æˆ–å¯¼å‡ºå…¶ä»–çŸ¢é‡æ–‡ä»¶æ ¼å¼ï¼Œä¾‹å¦‚å¯ä¼¸ç¼©çŸ¢é‡å›¾å½¢ï¼ˆ*.svgï¼‰å’ŒAutoCADç»˜å›¾äº¤æ¢æ ¼å¼ï¼ˆ*.dxfï¼‰ã€‚"},{header:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­Shapes",slug:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­shapes",content:"ç”¨æˆ·å¯ä»¥å•å‡»åŠ è½½æŒ‰é’®æˆ–æ–‡ä»¶->Shapes->åŠ è½½èœå•é¡¹æ¥æ‰“å¼€ArcGIS shapefileï¼ˆ*.shpï¼‰ä½œä¸ºShapesã€‚ä»èœå•ä¸­é€‰æ‹©æ–‡ä»¶->Shapes->æ–°å»ºï¼Œå¼¹å‡ºå¯¹è¯æ¡†å¦‚ä¸‹æ‰€ç¤ºï¼Œå¯ä»¥åˆ›å»ºæ–°çš„Shapesã€‚ç”¨æˆ·å¯ä»¥ä»ç‚¹ï¼Œçº¿å’Œé¢ä¸­é€‰æ‹©å…¶ä¸­ä¸€ç§å½¢çŠ¶ç±»å‹ã€‚è¿˜æ˜¾ç¤ºäº†ArcGIS shapefileï¼ˆ*.shpï¼‰ä¸åŒådBaseæ–‡ä»¶ï¼ˆ*.dbfï¼‰ä¹‹é—´çš„å…³ç³»ã€‚ ä¿å­˜Shapeså¯ä»¥é€šè¿‡å³é”®å•å‡»ä¸Šä¸‹æ–‡èœå•ä¸­çš„ä¿å­˜æˆ–å¦å­˜ä¸ºæ¥å®Œæˆã€‚ä¹Ÿå¯ä»¥ä»èœå•ä¸­å…³é—­Shapeså¹¶å¼¹å‡ºæç¤ºå¯¹è¯æ¡†ä»¥ä¿å­˜å®ƒã€‚"},{header:"æ˜¾ç¤ºå’Œç¼–è¾‘å½¢çŠ¶",slug:"æ˜¾ç¤ºå’Œç¼–è¾‘å½¢çŠ¶",content:"åœ¨æ•°æ®é€‰é¡¹å¡ä¸­åŒå‡»ä¸€ä¸ªå½¢çŠ¶å°†ä¸ºæ‚¨æä¾›åœ°å›¾è§†å›¾ï¼ˆæœ‰å…³åœ°å›¾å’Œå›¾å±‚ï¼Œè¯·å‚è§3.6ï¼‰ã€‚åˆ‡æ¢åˆ°æ“ä½œæŒ‰é’®ï¼Œç„¶åå³é”®å•å‡»å½¢çŠ¶å›¾å±‚ä¸­çš„ä¸€ä¸ªå½¢çŠ¶ï¼Œé€‰æ‹©ç¼–è¾‘æ‰€é€‰å½¢çŠ¶ï¼Œç„¶åè¿›å…¥ç¼–è¾‘æ¨¡å¼ã€‚åœ¨è¿™ä¸ªæ¨¡å¼ä¸‹ï¼Œç”¨æˆ·å¯ä»¥æ·»åŠ /åˆ é™¤éƒ¨åˆ†ä»¥åŠæ·»åŠ /åˆ é™¤å½¢çŠ¶ä¸­çš„ç‚¹ï¼ˆå…³äºå½¢çŠ¶çš„æ•°æ®ç»“æ„ï¼Œè¯·å‚è§2.2ï¼‰ã€‚é€šè¿‡å³é”®å•å‡»ä¸Šä¸‹æ–‡èœå•å±æ€§->è¡¨æ ¼->æ˜¾ç¤ºå¯ä»¥è®¿é—®å½¢çŠ¶çš„ç›¸å…³å±æ€§è¡¨æ ¼ï¼ˆ*.dbfï¼‰ï¼ˆè¯·å‚è§æ•™ç¨‹2.1ï¼‰ã€‚"},{header:"æ˜¾ç¤ºè®¾ç½®å’Œæ•°æ®å¯è§†åŒ–",slug:"æ˜¾ç¤ºè®¾ç½®å’Œæ•°æ®å¯è§†åŒ–",content:"ç”¨æˆ·å¯ä»¥ä»è®¾ç½®é¢æ¿ä¸­æ›´æ”¹å½¢çŠ¶çš„è½®å»“ã€å¡«å……ã€æ ‡ç­¾å’Œå…¶ä»–æ˜¾ç¤ºè®¾ç½®ã€‚ä¸€äº›é€‰é¡¹å¯ä»¥è¿æ¥å±æ€§æ•°æ®å¹¶æä¾›å¯è§†åŒ–åŠŸèƒ½ï¼ˆä¾‹å¦‚2.1ï¼‰ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/3.3_raster_grids.html",title:"3.3 æ …æ ¼å›¾",pathLocale:"/",contents:[{header:"3.3 æ …æ ¼å›¾",slug:"_3-3-æ …æ ¼å›¾",content:"MicroCityå¯ä»¥æ‰“å¼€ã€åˆ›å»ºå’Œç¼–è¾‘SAGA Gridï¼ˆ*.sgrdï¼‰ï¼Œåœ¨å·¥ä½œç©ºé—´é¢æ¿çš„æ•°æ®é€‰é¡¹å¡ä¸­è¢«ç§°ä¸ºGridå¹¶è¿›è¡Œç»´æŠ¤ã€‚å›¾åƒæ–‡ä»¶ï¼ˆ*.bmpã€*.gifã€*.jpgã€*.pngã€*.tifã€*.pcxï¼‰ä¹Ÿå¯ä»¥è¢«ä½œä¸ºGridæ‰“å¼€ã€‚é€šè¿‡ä½¿ç”¨æ¨¡å—ï¼ˆå‚è§3.7ï¼‰ï¼Œå…¶ä»–æ …æ ¼æ–‡ä»¶æ ¼å¼ï¼Œä¾‹å¦‚ESRI Arc/Info Gridï¼ˆ*.adfï¼‰å’ŒSurfer Gridï¼ˆ*.grdï¼‰ï¼Œä¹Ÿå¯ä»¥è¢«å¯¼å…¥æˆ–å¯¼å‡ºã€‚"},{header:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­Grid",slug:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­grid",content:`ç”¨æˆ·å¯ä»¥ç‚¹å‡»LoadæŒ‰é’®æˆ–File->Grid->Loadèœå•é¡¹æ¥æ‰“å¼€ä¸€ä¸ªGridã€‚ä»èœå•File->Grid->Newä¸­å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„Gridï¼Œç„¶åå¼¹å‡ºå¯¹è¯æ¡†: ä¸Šå›¾æ˜¯ä¸€ä¸ªGridçš„æ•°æ®ç»“æ„å’Œå®šä¹‰ã€‚Gridä»å…¶å·¦ä¸‹è§’å¼€å§‹ï¼Œå…·æœ‰åæ ‡**(xMin, yMin)ï¼ŒåŒ…å«NX*NYä¸ªæ–¹å½¢å•å…ƒæ ¼**ã€‚æ¯ä¸ªå•å…ƒæ ¼æœ‰è‡ªå·±çš„æ•´æ•°åæ ‡(X, Y)ï¼ŒèŒƒå›´ä»(0, 0)åˆ°(XMax, YMax)ã€‚
ä¿å­˜Gridå¯é€šè¿‡å³é”®ä¸Šä¸‹æ–‡èœå•Save or Save Asæ¥å®Œæˆã€‚ä¹Ÿå¯ä»¥é€šè¿‡èœå•å…³é—­Gridï¼Œå¹¶è·å¾—ä¸€ä¸ªæç¤ºå¯¹è¯æ¡†æ¥ä¿å­˜å®ƒã€‚`},{header:"æ˜¾ç¤ºå’Œç¼–è¾‘Grids",slug:"æ˜¾ç¤ºå’Œç¼–è¾‘grids",content:"åŒå‡»æ•°æ®é€‰é¡¹å¡ä¸­çš„ä¸€ä¸ªGridå°†ä¸ºæ‚¨æä¾›ä¸€ä¸ªåœ°å›¾è§†å›¾ï¼ˆæœ‰å…³åœ°å›¾å’Œå›¾å±‚ï¼Œè¯·å‚è§3.6ï¼‰ã€‚åˆ‡æ¢ActionæŒ‰é’® ï¼Œç„¶ååœ¨Gridä¸­é€‰æ‹©ä¸€ç³»åˆ—å•å…ƒæ ¼ã€‚ç„¶åå¯ä»¥åœ¨è®¾ç½®é¢æ¿çš„å±æ€§é€‰é¡¹å¡ä¸­ç¼–è¾‘è¿™äº›å•å…ƒæ ¼çš„å€¼ã€‚"},{header:"æ˜¾ç¤ºè®¾ç½®å’Œ3Dè§†å›¾",slug:"æ˜¾ç¤ºè®¾ç½®å’Œ3dè§†å›¾",content:"ç”¨æˆ·å¯ä»¥ä½¿ç”¨è®¾ç½®é¢æ¿æ¥æ˜¾ç¤ºå•å…ƒæ ¼çš„å€¼ï¼Œæ›´æ”¹é¢œè‰²å¹¶è®¾ç½®ç½‘æ ¼çš„é€æ˜åº¦ã€‚ä½¿ç”¨æŒ‰é’®å¯ä»¥åˆ›å»ºä¸€ä¸ªç½‘æ ¼çš„3Dè¡¨é¢ï¼Œå…¶ä¸­å•å…ƒæ ¼çš„å€¼è¢«è½¬æ¢ä¸ºé«˜ç¨‹ï¼ˆè§3.6ï¼‰ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/3.4_3d_scenes.html",title:"3.4 3Dåœºæ™¯",pathLocale:"/",contents:[{header:"3.4 3Dåœºæ™¯",slug:"_3-4-3dåœºæ™¯",content:"MicroCity 3Dåœºæ™¯ï¼ˆ*.m3dï¼‰æ˜¯ä¸€ç§å­˜å‚¨3Dåœºæ™¯ä¿¡æ¯çš„æ•°æ®æ–‡ä»¶æ ¼å¼ã€‚æµè¡Œçš„3Dæ–‡ä»¶æ ¼å¼åŒ…æ‹¬3D Studio Maxï¼ˆ*.3dsï¼‰ï¼ŒWavefront OBJï¼ˆ*.objï¼‰å’Œç«‹ä½“å…‰åˆ»ï¼ˆ*.stlï¼‰å¯ä»¥ä½œä¸ºåœºæ™¯ä¸­çš„å¯¹è±¡è¿›è¡ŒåŠ è½½ï¼ˆè¯¦è§ä¸‹æ–‡ä¸­çš„æ˜¾ç¤ºå’Œç¼–è¾‘3Dåœºæ™¯ï¼‰ï¼Œä½†ä¸èƒ½å­˜å‚¨åœ¨.m3dæ–‡ä»¶ä¸­ã€‚"},{header:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­3Dåœºæ™¯",slug:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­3dåœºæ™¯",content:"ç”¨æˆ·å¯ä»¥ç‚¹å‡»åŠ è½½æŒ‰é’® ï¼Œæˆ–é€‰æ‹©æ–‡ä»¶->åœºæ™¯->åŠ è½½èœå•é¡¹æ¥æ‰“å¼€ä¸€ä¸ªåœºæ™¯ã€‚ä»èœå•é¡¹æ–‡ä»¶->åœºæ™¯->æ–°å»ºå¯ä»¥åˆ›å»ºæ–°çš„åœºæ™¯å¹¶å¡«å†™å¼¹å‡ºå¯¹è¯æ¡†ä¸­çš„ä¿¡æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚ç‚¹å‡»ç¡®å®šæŒ‰é’®ä¹‹åï¼Œå·¥ä½œåŒºé¢æ¿çš„æ•°æ®é€‰é¡¹å¡ä¸­ä¼šå‡ºç°ä¸€ä¸ªé¡¹ç›®ã€‚ç„¶åå¯ä»¥é€šè¿‡å³é”®å•å‡»èœå•æ¥ä¿å­˜æˆ–å…³é—­åœºæ™¯ï¼š"},{header:"æ˜¾ç¤ºå’Œç¼–è¾‘3Dåœºæ™¯",slug:"æ˜¾ç¤ºå’Œç¼–è¾‘3dåœºæ™¯",content:"ä»æ•°æ®é€‰é¡¹å¡åŒå‡»ä¸€ä¸ªåœºæ™¯ä¼šæ˜¾ç¤ºä¸€ä¸ªåœºæ™¯è§†å›¾ã€‚åœ¨åœºæ™¯è§†å›¾ä¸­ï¼Œç”¨é¼ æ ‡å·¦é”®æ‹–æ‹½å¯ä»¥æ—‹è½¬ç›¸æœºï¼Œç”¨é¼ æ ‡å³é”®æ‹–æ‹½å¯ä»¥å¹³ç§»ç›¸æœºã€‚åœ¨åœºæ™¯è§†å›¾ä¸Šç”¨åŒå‡»å·¦é”®å¯ä»¥é€‰æ‹©å¯¹è±¡ï¼Œåœ¨åœºæ™¯è§†å›¾ä¸Šç”¨åŒå‡»å³é”®å¯ä»¥å¼¹å‡ºä¸Šä¸‹æ–‡èœå•ï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰ã€‚å¯ä»¥æ·»åŠ å¯¹è±¡ã€åŠ è½½å¯¹è±¡å’Œè®¾ç½®å¯¹è±¡ç­‰ç­‰ã€‚è¯·æ³¨æ„ï¼Œåæ ‡ç³»ä¸­çš„æ—‹è½¬åº”è¯¥éµå¾ªå·¦æ‰‹è§„åˆ™ã€‚ä¸‹å›¾å±•ç¤ºäº†åæ ‡ç³»çš„ç¤ºä¾‹å’Œæ²¿yè½´æ—‹è½¬çš„ç¤ºä¾‹ï¼š åœ¨å¯¹è±¡çš„ä½ç½®å’Œæ—‹è½¬ä¸­ä½¿ç”¨çš„åæ ‡æ˜¯ç›¸å¯¹äºå…¶çˆ¶å¯¹è±¡çš„ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ–°å¯¹è±¡çš„çˆ¶å¯¹è±¡ä¸ºç©ºã€‚"},{header:"æ˜¾ç¤ºè®¾ç½®",slug:"æ˜¾ç¤ºè®¾ç½®",content:"ç”¨æˆ·å¯ä»¥é€šè¿‡ä½¿ç”¨è®¾ç½®é¢æ¿æ›´æ”¹åœºæ™¯çš„èƒŒæ™¯è‰²ã€å‚è€ƒç½‘æ ¼æˆ–å…¶ä»–æ˜¾ç¤ºé€‰é¡¹ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚"}]},{path:"/docs/3.5_tables.html",title:"3.5 è¡¨æ ¼",pathLocale:"/",contents:[{header:"3.5 è¡¨æ ¼",slug:"_3-5-è¡¨æ ¼",content:"åŒ…æ‹¬ dBase æ–‡ä»¶ (*.dbf)ã€æ–‡æœ¬æ–‡ä»¶ (*.txt) å’Œé€—å·åˆ†éš”å€¼ (*.csv) åœ¨å†…çš„è¡¨æ ¼æ–‡ä»¶å¯ä»¥åœ¨ MicroCity ä¸­æ‰“å¼€å¹¶ä¿å­˜ä¸ºè¡¨æ ¼ã€‚"},{header:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­è¡¨æ ¼",slug:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜å’Œå…³é—­è¡¨æ ¼",content:"ç”¨æˆ·å¯ä»¥å•å‡»åŠ è½½æŒ‰é’® ï¼Œæˆ–é€‰æ‹©æ–‡ä»¶->è¡¨æ ¼->åŠ è½½èœå•é¡¹æ¥æ‰“å¼€ä¸€ä¸ªè¡¨æ ¼æ–‡ä»¶ã€‚å¯ä»¥ä»æ–‡ä»¶->è¡¨æ ¼->æ–°å»ºèœå•é¡¹ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„è¡¨æ ¼ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºçš„å¼¹å‡ºå¯¹è¯æ¡†ã€‚è¦ä¿å­˜ä¸€ä¸ªè¡¨æ ¼ï¼Œå¯ä»¥å³é”®å•å‡»ä¸Šä¸‹æ–‡èœå•ä¸­çš„ä¿å­˜æˆ–å¦å­˜ä¸ºé€‰é¡¹ã€‚"},{header:"æ˜¾ç¤ºå’Œç¼–è¾‘è¡¨æ ¼",slug:"æ˜¾ç¤ºå’Œç¼–è¾‘è¡¨æ ¼",content:'åŒå‡»æ•°æ®é€‰é¡¹å¡ä¸­çš„è¡¨æ ¼ï¼Œå°†æ˜¾ç¤ºä¸€ä¸ªè¡¨æ ¼è§†å›¾ã€‚é€šè¿‡å³é”®å•å‡»è¡¨å¤´å¯ä»¥ä¿®æ”¹è¡¨æ ¼çš„ç»“æ„ã€‚å¦‚æœå•å‡»"æ·»åŠ å­—æ®µ"ï¼Œå°†æ˜¾ç¤ºä¸€ä¸ªå¼•å¯¼å¯¹è¯æ¡†ï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰ã€‚å¦‚æœè¦å‘è¡¨æ ¼ä¸­æ’å…¥ä¸€æ¡è®°å½•ï¼Œå¯ä»¥å³é”®å•å‡»è¡¨æ ¼å·¦ä¾§çš„æ•°å­—ï¼Œå¹¶é€‰æ‹©ä¸€ä¸ªä¸Šä¸‹æ–‡èœå•é¡¹ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚'}]},{path:"/docs/3.6_maps_and_layers.html",title:"3.6 åœ°å›¾å’Œå›¾å±‚",pathLocale:"/",contents:[{header:"3.6 åœ°å›¾å’Œå›¾å±‚",slug:"_3-6-åœ°å›¾å’Œå›¾å±‚",content:"åœ¨MicroCityä¸­ï¼Œå½¢çŠ¶å’Œç½‘æ ¼å¯ä»¥æ˜¾ç¤ºåœ¨åœ°å›¾ä¸­ã€‚æ¯ä¸ªåœ°å›¾å¯ä»¥åŒ…å«å¤šä¸ªå›¾å±‚ï¼Œæ¯ä¸ªå›¾å±‚å¯¹åº”ä¸€ä¸ªå½¢çŠ¶æˆ–ä¸€ä¸ªç½‘æ ¼ã€‚"},{header:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜ã€æ‰“å°å’Œå…³é—­åœ°å›¾",slug:"æ‰“å¼€ã€åˆ›å»ºã€ä¿å­˜ã€æ‰“å°å’Œå…³é—­åœ°å›¾",content:"ç”±äºåœ°å›¾æ˜¯åŸºäºå½¢çŠ¶å’Œç½‘æ ¼çš„ï¼Œå®ƒä»¬ä¸èƒ½ç‹¬ç«‹ä¿å­˜æˆ–æ‰“å¼€ï¼Œä½†å¯ä»¥ä¸ä¸€ä¸ªMicroCityé¡¹ç›®(*.mprj)ä¸€åŒä¿å­˜æˆ–æ‰“å¼€ã€‚åˆ›å»ºä¸€ä¸ªåœ°å›¾æ˜¯é€šè¿‡åœ¨å·¥ä½œåŒºé¢æ¿çš„æ•°æ®é€‰é¡¹å¡ä¸­åŒå‡»ä¸€ä¸ªå½¢çŠ¶æˆ–ç½‘æ ¼æ¥å®ç°çš„ã€‚åœ°å›¾çª—å£åŒ…å«å››ä¸ªåæ ‡æ ï¼Œå¯ç”¨äºå®šä½å¯¹è±¡ï¼ˆè§ä¸‹æ–‡ï¼‰ã€‚åœ°å›¾ä¹Ÿå¯ä»¥é€šè¿‡å·¥ä½œåŒºé¢æ¿çš„åœ°å›¾é€‰é¡¹å¡çš„ä¸Šä¸‹æ–‡èœå•è¿›è¡Œæ‰“å°æˆ–å…³é—­ã€‚"},{header:"åœ¨åœ°å›¾ä¸­æ·»åŠ ã€ç§»åŠ¨ã€éšè—å’Œå…³é—­å›¾å±‚",slug:"åœ¨åœ°å›¾ä¸­æ·»åŠ ã€ç§»åŠ¨ã€éšè—å’Œå…³é—­å›¾å±‚",content:"ä¸€ä¸ªåœ°å›¾å¯ä»¥æœ‰å¤šä¸ªå›¾å±‚ï¼Œæ¯ä¸ªå›¾å±‚è¡¨ç¤ºä¸€ä¸ªæ•°æ®é¡¹ã€‚å¯ä»¥é€šè¿‡åœ¨æ•°æ®é€‰é¡¹å¡ä¸­åŒå‡»ä¸€ä¸ªå½¢çŠ¶æˆ–ç½‘æ ¼æ¥å°†ä¸€ä¸ªå›¾å±‚æ·»åŠ åˆ°ä¸€ä¸ªåœ°å›¾ä¸­ã€‚è¾ƒä½çš„å›¾å±‚å¯ä»¥è¢«ä¸Šé¢çš„å›¾å±‚é®æŒ¡ã€‚å¯ä»¥é€šè¿‡æ‹–åŠ¨æ¥ç§»åŠ¨ä¸€ä¸ªå›¾å±‚ï¼Œé€šè¿‡åŒå‡»æ¥éšè—ä¸€ä¸ªå›¾å±‚ï¼Œé€šè¿‡èœå•æ¥å…³é—­ä¸€ä¸ªå›¾å±‚ï¼ˆå¦‚ä¸‹æ‰€ç¤ºï¼‰ã€‚"},{header:"æ§åˆ¶åœ°å›¾è§†å›¾",slug:"æ§åˆ¶åœ°å›¾è§†å›¾",content:`å½“é€‰æ‹©ä¸€ä¸ªæ•°æ®é¡¹æˆ–å›¾å±‚æ—¶ï¼Œè¯¥å›¾å±‚è¢«ç§°ä¸ºæ´»åŠ¨å›¾å±‚ã€‚å¯ä»¥åˆ‡æ¢æ“ä½œæŒ‰é’®æ¥é€‰æ‹©å’Œç¼–è¾‘æ´»åŠ¨å›¾å±‚ä¸­çš„å¯¹è±¡ã€‚é€šè¿‡åˆ‡æ¢ç¼©æ”¾æŒ‰é’®æˆ–å¹³ç§»æŒ‰é’®ï¼Œå¯ä»¥å¯¹åœ°å›¾è¿›è¡Œç¼©æ”¾å’Œå¹³ç§»æ“ä½œã€‚å¦‚æœåœ¨åœ°å›¾ä¸­è¿·å¤±äº†æ–¹å‘ï¼Œå¯ä»¥ä½¿ç”¨ç¼©æ”¾è‡³å…¨å›¾èŒƒå›´æŒ‰é’®æ¥æŸ¥çœ‹æ•´ä¸ªåœ°å›¾ã€‚å…¶ä»–çš„ç¼©æ”¾æ§åˆ¶æŒ‰é’®å¯ç”¨äºæ–¹ä¾¿åœ°æµè§ˆåœ°å›¾ã€‚
å¦‚æœè¦æ¯”è¾ƒä¸¤ä¸ªæˆ–å¤šä¸ªåœ°å›¾ä¹‹é—´çš„å·®å¼‚ï¼Œå¯ä»¥ä½¿ç”¨åŒæ­¥æŒ‰é’®ã€‚å¯ä»¥ä½¿ç”¨å°ºå­æŒ‰é’®æµ‹é‡è·ç¦»ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨åœ°çƒåæ ‡ç³»ä¸‹æµ‹å¾—çš„è·ç¦»å•ä½æ˜¯å…¬é‡Œã€‚å¯ä»¥åœ¨åœ°å›¾çš„è®¾ç½®é¢æ¿ä¸­å°†åæ ‡ç³»æ›´æ”¹ä¸ºéåœ°çƒï¼Œä»è€Œè·å–æ²¡æœ‰å•ä½çš„ç¬›å¡å°”è·ç¦»ã€‚
ç‚¹å‡»3DæŒ‰é’®å¯ä»¥åˆ›å»ºä¸€ä¸ª3Dè¡¨é¢åœ°å›¾ï¼Œéœ€è¦ä¸€ä¸ªé€‚å½“å¤§å°çš„ç½‘æ ¼ï¼ˆå‚è§3.3ï¼‰æ¥å®ç°ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/3.7_modules.html",title:"3.7 æ‹“å±•æ¨¡å—",pathLocale:"/",contents:[{header:"3.7 æ‹“å±•æ¨¡å—",slug:"_3-7-æ‹“å±•æ¨¡å—",content:"MicroCityçš„åŠŸèƒ½å¯ä»¥é€šè¿‡æ¨¡å—è¿›è¡Œæ‹“å±•ï¼Œå…¶ä¸­ä¹‹ä¸€æ˜¯SAGAæ¨¡å—ï¼ˆ*.dllï¼‰ã€‚SAGAæ¨¡å—åŒ…å«è®¸å¤šæœ‰ç”¨çš„å½¢çŠ¶ï¼ˆShapesï¼‰å’Œç½‘æ ¼ï¼ˆGridsï¼‰åº“ã€‚å¦ä¸€ç§ç±»å‹çš„æ¨¡å—æ˜¯MicroCityè„šæœ¬ï¼ˆ*.mcsï¼‰ï¼Œå¯ä»¥ä½¿ç”¨è¿›è¡Œç¼–è¾‘å’Œè°ƒè¯•ï¼ˆè¯·å‚é˜…4.1ï¼‰ã€‚"},{header:"åŠ è½½ã€å…³é—­å’Œæ‰§è¡Œæ¨¡å—",slug:"åŠ è½½ã€å…³é—­å’Œæ‰§è¡Œæ¨¡å—",content:"å¯ä»¥é€šè¿‡ç‚¹å‡»åŠ è½½æŒ‰é’®æˆ–æ¨¡å—->åŠ è½½æ¨¡å—åº“èœå•é¡¹å°†æ¨¡å—åŠ è½½åˆ°MicroCityä¸­ã€‚å·¥ä½œåŒºé¢æ¿çš„æ¨¡å—é€‰é¡¹å¡å°†æ˜¾ç¤ºå·²åŠ è½½çš„åº“æ–‡ä»¶ï¼ˆæ¯ä¸ªå¯¹åº”ä¸€ä¸ªæ–‡ä»¶ï¼‰åŠå…¶åŒ…å«çš„æ¨¡å—ã€‚å¯ä»¥é€šè¿‡ä¸Šä¸‹æ–‡èœå•å…³é—­æˆ–é‡æ–°åŠ è½½æ¨¡å—åº“ã€‚æ‰§è¡Œæ¨¡å—æœ‰å¤šç§æ–¹å¼ï¼šåŒå‡»æ¨¡å—ï¼Œç‚¹å‡»è®¾ç½®é¢æ¿çš„æ‰§è¡ŒæŒ‰é’®ï¼Œæˆ–ç‚¹å‡»æ‰§è¡Œä¸Šä¸‹æ–‡èœå•é¡¹ã€‚è¿˜å¯ä»¥é€šè¿‡ç‚¹å‡»è°ƒè¯•ä¸Šä¸‹æ–‡èœå•é¡¹æ¥è°ƒè¯•MicroCityè„šæœ¬æ¨¡å—ï¼Œè¿™éœ€è¦åå°è¿è¡ŒScriptEditorã€‚MicroCityè¿˜å¯ä»¥æ•è·è¿è¡Œæ—¶é”™è¯¯å¹¶æš‚åœæ¨¡å—çš„æ‰§è¡Œã€‚"},{header:"åŠ é€Ÿã€åœæ­¢æ¨¡å—çš„æ‰§è¡Œ",slug:"åŠ é€Ÿã€åœæ­¢æ¨¡å—çš„æ‰§è¡Œ",content:`MicroCity Script æ¨¡å—æ˜¯ä½¿ç”¨éå¸¸å¿«é€Ÿçš„ Lua è¯­è¨€åˆ›å»ºçš„ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¦‚æœæ‚¨æƒ³è¦æ›´å¿«çš„æ‰§è¡Œé€Ÿåº¦ï¼Œå¯ä»¥åœ¨ å·¥ä½œåŒº é¢æ¿çš„ æ¨¡å— æ ‡ç­¾ä¸­ç‚¹å‡» æ¨¡å—åº“ï¼Œç„¶ååœ¨ è®¾ç½® é¢æ¿ä¸­å°† è„šæœ¬è¿è¡Œæ¨¡å¼ ä» å®‰å…¨æ¨¡å¼ åˆ‡æ¢åˆ° å¿«é€Ÿæ¨¡å¼ã€‚ç„¶å MicroCity å°†ä½¿ç”¨ LuaJIT æ¥æ‰§è¡Œæ¨¡å—ã€‚
å¦‚æœä¸€ä¸ªæ¨¡å—æ­£åœ¨è¢«æ‰§è¡Œï¼Œå¯ä»¥é€šè¿‡ç‚¹å‡»ç›¸åº”çš„ è®¾ç½® ä¸­çš„ æ‰§è¡Œ æŒ‰é’®æ¥åœæ­¢å®ƒã€‚åœ¨ å®‰å…¨æ¨¡å¼ ä¸‹ï¼Œæ‰§è¡Œå¯ä»¥ç«‹å³åœæ­¢ï¼Œä½†åœ¨ å¿«é€Ÿæ¨¡å¼ ä¸‹ï¼Œåœæ­¢æ“ä½œå–å†³äºè„šæœ¬ä¸­è°ƒç”¨çš„ GetReady() å‡½æ•°ï¼ˆå‚è§ 4.2ï¼‰ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.1_si_overview.html",title:"4.1 è„šæœ¬æ¦‚è§ˆ",pathLocale:"/",contents:[{header:"4.1 è„šæœ¬æ¦‚è§ˆ",slug:"_4-1-è„šæœ¬æ¦‚è§ˆ",content:"MicroCityä½¿ç”¨æ¨¡å—ï¼ˆè¯¦è§3.7ï¼‰æ¥æ‰©å±•å…¶åŠŸèƒ½ã€‚æ¨¡å—çš„ä¸€ç§ç±»å‹æ˜¯MicroCityè„šæœ¬ï¼ˆ*.mcsï¼‰ï¼Œå¯ä»¥åœ¨ScriptEditorä¸­è¿›è¡Œç¼–è¾‘å’Œè°ƒè¯•ã€‚"},{header:"è„šæœ¬ç¼–è¾‘å™¨",slug:"è„šæœ¬ç¼–è¾‘å™¨",content:""},{header:"ç¼–ç å’Œè°ƒè¯•MicroCityè„šæœ¬",slug:"ç¼–ç å’Œè°ƒè¯•microcityè„šæœ¬",content:"ScriptEditoråŸºäºZeroBraneã€‚å¯ä»¥åœ¨é‚£é‡Œæ‰¾åˆ°è¯¦ç»†çš„ä¿¡æ¯ã€‚è¦è¿›è¡Œè°ƒè¯•ï¼Œæ‚¨åº”è¯¥ä¿æŒScript Editoræ‰“å¼€ã€‚ç„¶åä»MicroCityä¸­å³é”®ç‚¹å‡»æ¨¡å—ï¼Œé€‰æ‹©ä¸Šä¸‹æ–‡èœå•ä¸­çš„è°ƒè¯•é¡¹ï¼ˆè¯¦è§3.7ï¼‰ã€‚æ‰§è¡Œè¿‡ç¨‹å¯ä»¥åœ¨ScriptEditorçš„Code Viewä¸­æ˜¾ç¤ºã€‚æ‚¨å¯ä»¥ä½¿ç”¨è°ƒè¯•æŒ‰é’®æ§åˆ¶æ‰§è¡Œå¹¶æŸ¥çœ‹å˜é‡ã€‚"},{header:"Luaè¯­è¨€å’ŒåµŒå…¥å‡½æ•°",slug:"luaè¯­è¨€å’ŒåµŒå…¥å‡½æ•°",content:`MicroCityä½¿ç”¨Lua 5.1ä½œä¸ºå…¶è„šæœ¬è¯­è¨€ã€‚å¯ä»¥åœ¨é‚£é‡Œæ‰¾åˆ°å‚è€ƒæ‰‹å†Œã€‚MicroCityåœ¨Luaä¸­åµŒå…¥äº†è®¸å¤šæœ‰ç”¨çš„å‡½æ•°ï¼Œä¸ä»…å¯ä»¥æ§åˆ¶ç”¨æˆ·ç•Œé¢ã€æ“ä½œæ•°æ®ï¼Œè¿˜å¯ä»¥è§£å†³æ•°å­¦æ¨¡å‹å’Œè¿è¡Œä»¿çœŸç­‰é—®é¢˜ã€‚è¯·é˜…è¯»ä»¥ä¸‹ç« èŠ‚ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚
æœ¬å‚è€ƒèµ„æ–™ä¸­çš„çº¦å®šï¼š
Luaä¸­æœ‰å››ç§ä¸»è¦çš„æ•°æ®ç±»å‹å¯ä»¥ä½œä¸ºå‚æ•°é€šè¿‡åµŒå…¥å‡½æ•°ä¼ é€’ï¼Œåˆ†åˆ«æ˜¯æ•°å­—(Number)ã€å¸ƒå°”å€¼(Boolean)ã€å­—ç¬¦ä¸²(String)å’Œå¯¹è±¡(Object)ã€‚å¯¹è±¡ç±»å‹åŒ…æ‹¬å†…ç½®çš„Luaå¯¹è±¡ï¼Œå¦‚è¡¨(Table)ã€å‡½æ•°(Function)å’Œçº¿ç¨‹(Thread)ï¼Œä»¥åŠMicroCityå¯¹è±¡ï¼Œå¦‚å½¢çŠ¶(Shapes)ã€ç½‘æ ¼(Grid)ã€è¡¨(Table)å’Œåœºæ™¯(Scene)ã€‚ä¸ºäº†æ˜ç¡®åµŒå…¥å‡½æ•°ä¸­çš„å‚æ•°ç±»å‹ï¼Œåœ¨å‡½æ•°æè¿°ä¸­æˆ‘ä»¬ä½¿ç”¨å¤§å†™ã€å¼•å·å’Œè¯­ä¹‰ä¿¡æ¯æ¥é¿å…æ­§ä¹‰ã€‚å‚æ•°çš„å°å†™å•è¯è¡¨ç¤ºæ•°å­—ã€‚æœ‰æ—¶å€™ä¸ºäº†è¡¨ç¤ºæ•´æ•°å‚æ•°ï¼Œä¼šåœ¨å•è¯åé¢åŠ ä¸Šå­—æ¯'i'ï¼Œå¦‚iFieldã€‚ä»¥å­—æ¯'b'å¼€å¤´å¹¶è·Ÿéšä¸€ä¸ªå•è¯è¡¨ç¤ºå¸ƒå°”å€¼ï¼Œå¦‚bShowã€‚ç”¨å¼•å·æ‹¬èµ·æ¥çš„å•è¯è¡¨ç¤ºå­—ç¬¦ä¸²ã€‚å¤§å†™çš„å•è¯è¡¨ç¤ºå¯¹è±¡æˆ–å…³é”®å­—ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªåµŒå…¥å‡½æ•°æè¿°çš„ç¤ºä¾‹ã€‚
AddParameter(Module, ParentNode, "Value", "id" [, default = 0])
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒModuleå‚æ•°åº”è¯¥æ˜¯ä¸€ä¸ªModuleå¯¹è±¡ã€‚ParentNodeå‚æ•°åº”è¯¥æ˜¯ä¸€ä¸ªNodeå¯¹è±¡ï¼Œä½†å®ƒä½œä¸ºä¸€ä¸ªçˆ¶èŠ‚ç‚¹ã€‚"Value"å‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½†å®ƒä»£è¡¨MicroCityä¸­çš„å†…ç½®ç±»å‹Valueï¼Œå› æ­¤è¿™ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸èƒ½æ”¹å˜çš„ã€‚*"id"*å‚æ•°åº”è¯¥æ˜¯ä¸€ä¸ªç”¨æˆ·æŒ‡å®šçš„å­—ç¬¦ä¸²ã€‚defaultå‚æ•°æ˜¯ä¸€ä¸ªæ•°å­—ã€‚æ–¹æ‹¬å·ä¸­çš„å†…å®¹æ˜¯å¯é€‰çš„ã€‚å‚æ•°ä¹‹é—´çš„ç«–çº¿è¡¨ç¤º"æˆ–"çš„å…³ç³»ã€‚
ç¼–ç æ ¼å¼ï¼š
MicroCityä½¿ç”¨ANSIç¼–ç æ ¼å¼è¯»å†™æ•°æ®ï¼Œæ¯”å¦‚shpã€txtã€csvå’Œdbfç­‰ã€‚ScriptEditorå’ŒåµŒå…¥å‡½æ•°ä½¿ç”¨UTF-8ç¼–ç æ ¼å¼è¯»å†™æ•°æ®ï¼Œæ¯”å¦‚txtæˆ–csvç­‰ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.2_ui_control.html",title:"4.2 æ§åˆ¶ç”¨æˆ·ç•Œé¢",pathLocale:"/",contents:[{header:"4.2 æ§åˆ¶ç”¨æˆ·ç•Œé¢",slug:"_4-2-æ§åˆ¶ç”¨æˆ·ç•Œé¢",content:'Microcity Script å¯ç”¨äºæ§åˆ¶ç”¨æˆ·ç•Œé¢ä¸Šçš„ä¸€äº›åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ¨¡å—ã€æ•°æ®å¯¹è±¡ã€æ¶ˆæ¯ç­‰ç­‰ã€‚åœ¨ ScriptEditor çš„é¡¹ç›®æ ‡ç­¾çš„"user_interface"æ–‡ä»¶å¤¹ä¸­å¯ä»¥æ‰¾åˆ°ä¸€äº›ç¤ºä¾‹ä»£ç ã€‚'},{header:"åŸºæœ¬ç”¨æˆ·ç•Œé¢",slug:"åŸºæœ¬ç”¨æˆ·ç•Œé¢",content:`Print ("hello" [,...])
åœ¨æ¶ˆæ¯é¢æ¿ä¸­æ‰“å°æ•°å€¼ã€‚
Note ("hello" [,...])
é€šçŸ¥ç”¨æˆ·å¹¶æš‚åœæ‰§è¡Œã€‚
SetProcessText ("processing")
åœ¨MicroCityçš„å·¦ä¸‹è§’è®¾ç½®ä¸€ä¸ªæ–‡æœ¬ã€‚
SetProgress (position, range)
è®¾ç½®ä½äºMicroCityå³ä¸‹è§’çš„è¿›åº¦æ¡çš„ position/range å€¼ã€‚
Sleep (milliseconds)
æš‚åœæ‰§è¡Œ milliseconds æ¯«ç§’ã€‚
GetReady ()
MicroCityä¸Luaå¼•æ“å…±äº«åŒä¸€çº¿ç¨‹ã€‚Luaä¸­çš„è®¡ç®—é‡è¾ƒå¤§ä¼šé˜»å¡MicroCityç•Œé¢ã€‚åœ¨å†…éƒ¨ä½¿ç”¨è¯¥å‡½æ•°å¯ä»¥ä½¿MicroCityç•Œé¢å“åº”ç”¨æˆ·æ“ä½œã€‚å¦‚æœç”¨æˆ·å–æ¶ˆå½“å‰æ‰§è¡Œï¼Œåˆ™è¿”å›falseã€‚
GetClickXY ()
è¿”å›ç”¨æˆ·åœ¨åœ°å›¾è§†å›¾ä¸­ç‚¹å‡»çš„ x,y åæ ‡ã€‚
GetDragExtent ()
è¿”å›ç”¨æˆ·ä½¿ç”¨é¼ æ ‡åœ¨åœ°å›¾è§†å›¾ä¸­æ‹–åŠ¨çŸ©å½¢æ—¶çš„åº•éƒ¨å·¦ä¾§å’Œé¡¶éƒ¨å³ä¾§åæ ‡ï¼šLxï¼ŒByï¼ŒRxï¼ŒTyã€‚`},{header:"æ•°æ®å¯¹è±¡",slug:"æ•°æ®å¯¹è±¡",content:`PATH
å†…éƒ¨å…¨å±€å˜é‡ï¼Œä¿å­˜å½“å‰å·¥ä½œç›®å½•çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚"c:\\microcity"ã€‚
Open (".\\\\shapes.shp" [, ".\\\\grid.sgrd" [, ".\\\\table.dbf" [, ".\\\\scene.m3d" , ...]]])
ä»å½“å‰å·¥ä½œç›®å½•æˆ–æ‰“å¼€çš„æ•°æ®ä¸­æ‰“å¼€å¹¶è¿”å›Shapesã€Tableã€Gridå’ŒSceneå¯¹è±¡ã€‚
Close (Shapes|Grid|Table|Scene|Network|RndEngine|LPModel)
å…³é—­å·²æ‰“å¼€æˆ–åˆ›å»ºçš„Shapesã€Tableã€Gridã€Sceneã€Networkã€RndEngineæˆ–LPModelå¯¹è±¡ã€‚
Update (Shapes|Grid|Table [, bShow = true])
åœ¨MicroCityä¸­æ›´æ–°Shapesã€Gridæˆ–Tableå¯¹è±¡çš„å½“å‰æ›´æ”¹ã€‚bShowè¡¨ç¤ºæ˜¯å¦åˆ›å»ºå¯¹è±¡çš„è§†å›¾ã€‚å¦‚æœç”¨æˆ·å–æ¶ˆå½“å‰æ‰§è¡Œï¼Œè¿”å›falseã€‚
CreateMap ("name", Shapes1|Grid1 [, Shapes2|Grid2, ...])
åˆ›å»ºä¸€ä¸ªåœ°å›¾è§†å›¾ï¼Œä»¥æ˜¾ç¤ºæŒ‰å‚æ•°ä¸­çš„é¡ºåºåˆ†å±‚æ’åˆ—çš„å¯¹è±¡ã€‚`},{header:"æ¨¡å—å’Œå‚æ•°",slug:"æ¨¡å—å’Œå‚æ•°",content:`AddModule ("Function" [, "name"]) æ­¤å‡½æ•°å¯ä»¥å°†Luaå‡½æ•°ä½œä¸ºæ¨¡å—æ·»åŠ åˆ°å½“å‰æ¨¡å—åº“ã€‚æ¨¡å—çš„é»˜è®¤åç§°æ˜¯å‡½æ•°çš„åç§°ã€‚è¿”å›ä¸€ä¸ªModuleå¯¹è±¡ã€‚
function AddParameter(Module, ParentNode, "Node", "id")
function AddParameter(Module, ParentNode, "Value", "id" [, default = 0])
function AddParameter(Module, ParentNode, "Range", "id" [, low = 0 [, high = 1]])
function AddParameter(Module, ParentNode, "Check", "id" [, default = 0])
function AddParameter(Module, ParentNode, "String", "id" [, "string" = "")
function AddParameter(Module, ParentNode, "Choice", "id" [, "choice1|choice2|" [, choice = 1]])
function AddParameter(Module, ParentNode, "File", "id" [, "c:\\\\default.txt" = ""])
function AddParameter(Module, ParentNode, "Color", "id" [, "color" = "255 255 255")
function AddParameter(Module, ParentNode, "Shapes", "id")
function AddParameter(Module, ParentNode, "Grid", "id")
function AddParameter(Module, ParentNode, "Scene", "id")
function AddParameter(Module, ParentNode, "Table", "id")
function AddParameter(Module, ParentNode, "Field", "id")
è¿™äº›å‡½æ•°å¯ä»¥åœ¨æ¨¡å—çš„è®¾ç½®é¢æ¿ä¸­æ·»åŠ å‚æ•°ã€‚è¿”å›ç›¸åº”çš„å€¼æˆ–å¯¹è±¡ã€‚ParentNode å¯ä»¥è®¾ç½®ä¸º AddParameter å‡½æ•°çš„ç¬¬ä¸€ä¸ªè¿”å›å€¼ã€‚å¦‚æœ "Field" åœ¨ç¬¬ä¸‰ä¸ªä½ç½®ï¼Œåˆ™ parent_node å¯ä»¥è®¾ç½®ä¸º Table æˆ– Shapes å¯¹è±¡ï¼Œä»¥è·å–å…¶å±æ€§è¡¨çš„å¤´éƒ¨ã€‚
GetParameter(Shapes|Table|Grid|Scene|Module, "id")
ä»å¯¹è±¡çš„è®¾ç½®é¢æ¿ä¸­è¿”å›æŒ‡å®šçš„å‚æ•°ã€‚
SetParameter(Shapes|Table|Grid|Scene|Module, "id", Number | "String" | Object)
åœ¨å¯¹è±¡çš„è®¾ç½®é¢æ¿ä¸­è®¾ç½®æŒ‡å®šçš„å‚æ•°ã€‚å¦‚æœæˆåŠŸï¼Œåˆ™è¿”å› trueã€‚è¯·æ³¨æ„ï¼Œé€‰æ‹©å‚æ•°åº”ä»1å¼€å§‹ã€‚å¯ä»¥åœ¨ä¸‹å›¾ä¸­çš„å‚æ•°å¸®åŠ©æ–‡æœ¬ä¸­æ‰¾åˆ°å‚æ•°çš„ "id"ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.3_shapes_and_tables.html",title:"4.3 çŸ¢é‡å›¾å½¢å’Œè¡¨æ ¼",pathLocale:"/",contents:[{header:"4.3 çŸ¢é‡å›¾å½¢å’Œè¡¨æ ¼",slug:"_4-3-çŸ¢é‡å›¾å½¢å’Œè¡¨æ ¼",content:'ç”¨æˆ·å¯ä»¥ä½¿ç”¨ MicroCity è„šæœ¬æ“ä½œ å½¢çŠ¶ï¼ˆShapesï¼‰ å’Œ è¡¨æ ¼ï¼ˆTablesï¼‰ã€‚æœ‰å…³å½¢çŠ¶ï¼ˆShapesï¼‰çš„è¯¦ç»†æ•°æ®ç»“æ„ï¼Œæ‚¨å¯ä»¥å‚è€ƒä¸Šä¸€ç« èŠ‚ 2.2 å’Œ 3.2ã€‚ç”±äºå½¢çŠ¶ï¼ˆShapesï¼‰å¯ä»¥è¢«è§†ä¸ºå¸¦æœ‰åœ°ç†æ•°æ®çš„è¡¨æ ¼ï¼ˆTablesï¼‰ï¼Œå› æ­¤ä¸€äº›ç”¨äºè¡¨æ ¼æ•°æ®æ“ä½œçš„åµŒå…¥å‡½æ•°å¯ä»¥åœ¨**å½¢çŠ¶ï¼ˆShapesï¼‰å’Œè¡¨æ ¼ï¼ˆTablesï¼‰ä¸­åŒæ—¶ä½¿ç”¨ã€‚æœ¬ç« èŠ‚çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨é¡¹ç›®ï¼ˆProjectï¼‰**é€‰é¡¹å¡çš„"shapes_samples"æ–‡ä»¶å¤¹ä¸­æ‰¾åˆ°ï¼Œè¯¥æ–‡ä»¶å¤¹ä½äº ScriptEditorã€‚'},{header:"è¡¨æ ¼æ•°æ®æ“ä½œ",slug:"è¡¨æ ¼æ•°æ®æ“ä½œ",content:`CreateShapes ("name", "Point|Line|Polygon")
è¿”å›ä¸€ä¸ª Shapes å¯¹è±¡ã€‚
CreateTable ("Name")
è¿”å›ä¸€ä¸ª Table å¯¹è±¡ã€‚
GetFieldCount (Shapes|Table)
è¿”å› Shapes æˆ– Table ä¸­å­—æ®µçš„æ•°é‡ã€‚
GetField (Shapes|Table, iField)
è¾“å…¥å­—æ®µçš„ç´¢å¼•ï¼ˆä» 1 å¼€å§‹ï¼‰å¹¶è¿”å›å­—æ®µåå’Œç±»å‹ï¼ˆ"Int"ã€"Float"ã€"Double" æˆ– "String"ï¼‰ã€‚
AddField (Shapes|Table, "field1", "Int|Float|Double|String" [, "field2", "Int|Float|Double|String", ...])
å‘ *Table æˆ– Shapes æ·»åŠ å­—æ®µï¼Œå¹¶æŒ‰ç…§é¡ºåºè¿”å›å¸ƒå°”å€¼ï¼ˆtrue æˆ– falseï¼‰ã€‚
DelField (Shapes|Table, iField)
æˆåŠŸåˆ é™¤å­—æ®µæ—¶è¿”å› trueã€‚
GetRecCount (Shapes|Table)
è¿”å› Shapes æˆ– Table ä¸­çš„è®°å½•æ€»æ•°ã€‚
AddRecord (Shapes|Table)
å‘ Shapes æˆ– Table æ·»åŠ ä¸€æ¡è®°å½•ï¼Œå¹¶è¿”å›è¯¥è®°å½•çš„ç´¢å¼•ã€‚
GetValue (Shapes|Table, "field_name", index1 [, index2, ...])
ä»æŒ‡å®šå­—æ®µå’Œ Shapes æˆ– Table çš„ç´¢å¼•ä¸­æ£€ç´¢å€¼ã€‚æŒ‰ç…§ç´¢å¼•çš„é¡ºåºè¿”å›å¤šä¸ªå€¼ã€‚
SetValue (Shapes|Table, value, "field_name", index1 [, index2, ...])
ä¸ºæŒ‡å®šå­—æ®µå’Œ Shapes æˆ– Table çš„ç´¢å¼•è®¾ç½®å€¼ã€‚`},{header:"åœ°ç†æ•°æ®æ“ä½œ",slug:"åœ°ç†æ•°æ®æ“ä½œ",content:`GetSelections (Shapes)
ä»Shapesä¸­è¿”å›æ‰€é€‰çš„å½¢çŠ¶å¯¹è±¡ã€‚
GetShape (Shapes, index1 [, index2, ...])
æŒ‰ç´¢å¼•é¡ºåºä»Shapesä¸­è¿”å›Shapeå¯¹è±¡ã€‚
AddShape (Shapes, Shape)
å°†Shapeå¯¹è±¡æ·»åŠ åˆ°Shapesä¸­å¹¶è¿”å›å…¶ç´¢å¼•ã€‚
AddShape (Shapes [, x1, y1, x2, y2, ...])
å°†å®šä¹‰ä¸ºç‚¹çš„Shapeå¯¹è±¡æ·»åŠ åˆ°Shapesä¸­ã€‚è¿”å›Shapeå¯¹è±¡å’Œç´¢å¼•ã€‚
DelShape (Shape|Shapes)
åˆ é™¤ä¸€ä¸ªShapeæˆ–Shapeså¯¹è±¡ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueã€‚
AddPoint (Shape, x, y [, iPart = 1])
åœ¨Shapeä¸­æ·»åŠ ä¸€ä¸ªç‚¹ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueã€‚
InsPoint (Shape, x, y [, iPoint = 1 [, iPart = 1]])
åœ¨Shapeä¸­æ’å…¥ä¸€ä¸ªç‚¹ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueã€‚
SetPoint (Shape, x, y [, iPoint = 1 [, iPart = 1]])
è®¾ç½®Shapeä¸­çš„ç‚¹åæ ‡ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueã€‚
DelPoint (Shape, iPoint [, iPart=1])
ä»Shapeä¸­åˆ é™¤ä½ç½®ä¸ºiPointçš„ä¸€ä¸ªç‚¹ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueã€‚
DelPart (Shape, iPart)
ä»Shapeä¸­åˆ é™¤ä¸€ä¸ªéƒ¨åˆ†ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueã€‚
GetPartCount (Shape)
è¿”å›Shapeä¸­éƒ¨åˆ†çš„æ•°é‡ã€‚
GetPointCount (Shape [, iPart])
è¿”å›Shapeä¸­ç‚¹çš„æ•°é‡ã€‚
GetPointXY (Shape [, iPoint [, iPart = 1]])
ä»Shapeæˆ–æŒ‡å®šç‚¹çš„åæ ‡ä¸­è¿”å›æ‰€æœ‰ç‚¹çš„åæ ‡ï¼šx1ï¼Œy1ï¼Œx2ï¼Œy2ï¼Œ...ã€‚
CopyShapeTo (TargetShapes, dx, dy, Shape1 [, Shape2, ...])
å°†Shapeå¯¹è±¡å¤åˆ¶åˆ°ç›®æ ‡Shapesï¼Œå¹¶è¿›è¡Œç›¸å¯¹å¹³ç§»ï¼ˆdxï¼Œdyï¼‰ï¼Œè¿”å›æ–°çš„Shapeå¯¹è±¡ã€‚
MoveShapeTo (dx, dy, Shape1 [, Shape2, ...])
å°†Shapeå¯¹è±¡å¹³ç§»åˆ°å…¶ç›¸å¯¹ä½ç½®ï¼ˆdxï¼Œdyï¼‰ã€‚
GetCenterXY (Shapes)
è¿”å›Shapesçš„ä¸­å¿ƒåæ ‡ï¼ˆxï¼Œyï¼‰ã€‚
GetCenterXY (Shapes, index1 [, index2, ...])
è¿”å›åœ¨Shapesä¸­ç”±ç´¢å¼•æŒ‡å®šçš„Shapeå¯¹è±¡çš„ä¸­å¿ƒåæ ‡ï¼ˆx1ï¼Œy1ï¼Œx2ï¼Œy2ï¼Œ...ï¼‰ã€‚
GetCenterXY (Shape1 [, Shape2, ...])
è¿”å›Shapeå¯¹è±¡çš„ä¸­å¿ƒåæ ‡ï¼ˆx1ï¼Œy1ï¼Œx2ï¼Œy2ï¼Œ...ï¼‰ã€‚
GetDistance (x1, y1, x2, y2 [, x3, y3, ...])
è¿”å›æ¯ä¸¤ä¸ªåæ ‡ï¼ˆxï¼Œyï¼‰å¯¹ä¹‹é—´çš„æ€»è·ç¦»ã€‚
GetShapeLen (Shape1 [, Shape2, ...])
è¿”å›Shapeå¯¹è±¡çš„é•¿åº¦ã€‚
GetShapeArea (Shape1 [, Shape2, ...])
è¿”å›Shapeå¯¹è±¡çš„é¢ç§¯ã€‚
GetShapeType (Shape|Shapes)
è¿”å›Shapesæˆ–Shapeå¯¹è±¡çš„ç±»å‹ï¼ˆ"Point"ï¼Œ"Line"æˆ–"Polygon"ï¼‰ã€‚
GetExtent (Shapes)
è¿”å›Shapesçš„èŒƒå›´åæ ‡ï¼ˆLxï¼ŒByï¼ŒRxï¼ŒTyï¼‰ã€‚
GetExtent (Shapes, index)
è¿”å›Shapesä¸­ç´¢å¼•ä¸ºindexçš„Shapeçš„èŒƒå›´åæ ‡ï¼ˆLxï¼ŒByï¼ŒRxï¼ŒTyï¼‰ã€‚
GetExtent (Shape)
è¿”å›Shapeçš„èŒƒå›´åæ ‡ï¼ˆLxï¼ŒByï¼ŒRxï¼ŒTyï¼‰ã€‚
GetIntersection (ShapeA, ShapeB)
è¿”å›ä¸¤ä¸ªShapesçš„äº¤é›†çš„Shapeï¼ˆPointï¼ŒLineæˆ–Polygonï¼‰å¯¹è±¡ã€‚
GetValue (Shape, "field_name")
è¿”å›Shapeçš„æŒ‡å®šå­—æ®µçš„å€¼ã€‚
SetValue (Shape, value1, "field_name1" [, value2, "field_name2", ...])
ä¸ºShapeçš„ä¸åŒå­—æ®µè®¾ç½®å€¼ã€‚
SetCoorSys ("Earth"|"Non-Earth")
è®¾ç½®åæ ‡ç³»ç»Ÿã€‚å¦‚æœä½¿ç”¨"Earth"ï¼Œè·ç¦»ã€é•¿åº¦å’Œé¢ç§¯å°†æ ¹æ®åœ°çƒæ¤­çƒåæ ‡ç³»ç»Ÿè®¡ç®—ã€‚é»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨"Non-Earth"ï¼Œå³ç¬›å¡å°”åæ ‡ç³»ç»Ÿã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.4_grids.html",title:"4.4 æ …æ ¼å›¾å½¢",pathLocale:"/",contents:[{header:"4.4 æ …æ ¼å›¾å½¢",slug:"_4-4-æ …æ ¼å›¾å½¢",content:'åœ¨MicroCityä¸­ï¼Œæ …æ ¼å›¾å½¢å…·æœ‰ç®€å•çš„ç»“æ„ï¼ˆ3.3ï¼‰ï¼Œä½†æ˜¯å¦‚æœåœ¨å…¶ä¸Šåº”ç”¨ç®—æ³•ï¼Œå¯ä»¥é«˜æ•ˆåˆ©ç”¨æ—¶é—´å’Œç©ºé—´ã€‚æœ¬ç« çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨é¡¹ç›®é€‰é¡¹å¡çš„"grid_samples"æ–‡ä»¶å¤¹ä¸­æ‰¾åˆ°ï¼Œè¯¥é€‰é¡¹å¡ä½äºScriptEditorä¸­ã€‚'},{header:"æ …æ ¼æ•°æ®æ“ä½œ",slug:"æ …æ ¼æ•°æ®æ“ä½œ",content:`CreateGrid("name", "Int|Float|Double", XMax, YMax [, CellSize = 1 [, xMin = 0 [, yMin = 0] [, init = 0]]]])
è¿”å›ä¸€ä¸ªGridå¯¹è±¡ã€‚
GetCellSize(Grid)
è¿”å›Gridçš„Cellsizeå€¼ã€‚
GetGridMaxXY(Grid)
è¿”å›Gridçš„XMaxå’ŒYMaxå€¼ã€‚
ConvertToGridXY(Grid, x1, y1 [, x2, y2, ...])
å°†å®é™…åæ ‡è½¬æ¢ä¸ºGridä¸­çš„åæ ‡ã€‚è¿”å›X1ï¼ŒY1ï¼ŒX2ï¼ŒY2ï¼Œ...ã€‚
ShapeToGrid(Grid, Shape, value)
åœ¨Gridä¸­å°†Shapeæ …æ ¼åŒ–ã€‚æ …æ ¼å•å…ƒå€¼å°†æ ¹æ®è¦†ç›–é¢ç§¯å’Œè¾“å…¥çš„å€¼è®¾ç½®ã€‚
ShapeToGrid(Grid, Shapes, "field_name")
åœ¨Shapesä¸­æ …æ ¼åŒ–æ‰€æœ‰çš„Shapeå¯¹è±¡ã€‚æ …æ ¼å•å…ƒå€¼å°†æ ¹æ®è¦†ç›–é¢ç§¯å’ŒShapeså­—æ®µçš„å€¼è®¾ç½®ã€‚
GetValue(Grid, X1, Y1 [, X2, Y2, ...])
è¿”å›æŒ‡å®šGridåæ ‡çš„å•å…ƒæ ¼å€¼ï¼švalue1ï¼Œvalue2ï¼Œ...ã€‚
SetValue(Grid, value, X1, Y1 [, X2, Y2, ...])
è®¾ç½®æŒ‡å®šGridåæ ‡å•å…ƒçš„å€¼ã€‚
GetCenterXY(Grid)
è¿”å›Gridçš„ä¸­å¿ƒå®é™…åæ ‡ï¼ˆxï¼Œyï¼‰ã€‚
GetCenterXY(Grid, X1, Y1 [, X2, Y2, ...])
è¿”å›å•å…ƒæ ¼ä¸­å¿ƒçš„å®é™…åæ ‡ï¼šx1ï¼Œy1ï¼Œx2ï¼Œy2ï¼Œ...ã€‚
GetExtent(Grid)
è¿”å›GridèŒƒå›´çš„å·¦ä¸‹è§’å’Œå³ä¸Šè§’åæ ‡ï¼šLxï¼ŒByï¼ŒRxï¼ŒTyã€‚
GetExtent(Grid, X, Y)
è¿”å›å•å…ƒæ ¼èŒƒå›´çš„å·¦ä¸‹è§’å’Œå³ä¸Šè§’åæ ‡ï¼šLxï¼ŒByï¼ŒRxï¼ŒTyã€‚
GetFractalDim(Grid, X1, Y1, X2, Y2, fold [, MultiFractalQ = 0])
è®¡ç®—Gridä¸­æŒ‡å®šåŒºåŸŸçš„åˆ†å½¢ç»´åº¦ã€‚è¿”å›ç»´åº¦ï¼Œçº¿æ€§å›å½’çš„RSQå€¼ä»¥åŠæ¯ä¸ªæŠ˜å ä¸­çš„ç›’å­æ•°ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.5_3d_scenes.html",title:"4.5 3Dåœºæ™¯",pathLocale:"/",contents:[{header:"4.5 3Dåœºæ™¯",slug:"_4-5-3dåœºæ™¯",content:'åœºæ™¯å’Œ3Dç‰©ä½“ï¼ˆ3.4ï¼‰å¯ä»¥è¿›è¡Œè„šæœ¬ç¼–å†™ã€‚æœ¬ç« èŠ‚çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨é¡¹ç›®æ ‡ç­¾ä¸­çš„"3d_samples"æ–‡ä»¶å¤¹ä¸­çš„ScriptEditorä¸­æ‰¾åˆ°ã€‚'},{header:"3Dåœºæ™¯å’Œç‰©ä½“æ“ä½œ",slug:"_3dåœºæ™¯å’Œç‰©ä½“æ“ä½œ",content:`CreateScene ("æ ‡é¢˜" [, RotSpeed=1] [, TransSpeed=1])
åˆ›å»ºä¸€ä¸ªæ–°çš„3Dåœºæ™¯å¹¶è¿”å›ç‰©ä½“ã€‚
AddZipTo3DPath (Scene, "æ–‡ä»¶å.zip")
å°†ä¸€ä¸ªzipæ–‡ä»¶æ·»åŠ åˆ°æœç´¢ç›®å½•ä¸­ï¼Œå¹¶åœ¨æˆåŠŸæ—¶è¿”å›trueã€‚è¿™å¯¹äºæ”¶é›†å¤§é‡æ–‡ä»¶å¾ˆæœ‰ç”¨ã€‚
LoadSkybox (Scene, "top.jpg" ,"bottom.jpg" ,"left.jpg" ,"right.jpg" ,"front.jpg" ,"back.jpg")
å°†å…­ä¸ªå›¾åƒæ–‡ä»¶åŠ è½½ä¸º3Dåœºæ™¯çš„å¤©ç©ºç›’ã€‚
LoadObject (Scene, "æ–‡ä»¶å.3ds" [,shadow = false [, AnimationSpeed]])
ä»æ–‡ä»¶ä¸­åŠ è½½ä¸€ä¸ª3Dç‰©ä½“ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚
AddLight (Scene, x, y, z, Radius [, r = 255, g = 255, b = 255])
æ·»åŠ ä¸€ä¸ªå…‰æºç‰©ä½“ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚
Add3DLabel(Scene, "æ ‡ç­¾" [, width=10, height=10 [, r = 180, g = 180, b = 180 [, "font.xml"]]])
åœ¨åæ ‡(0,0,0)å¤„æ·»åŠ ä¸€ä¸ª3Dæ ‡ç­¾ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚
Add3DLine (Scene, x1, y1, z1, x2, y2, z2 [, r = 0, g = 0, b = 0])
ä»ç‚¹(x1, y1, z1)åˆ°ç‚¹(x2, y2, z2)æ·»åŠ ä¸€ä¸ª3Dçº¿ç‰©ä½“ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚
Add3DRect (Scene, é•¿åº¦, å®½åº¦ [, r = 180, g = 180, b = 180])
ä»(-é•¿åº¦/2,0,-å®½åº¦/2)åˆ°(é•¿åº¦/2,0,å®½åº¦/2)æ·»åŠ ä¸€ä¸ª3DçŸ©å½¢ç‰©ä½“ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚
Add3DBox (Scene, é•¿åº¦, å®½åº¦, é«˜åº¦ [, r = 180, g = 180, b = 180 [, bShowEdge = true]])
ä»(-é•¿åº¦/2,-é«˜åº¦/2,-å®½åº¦/2)åˆ°(é•¿åº¦/2,é«˜åº¦/2,å®½åº¦/2)æ·»åŠ ä¸€ä¸ª3Dç›’å­ç‰©ä½“ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚
AddSphere (Scene, åŠå¾„ [, polycount = 16 [, r = 180, g = 180, b = 180]])
åœ¨åæ ‡(0,0,0)å¤„æ·»åŠ ä¸€ä¸ªçƒä½“ï¼Œå¹¶è¿”å›è¯¥ç‰©ä½“ã€‚å¦‚æœåŠå¾„å‚æ•°å°äº0ï¼Œåˆ™è¿”å›ä¸€ä¸ªä¸å¯è§çš„ç‰©ä½“ã€‚
GetTexture (Object)
è¿”å›ä¸€ä¸ªç‰©ä½“çš„çº¹ç†æ–‡ä»¶ï¼š"æ–‡ä»¶å1"ï¼Œ"æ–‡ä»¶å2"ç­‰ç­‰ã€‚
LoadTexture (Scene, Object, "æ–‡ä»¶å1" [, "æ–‡ä»¶å2", ...])
åŠ è½½çº¹ç†æ–‡ä»¶åˆ°ä¸€ä¸ªç‰©ä½“ä¸­ã€‚
SetPosition (Object, x, y, z [, absolute = false])
è®¾ç½®ä¸€ä¸ªç‰©ä½“ç›¸å¯¹äºå…¶çˆ¶ç‰©ä½“çš„ä½ç½®ï¼ˆæˆ–è€…ç»å¯¹ä½ç½®åˆ°åœºæ™¯ï¼‰ã€‚
GetPosition (Object [, absolute = false])
è·å–ä¸€ä¸ªç‰©ä½“ç›¸å¯¹äºå…¶çˆ¶ç‰©ä½“çš„ä½ç½®ï¼ˆæˆ–è€…è¯¥ç‰©ä½“åœ¨åœºæ™¯ä¸­çš„ç»å¯¹ä½ç½®ï¼‰ã€‚
SetRotation (Object, rx, ry, rz [, absolute = false])
è®¾ç½®ä¸€ä¸ªç‰©ä½“ç›¸å¯¹äºå…¶çˆ¶ç‰©ä½“çš„æ—‹è½¬è§’åº¦ï¼ˆå·¦æ‰‹åæ ‡ç³»ï¼‰ï¼Œä»¥åº¦ä¸ºå•ä½ï¼ˆæˆ–è€…è¯¥ç‰©ä½“åœ¨åœºæ™¯ä¸­çš„ç»å¯¹æ—‹è½¬è§’åº¦ï¼‰ã€‚
GetRotation (Object [, absolute = false])
è·å–ä¸€ä¸ªç‰©ä½“ç›¸å¯¹äºå…¶çˆ¶ç‰©ä½“çš„æ—‹è½¬è§’åº¦ï¼ˆå·¦æ‰‹åæ ‡ç³»ï¼‰ï¼Œä»¥åº¦ä¸ºå•ä½ï¼ˆæˆ–è€…è¯¥ç‰©ä½“åœ¨åœºæ™¯ä¸­çš„ç»å¯¹æ—‹è½¬è§’åº¦ï¼‰ã€‚
SetScale (Object, sx, sy, sz)
è®¾ç½®ä¸€ä¸ªç‰©ä½“çš„ç¼©æ”¾æ¯”ä¾‹ã€‚
GetScale (Object)
è·å–ä¸€ä¸ªç‰©ä½“çš„ç¼©æ”¾æ¯”ä¾‹ã€‚
SetParent (Object, Parent)
å°†ä¸€ä¸ªç‰©ä½“ä½œä¸ºå­ç‰©ä½“é™„åŠ åˆ°å¦ä¸€ä¸ªç‰©ä½“ä¸Šã€‚
GetParent (Object)
è·å–ä¸€ä¸ªç‰©ä½“çš„çˆ¶ç‰©ä½“ã€‚
SetObject (Object "id" [,x, y, z, [,rx, ry, rz [,sx, sy, sz]]])
è®¾ç½®ä¸€ä¸ªç‰©ä½“çš„idã€ä½ç½®ã€æ—‹è½¬å’Œç¼©æ”¾ã€‚
DelObject (Object)
åˆ é™¤ä¸€ä¸ªç‰©ä½“ã€‚
SetCamera (Scene, x, y, z [,Tx, Ty, Tz])
è®¾ç½®åœºæ™¯ç›¸æœºçš„ä½ç½®å’Œç›®æ ‡ã€‚
GetCamera (Scene)
è·å–ä¸€ä¸ª3Dåœºæ™¯çš„ç›¸æœºç‰©ä½“ä»¥åŠå…¶ä½ç½®å’Œç›®æ ‡ã€‚
GetSelections (Scene)
ä»ä¸€ä¸ª3Dåœºæ™¯ä¸­è¿”å›é€‰ä¸­çš„ç‰©ä½“ã€‚
GetObjectID (Object1 [, Object2, ...])
è¿”å›ç‰©ä½“çš„"id"ã€‚
SetObjectID (Object, "id")
è®¾ç½®ä¸€ä¸ªç‰©ä½“çš„idã€‚
GetObject (Scene, "id")
æ ¹æ®idæŸ¥æ‰¾ä¸€ä¸ªç‰©ä½“ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.6_networks.html",title:"4.6 ç½‘ç»œ",pathLocale:"/",contents:[{header:"4.6 ç½‘ç»œ",slug:"_4-6-ç½‘ç»œ",content:'åœ¨MicroCityä¸­ï¼ŒGISçŸ¢é‡æ•°æ®ï¼ˆå‚è§3.2ï¼‰å¯ä»¥è¿›è¡Œæ‹“æ‰‘æ“ä½œï¼Œå¹¶åº”ç”¨æœ€çŸ­è·¯å¾„ç®—æ³•å’Œç”¨æˆ·å‡è¡¡äº¤é€šåˆ†é…ç®—æ³•ã€‚æœ¬ç« çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨é¡¹ç›®é€‰é¡¹å¡çš„"network_samples"æ–‡ä»¶å¤¹ä¸­æ‰¾åˆ°ï¼Œå…·ä½“è¯·å‚è€ƒScriptEditorã€‚'},{header:"ç½‘ç»œæ“ä½œ",slug:"ç½‘ç»œæ“ä½œ",content:`CreateNetwork ()
åˆ›å»ºä¸€ä¸ªç©ºç½‘ç»œå¯¹è±¡å¹¶è¿”å›ã€‚
CreateNetwork (UnTopoLines)
ä»æœªè¿›è¡Œæ‹“æ‰‘æ“ä½œçš„â€œçº¿â€å½¢çŠ¶åˆ›å»ºç½‘ç»œï¼Œå¹¶è¿”å›ä¸‰ä¸ªå¯¹è±¡ï¼šç½‘ç»œã€èŠ‚ç‚¹ï¼ˆå½¢çŠ¶ï¼‰å’Œé“¾æ¥ï¼ˆå½¢çŠ¶ï¼‰ã€‚
CreateNetwork (Nodes, Links)
ä»è¿›è¡Œäº†æ‹“æ‰‘æ“ä½œçš„èŠ‚ç‚¹å’Œé“¾æ¥å½¢çŠ¶åˆ›å»ºç½‘ç»œå¯¹è±¡ã€‚è¿”å›ç½‘ç»œå¯¹è±¡ã€‚
InitNetwork (Network, Nodes, Links)
ä»èŠ‚ç‚¹å’Œé“¾æ¥å½¢çŠ¶åˆå§‹åŒ–ç½‘ç»œã€‚å¦‚æœæˆåŠŸè¿”å›trueã€‚
AddLink (Network, linkID|-1, oID|-1, dID|-1, impedance [, direction = 1 [, capacity = 1E+38]])
å‘ç½‘ç»œä¸­æ·»åŠ æ–°çš„é“¾æ¥æˆ–æ›´æ–°ç°æœ‰é“¾æ¥ã€‚è¿”å›linkIDã€oIDã€dIDã€æ·»åŠ ç»“æœï¼ˆtrue/falseï¼‰å’Œæ›´æ–°ç»“æœï¼ˆtrue/falseï¼‰ã€‚
AddLink (Network, Shapes|Table, index1 [, index2, ...])
ä»å½¢çŠ¶è®°å½•é›†æˆ–è¡¨ä¸­æ·»åŠ æˆ–æ›´æ–°é“¾æ¥ã€‚è¿”å›å¸ƒå°”å€¼ã€‚
DelLink (Network, linkID)
ä»ç½‘ç»œä¸­åˆ é™¤é“¾æ¥ã€‚è¿”å›å¸ƒå°”å€¼ã€‚
GetNearNodeID (Network, x, y [, radius=nil])
è·å–åæ ‡æœ€è¿‘çš„ç½‘ç»œèŠ‚ç‚¹ã€‚è¿”å›èŠ‚ç‚¹IDã€‚
GetNodeXY (Network, nodeID1 [, nodeID2, ...])
è¿”å›ç½‘ç»œä¸­èŠ‚ç‚¹çš„åæ ‡ï¼šx1ã€y1ã€x2ã€y2ï¼Œç­‰ç­‰ã€‚`},{header:"ç®—æ³•",slug:"ç®—æ³•",content:`GenSTPTree (Network, startID [, endID])
ä»ä¸€ä¸ªèŠ‚ç‚¹ç”Ÿæˆæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘ã€‚è¿”å›å¸ƒå°”å€¼ã€‚
GetSTPPath (Network, endID, "NodeID"|"LinkID")
åœ¨è°ƒç”¨GenSTPTreeä¹‹åè°ƒç”¨è¯¥å‡½æ•°ã€‚è¿”å›ç”±èŠ‚ç‚¹IDæˆ–é“¾æ¥IDåºåˆ—è¡¨ç¤ºçš„æœ€çŸ­è·¯å¾„ï¼šid1ã€id2ï¼Œç­‰ç­‰ã€‚
GetSTPPath (Network, endID, "iNodeShp"|"iLinkShp")
åœ¨è°ƒç”¨GenSTPTreeä¹‹åè°ƒç”¨è¯¥å‡½æ•°ã€‚è¿”å›ç”±èŠ‚ç‚¹æˆ–é“¾æ¥å½¢çŠ¶ç´¢å¼•åºåˆ—è¡¨ç¤ºçš„æœ€çŸ­è·¯å¾„ã€‚
GetSTPPath (Network, endID, "NodeShp"|"LinkShp")
åœ¨è°ƒç”¨GenSTPTreeä¹‹åè°ƒç”¨è¯¥å‡½æ•°ã€‚è¿”å›ç”±èŠ‚ç‚¹æˆ–é“¾æ¥å½¢çŠ¶å¯¹è±¡åºåˆ—è¡¨ç¤ºçš„æœ€çŸ­è·¯å¾„ã€‚
GetSTPLen (Network, endID)
åœ¨è°ƒç”¨GenSTPTreeä¹‹åè°ƒç”¨è¯¥å‡½æ•°ã€‚è¿”å›åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„è·ç¦»ã€‚
GetSTPLen (Network, startID, endID)
åœ¨ç½‘ç»œä¸­ä»èµ·ç‚¹èŠ‚ç‚¹åˆ°ç»ˆç‚¹èŠ‚ç‚¹è·å–æœ€çŸ­è·¯å¾„ã€‚è¿”å›è·ç¦»ã€‚
GetSTPLen (Network, x1, y1, x2, y2)
åœ¨ç½‘ç»œä¸­ä»èµ·ç‚¹åæ ‡åˆ°ç»ˆç‚¹åæ ‡è·å–æœ€çŸ­è·¯å¾„ã€‚è¿”å›è·ç¦»ã€‚
SetTrip (Network, oID, dID, amount)
è®¾ç½®ä»å‡ºå‘åœ°åˆ°ç›®çš„åœ°çš„æ—…è¡Œé‡ã€‚
SolveUE (Network [, rootTol = 1E-2 [, equlBrm = 1E-5 [, maxIter = 10000]]])
åœ¨è°ƒç”¨SetTripä¹‹åè°ƒç”¨è¯¥å‡½æ•°ã€‚æ‰§è¡Œç”¨æˆ·å‡è¡¡äº¤é€šåˆ†é…ï¼Œå¹¶è¿”å›å¸ƒå°”å€¼ã€‚
GetFlow (Network, linkID)
è¿”å›æŒ‡å®šé“¾æ¥çš„äº¤é€šæµé‡ã€‚
SetFlow (Network, linkID, flow)
è®¾ç½®æŒ‡å®šé“¾æ¥çš„äº¤é€šæµé‡ï¼Œå¹¶è¿”å›å¸ƒå°”å€¼ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.7_des_simulations.html",title:"4.7 ç¦»æ•£äº‹ä»¶ä»¿çœŸ",pathLocale:"/",contents:[{header:"4.7 ç¦»æ•£äº‹ä»¶ä»¿çœŸ",slug:"_4-7-ç¦»æ•£äº‹ä»¶ä»¿çœŸ",content:"MicroCityæœ‰ä¸€ä¸ªå†…ç½®çš„ä»¿çœŸæ—¶é—´è®¡æ•°å’Œäº‹ä»¶è°ƒåº¦æœºåˆ¶ã€‚å®ƒæä¾›äº†å‡ ä¸ªåµŒå…¥çš„Luaå‡½æ•°æ¥æ–¹ä¾¿åˆ›å»ºç¦»æ•£äº‹ä»¶ä»¿çœŸï¼Œè¿™å¯¹äºåŠ¨æ€ç³»ç»Ÿåˆ†æéå¸¸æœ‰ç”¨ã€‚æœ¬ç« çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨é¡¹ç›®é€‰é¡¹å¡çš„â€œsimulation_samplesâ€æ–‡ä»¶å¤¹ä¸­çš„ScriptEditoræ‰¾åˆ°ã€‚"},{header:"éšæœºæ•°ç”Ÿæˆ",slug:"éšæœºæ•°ç”Ÿæˆ",content:`CreateRandEng (seed, "uniform_01")
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªäºŒè¿›åˆ¶åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "uniform_real" [, min = 0, max = 1])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»å‡åŒ€åˆ†å¸ƒçš„å®æ•°éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "uniform_int" [, min = 0, max = 1])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»å‡åŒ€åˆ†å¸ƒçš„æ•´æ•°éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "triangle" [, a = 0, b = 1, c = 2])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»ä¸‰è§’åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "bernoulli" [, p = 0])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»ä¼¯åŠªåˆ©åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "cauchy" [, median = 0, sigma = 1])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»æŸ¯è¥¿åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "exponential" [, lambda = 1])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»æŒ‡æ•°åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "geometric" [, p = 0])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»å‡ ä½•åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "normal" [, mean = 0, sigma = 1])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»æ­£æ€åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
CreateRandEng (seed, "lognormal" [, mean = 0, sigma = 1])
ä½¿ç”¨ç§å­åˆ›å»ºä¸€ä¸ªæœä»å¯¹æ•°æ­£æ€åˆ†å¸ƒçš„éšæœºæ•°ç”Ÿæˆå¼•æ“ï¼Œå¹¶è¿”å›è¯¥å¯¹è±¡ã€‚
GetNextRandom (Engine)
ä»éšæœºæ•°ç”Ÿæˆå¼•æ“ä¸­è·å–ä¸€ä¸ªéšæœºæ•°ã€‚`},{header:"ä»¿çœŸæ§åˆ¶",slug:"ä»¿çœŸæ§åˆ¶",content:`CreateEvent (time, Funcion [, arg1, arg2, ...])
ä»Lua Functionæˆ–Lua Coroutineåˆ›å»ºä¸€ä¸ªå°†æ¥çš„äº‹ä»¶ï¼Œå¹¶è¿”å›ä¸€ä¸ªCoroutineå¯¹è±¡ã€‚
ExecAllEvents ()
æœ€åè°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚å®ƒä¼šå°†æ‰€æœ‰äº‹ä»¶ä½œä¸ºLua Coroutinesæ‰§è¡Œã€‚
Delay ([relativeTime = 0])
åœ¨Lua Coroutineä¸­è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œè®©å®ƒå…ˆæš‚åœä¸€æ®µæŒ‡å®šçš„ç›¸å¯¹æ—¶é—´ï¼Œç„¶åå†æ¢å¤æ‰§è¡Œã€‚å¦‚æœæ²¡æœ‰è®¾ç½®å‚æ•°relativeTimeï¼Œå½“å‰çš„Coroutineå°†æš‚åœè€Œä¸ä¼šè‡ªåŠ¨æ¢å¤ã€‚
Resume ([time, ] Coroutine [, arg1, arg2, ...])
ç«‹å³æˆ–åœ¨æŒ‡å®šçš„æ—¶é—´æ¢å¤ä¸€ä¸ªå·²æš‚åœçš„åç¨‹ã€‚
GetSimTime ()
è¿”å›å½“å‰çš„ä»¿çœŸæ—¶é—´ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/4.8_mixed_integer_programming.html",title:"4.8 æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’",pathLocale:"/",contents:[{header:"4.8 æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’",slug:"_4-8-æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’",content:'MicroCityä½¿ç”¨lpsolveæ¥è§£å†³æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’é—®é¢˜ã€‚å¼€å‘äººå‘˜å¯ä»¥ä½¿ç”¨åµŒå…¥çš„Luaå‡½æ•°æ¥æ„å»ºå’Œæ±‚è§£æ¨¡å‹ã€‚æœ¬ç« çš„ç¤ºä¾‹ä»£ç å¯ä»¥åœ¨é¡¹ç›®é€‰é¡¹å¡ä¸­çš„"optimization_samples"æ–‡ä»¶å¤¹ä¸­æ‰¾åˆ°ï¼Œå›¾æ ‡ä¸ºScriptEditor.'},{header:"æ¨¡å‹åˆ›å»ºå’Œæ‰§è¡Œ",slug:"æ¨¡å‹åˆ›å»ºå’Œæ‰§è¡Œ",content:`CreateLP ([rows = 0 , columns = 0])
åˆ›å»ºä¸€ä¸ªæ··åˆæ•´æ•°çº¿æ€§è§„åˆ’æ¨¡å‹å¹¶è¿”å›LPModelå¯¹è±¡ã€‚
SetObjFunction (LPModel, rowTable, "MAX"|"MIN")
ä½¿ç”¨å­˜å‚¨å†³ç­–å˜é‡ç³»æ•°çš„Lua Tableè®¾ç½®LPModelçš„ç›®æ ‡å‡½æ•°ã€‚
AddConstraint (LPModel, rowTable, "<="|">="|"==", rhsValue)
ä½¿ç”¨å­˜å‚¨å†³ç­–å˜é‡ç³»æ•°çš„Lua Tableå‘LPModelæ·»åŠ çº¦æŸã€‚
SetInteger (LPModel, index)
å°†ç”±ç´¢å¼•indexæŒ‡å®šçš„å†³ç­–å˜é‡è®¾ç½®ä¸ºæ•´æ•°å˜é‡ã€‚
SetBinary (LPModel, index)
å°†ç”±ç´¢å¼•indexæŒ‡å®šçš„LPModelçš„å†³ç­–å˜é‡è®¾ç½®ä¸ºäºŒè¿›åˆ¶å˜é‡ã€‚
SetUnbounded (LPModel, index)
å°†ç”±ç´¢å¼•indexæŒ‡å®šçš„LPModelçš„å†³ç­–å˜é‡è®¾ç½®ä¸ºæ— ç•Œï¼ˆæ­£/è´Ÿæ— ç©·å¤§ï¼‰ã€‚
SolveLP (LPModel [, timeoutSec = 60])
æ±‚è§£LPModelå¹¶è¿”å›0è¡¨ç¤ºæˆåŠŸï¼Œ-1è¡¨ç¤ºæ— æ•ˆLPæ¨¡å‹ï¼Œ-2è¡¨ç¤ºå†…å­˜ä¸è¶³ï¼Œ1è¡¨ç¤ºæ¬¡ä¼˜ï¼Œ2è¡¨ç¤ºä¸å¯è¡Œï¼Œ3è¡¨ç¤ºæ— ç•Œï¼Œ4è¡¨ç¤ºé€€åŒ–ï¼Œ5è¡¨ç¤ºé‡åˆ°æ•°å€¼é”™è¯¯ï¼Œ6è¡¨ç¤ºç”¨æˆ·ä¸­æ­¢ï¼Œ7è¡¨ç¤ºè¶…æ—¶é”™è¯¯ï¼Œ9è¡¨ç¤ºæ¨¡å‹å¯ç”±é¢„å¤„ç†è§£å†³ï¼Œ10è¡¨ç¤ºB&Bä¾‹ç¨‹å¤±è´¥ï¼Œ11è¡¨ç¤ºB&Bå› ä¸­æ–­è€Œåœæ­¢ï¼Œ12è¡¨ç¤ºæ‰¾åˆ°å¯è¡Œçš„B&Bè§£å†³æ–¹æ¡ˆï¼Œ13è¡¨ç¤ºæ²¡æœ‰å¯è¡Œçš„B&Bè§£å†³æ–¹æ¡ˆã€‚
GetObjective (LPModel)
è¿”å›LPModelçš„ç›®æ ‡å‡½æ•°å€¼ã€‚
GetVariable (LPModel, index)
è¿”å›ç”±ç´¢å¼•indexæŒ‡å®šçš„å†³ç­–å˜é‡çš„å€¼ã€‚
GetVariables (LPModel)
è¿”å›LPModelçš„æ‰€æœ‰å†³ç­–å˜é‡çš„å€¼ã€‚
GetDual (LPModel, index)
è¿”å›ç”±ç´¢å¼•indexæŒ‡å®šçš„å†³ç­–å˜é‡çš„å¯¹å¶å€¼ã€‚
GetDuals (LPModel)
è¿”å›LPModelçš„æ‰€æœ‰å†³ç­–å˜é‡çš„å¯¹å¶å€¼ã€‚
ReadLP("fileName.mps")
ä»æ–‡ä»¶(*.lp, *.mps)ä¸­è¯»å–LPModelï¼Œå¹¶åœ¨æˆåŠŸæ—¶è¿”å›LPModelã€‚
WriteLP (LPModel, "fileName.mps")
å°†LPModelå†™å…¥æ–‡ä»¶(*.lp, *.mps)ï¼Œå¹¶åœ¨æˆåŠŸæ—¶è¿”å›trueã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/docs/",title:"MicroCity Desktop æ–‡æ¡£",pathLocale:"/",contents:[{header:"MicroCity Desktop æ–‡æ¡£",slug:"microcity-desktop-æ–‡æ¡£",content:""},{header:"ç›®å½•",slug:"ç›®å½•",content:`1 Introduction 1.1 MicroCityçš„åŠŸèƒ½ 2 å…¥é—¨æŒ‡å— 2.1 æ˜¾ç¤ºä¸–ç•Œåœ°å›¾
2.2 æœç´¢å›½å®¶ 3 ç”¨æˆ·ç•Œé¢ 3.1 UIæ¦‚è§ˆ
3.2 çŸ¢é‡å½¢çŠ¶
3.3 æ …æ ¼å›¾å±‚
3.4 3Dåœºæ™¯
3.5 è¡¨æ ¼
3.6 åœ°å›¾å’Œå›¾å±‚
3.7 æ¨¡å— 4 è„šæœ¬æ¥å£ 4.1 æ¥å£æ¦‚è§ˆ
4.2 UIæ§åˆ¶
4.3 å½¢çŠ¶å’Œè¡¨æ ¼
4.4 æ …æ ¼å›¾å±‚
4.5 3Dåœºæ™¯
4.6 ç½‘ç»œ
4.7 ç¦»æ•£äº‹ä»¶ä»¿çœŸ
4.8 æ··åˆæ•´æ•°è§„åˆ’ å£°æ˜ï¼šæœ¬ç½‘ç«™æ–‡æ¡£ä¸­çš„éƒ¨åˆ†å†…å®¹æ¥æºäºMicroCity Desktopï¼Œç‰ˆæƒå½’åŸä½œè€…æ‰€æœ‰ã€‚ è¿™ç¯‡æ–‡ç« ä½¿ç”¨ChatGPTç¿»è¯‘è‡ªå…¶ä»–è¯­è¨€ï¼Œå¦‚æœæœ‰é—®é¢˜è¯·åœ¨åé¦ˆé¡µé¢æäº¤åé¦ˆã€‚`}]},{path:"/en/",title:"Home Page",pathLocale:"/en/",contents:[{header:"Getting Started with MicroCity Web",slug:"getting-started-with-microcity-web",content:"Open MicroCity Web, and the example code for rotating blocks will load by default. Click the button to run the code. The program will run, and you will see the blocks rotating in the right-hand view. If you want to learn more about how to use MicroCity Web and its advanced features, you can refer to the Learning Notes provided on this site."},{header:"Getting Started with MicroCity Desktop",slug:"getting-started-with-microcity-desktop",content:'Go to the MicroCity documentation repository to download the Latest Version of MicroCity. Open the ScriptEditor and type: Print("hello, world!") Save the script as test.mcs and drag it into MicroCity. In the main interface of the program, go to the Modules tab on the left side, open test, and double-click on main to execute the script you just wrote. The information about the execution of the script will be displayed in the Messages panel at the bottom of the program interface. For more information on how to use MicroCity, you can refer to the documentation found on this site, which is a mirror of the documentation provided on GitHub: MicroCity Documentation. You can also refer to the documentation of MicroCtiy on GitHub at MicroCity.'},{header:"MicroCityNotes Repository",slug:"microcitynotes-repository",content:`If users in China have difficulty accessing GitHub, they can also visit the Synchronized Site hosted on Netlify.
If you find any issues with the documentation or notes, please feel free to submit a Pull Request or provide Issues to help make it betterğŸ˜‹. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/notes/3d-objects.html",title:"3D å¯¹è±¡",pathLocale:"/",contents:[{header:"3D å¯¹è±¡",slug:"_3d-å¯¹è±¡",content:"æœ¬èŠ‚å°†ä»‹ç» MicroCity Web ä¸­çš„ä¸‰ç»´åœºæ™¯å¯¹è±¡åŠå…¶æ§åˆ¶å‡½æ•°ã€‚"},{header:"æ·»åŠ å¯¹è±¡",slug:"æ·»åŠ å¯¹è±¡",content:`å‘åœºæ™¯ä¸­æ·»åŠ å¯¹è±¡ï¼Œå‡½æ•°å½¢å¼å¦‚ä¸‹
local obj = scene.addobj([ç±»å‹], {key1 = value1, key2 = value2, ...})`},{header:"å¯¹è±¡å¯é€‰å±æ€§åˆ—è¡¨",slug:"å¯¹è±¡å¯é€‰å±æ€§åˆ—è¡¨",content:`æ·»åŠ åˆ°åœºæ™¯ä¸­çš„å¯¹è±¡é€šå¸¸æ”¯æŒè®¾ç½®ä»¥ä¸‹å±æ€§ä¸­çš„æŸäº›å±æ€§ å¯¹è±¡å±æ€§
å«ä¹‰ color
å¯¹è±¡çš„é¢œè‰²ã€‚é¢œè‰²çš„æ ¼å¼æ”¯æŒå†…ç½®é¢œè‰²ã€åå…­è¿›åˆ¶ã€RGBã€‚ä¸ åœºæ™¯èƒŒæ™¯é¢œè‰² çš„è®¾ç½®ç›¸åŒ opacity
é€æ˜åº¦ hcolor
é€‰ä¸­æ—¶çš„é¢œè‰² size
å¯¹è±¡çš„å¤§å°ï¼Œé»˜è®¤å€¼ä¸º1 length
å¯¹è±¡çš„é•¿åº¦ï¼Œå¸¸ç”¨äº box(ç«‹æ–¹ä½“) width
å¯¹è±¡çš„å®½åº¦ï¼Œå¸¸ç”¨äº box(ç«‹æ–¹ä½“) height
å¯¹è±¡çš„é«˜åº¦ï¼Œå¸¸ç”¨äº box(ç«‹æ–¹ä½“) radius
å¯¹è±¡åœ†è§’å¤§å° segments
ä»½æ•°ï¼Œé€šå¸¸ç”¨äºè®¾ç½® sphere(çƒä½“) ç»˜åˆ¶çš„ç²¾åº¦ selectable
æ˜¯å¦å¯è¢«é€‰ä¸­ name
å¯¹è±¡åç§° text
å¯¹è±¡æ–‡æœ¬å€¼ font
æ–‡æœ¬å­—ä½“ vertices
æ„æˆå¯¹åº”å¯¹è±¡çš„ç‚¹é›†åˆ æ”¯æŒæ·»åŠ åˆ°åœºæ™¯ä¸­çš„ç±»å‹å¦‚ä¸‹`},{header:"å¯¹è±¡ç±»å‹",slug:"å¯¹è±¡ç±»å‹",content:""},{header:"å¯¹è±¡ç±»å‹åˆ—è¡¨",slug:"å¯¹è±¡ç±»å‹åˆ—è¡¨",content:`labelï¼šæ–‡æœ¬æ ‡ç­¾
pointsï¼šç‚¹é›†åˆ
polylineï¼šçº¿æ®µé›†åˆ
boxï¼šç«‹æ–¹ä½“
sphereï¼šçƒä½“
polygonï¼šå¤šè¾¹å½¢
lightï¼šå…‰æº
meshï¼šç‚¹æ„æˆçš„é¢ æ³¨é‡Š
ä¸ºäº†ç®€æ´èµ·è§ï¼Œä¸‹æ–¹ç¤ºä¾‹çš„å¯¹è±¡å¯é€‰å±æ€§ä¸­åªå±•ç¤ºå¯¹åº”å¯¹è±¡çš„å…³é”®å±æ€§ã€‚å…¶ä»–é€šç”¨çš„å±æ€§å¯ä»¥å‚è€ƒ å¯¹è±¡å¯é€‰å±æ€§åˆ—è¡¨ è‡ªè¡Œæ·»åŠ ã€‚`},{header:"label",slug:"label",content:`label æ˜¯æ–‡æœ¬æ ‡ç­¾ã€‚å¯ä»¥åœ¨ text å±æ€§ä¸­è®¾ç½®labelçš„æ–‡æœ¬ã€‚
local obj = scene.addobj('label', {text = "Hello World!"})`},{header:"points",slug:"points",content:`points æ˜¯ç‚¹é›†åˆã€‚å¯ä»¥åªåˆ›å»ºå•ä¸ªç‚¹ï¼Œä¹Ÿå¯ä»¥åˆ›å»ºå¤šä¸ªç‚¹ã€‚æ¯ä¸ªç‚¹éƒ½æœ‰ä¸‰ä¸ªç»´åº¦çš„åæ ‡ä»¥ç¡®å®šå…¶åœ¨ä¸‰ç»´ç©ºé—´ä¸­çš„ä½ç½®ã€‚ç‚¹çš„ä¸ªæ•°é€šè¿‡ vertices å±æ€§ç¡®å®šã€‚
ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ›å»º points ç‚¹é›†å¯¹è±¡çš„ç¤ºä¾‹
-- åœ¨åæ ‡ä¸º(5,5,5)çš„ä½ç½®åˆ›å»ºä¸€ä¸ªç‚¹
scene.addobj("points", {vertices = {5,5,5}, size = 5}) -- ç¬¬ä¸€ä¸ªç‚¹çš„åæ ‡ä¸º(0,0,0)ï¼Œç¬¬äºŒä¸ªç‚¹çš„åæ ‡ä¸º(5,5,5)
scene.addobj("points", {vertices = {0,0,0, 5,5,5}, size = 5})`},{header:"polyline",slug:"polyline",content:`polyline æ˜¯çº¿æ®µé›†åˆã€‚å½“åœ¨verticeså±æ€§ä¸­è¾“å…¥å¤šä¸ªç‚¹çš„åæ ‡æ—¶ï¼Œå°†ä¼šä¾æ¬¡æ ¹æ®ç‚¹åæ ‡è¿çº¿ï¼Œå¾—åˆ°çº¿æ®µé›†åˆã€‚
å› æ­¤ï¼Œè™½ç„¶ä¸‹é¢ä¸¤ä¸ªä¾‹å­ä¸­ä½¿ç”¨äº†ç›¸åŒçš„ç‚¹åæ ‡ï¼Œä½†æ˜¯ç”±äºç‚¹åæ ‡è¾“å…¥é¡ºåºä¸åŒï¼Œå¾—åˆ°çš„ç»“æœä¹Ÿä¸åŒã€‚
scene.addobj("polyline", {vertices = {0,0,0, 4,6,7, -2,3,5}})
scene.addobj("polyline", {vertices = {0,0,0, -2,3,5, 4,6,7}}) polylineç‚¹é¡ºåºå¯¹æ¯”å›¾ polyline æ²¡æœ‰ size å±æ€§`},{header:"box",slug:"box",content:`box æ˜¯é•¿æ–¹ä½“ã€‚ä¸»è¦é€šè¿‡ lengthã€width å’Œ height å±æ€§ä¿®æ”¹å…¶å½¢çŠ¶ã€‚
local obj = scene.addobj('box', {length = 3, width = 4, height = 5})
box å¯¹è±¡çš„é‡è¦å¯é€‰å±æ€§ å±æ€§
å«ä¹‰ length
ç«‹æ–¹ä½“çš„é•¿åº¦ width
ç«‹æ–¹ä½“çš„å®½åº¦ height
ç«‹æ–¹ä½“çš„é«˜åº¦ åŸºäºä»¥ä¸Šä¸‰ä¸ªå±æ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹é»˜è®¤ç¤ºä¾‹ä»£ç ä¸­æ—‹è½¬çš„boxçš„å½¢çŠ¶ã€‚
--æ·»åŠ äº†length, width, heightä¸‰ä¸ªå±æ€§ï¼ˆä¸æ·»åŠ é»˜è®¤éƒ½ä¸º1ï¼‰
local obj = scene.addobj('box', {length = 3, width = 4, height = 5}) local x = 1
local y = 1
local z = 0
while scene.render() do x = x + 0.1 y = y + 0.1 obj:setrot(x, y, z)
end ä¸åŒé•¿å®½é«˜è®¾ç½®çš„box`},{header:"sphere",slug:"sphere",content:`sphere æ˜¯çƒä½“ã€‚å¯ä»¥é€šè¿‡ radius å±æ€§ä¿®æ”¹å…¶å¤§å°ï¼Œè¿˜å¯ä»¥é€šè¿‡è®¾ç½® segment å±æ€§è®¾ç½®å…¶æ¨¡å‹è´¨é‡ã€‚å…·ä½“å¯ä»¥å‚è€ƒå†…ç½®ç¤ºä¾‹ä¸­åœ°çƒçš„ä¾‹å­ã€‚
local obj = scene.addobj('sphere', {radius=15, segments=360})
sphere å¯¹è±¡çš„å¯é€‰å±æ€§ å±æ€§
å«ä¹‰ radius
çƒä½“çš„åœ†è§’å¤§å°ã€‚å¯ä»¥ç”¨äºæ§åˆ¶çƒä½“çš„å¤§å°ã€‚ segments
çƒä½“çš„æ¸²æŸ“é¢æ•°ã€‚è®¾ç½®å€¼è¶Šé«˜çƒä½“çš„æ¨¡å‹è¶Šç²¾ç»†ã€‚ ä¸åŒsegmentå¯¹äºç›¸åŒsphereçš„å½±å“`},{header:"polygon",slug:"polygon",content:`polygon æ˜¯å¤šè¾¹å½¢ã€‚ä¸»è¦é€šè¿‡ vertices å±æ€§å¯¹å…¶è¿›è¡Œè®¾ç½®ã€‚
local obj = scene.addobj("polygon", {vertices = {-1,-1,0, -1,1,-0, 1,1,0, 1,-1,0}}) ç”±äºæ­¤å¤„ä¸¾ä¾‹çš„å¤šè¾¹å½¢ä¸ºæ­£æ–¹å½¢ï¼Œå› æ­¤çœ‹ä¸Šå»ä¸ä¸Šé¢ä»‹ç»çš„ box æ²¡ä»€ä¹ˆå·®åˆ«ã€‚ä½†æ˜¯å½“å½¢çŠ¶è®¾ç½®ä¸ºå…¶ä»–ç±»å‹çš„å¤šè¾¹å½¢æ—¶ï¼ˆå¦‚ä¸‰è§’å½¢ã€äº”è¾¹å½¢ç­‰ï¼‰ï¼Œå¤šè¾¹å½¢çš„æ„ä¹‰å°±èƒ½è¢«ä½“ç°å‡ºæ¥äº†ã€‚ å±æ€§
å«ä¹‰
è¯´æ˜ vertices
å¤šè¾¹å½¢çš„é¡¶ç‚¹
å¯ä»¥åœ¨ vertices å±æ€§ä¸­ä¾æ¬¡è®¾ç½®æ¯ä¸ªç‚¹çš„ä¸‰ç»´åæ ‡ã€‚ç¬¬ä¸‰ç»´çš„åæ ‡ä¸ä¼šäº§ç”Ÿå½±å“ï¼Œä½†æ˜¯èµ·åˆ°å ä½ä½œç”¨ã€‚ size
ä½“ç§¯
ç”±äºç¬¬ä¸‰ç»´çš„åæ ‡ä¸å½±å“ï¼Œä¸”å¤šè¾¹å½¢çš„é¡¶ç‚¹ç¡®å®šåé¢ç§¯å°±å·²ç»ç¡®å®šï¼Œå› æ­¤ size å±æ€§é€šè¿‡æ§åˆ¶æ¯ä¸ªç‚¹çš„ç¬¬ä¸‰ç»´åæ ‡å€¼æ¥æ§åˆ¶ä½“ç§¯ã€‚ ä¸åŒsizeå¯¹äºç›¸åŒpolygonä½“ç§¯çš„å½±å“`},{header:"å¤–éƒ¨æ¨¡å‹",slug:"å¤–éƒ¨æ¨¡å‹",content:`å¼•ç”¨å¤–éƒ¨æ–‡ä»¶ã€‚ä½†æ˜¯ç›®å‰å¯¹äºMicroCityWebæ¥è¯´ï¼Œæš‚æ—¶åªèƒ½å¼•ç”¨ç½‘ç«™ä¸­å†…ç½®çš„æ–‡ä»¶ã€‚
ä¾‹å¦‚å†…ç½®ç¤ºä¾‹ä¸­å¼•ç”¨ç½‘ç«™å†…éƒ¨æ–‡ä»¶åœ¨è§†å›¾ä¸­ç”Ÿæˆä¸€è¾†å¢å¼è´§è½¦ï¼š
local obj = scene.addobj('/res/2axle.glb')
è¿˜å¯ä»¥é€šè¿‡å¼•ç”¨æ–‡ä»¶çš„ç½‘å€å¼•ç”¨å¤–éƒ¨æ¨¡å‹ï¼š
local obj = scene.addobj('https://huuhghhgyg.github.io/ModelResource/models/F16-lite.glb') æç¤º
å¦‚æœéœ€è¦å¤–éƒ¨æ¨¡å‹ï¼Œå¯ä»¥åˆ° ModelResourceä»“åº“ ä¸­æ‰¾æœ‰æ²¡æœ‰åˆé€‚çš„æ¨¡å‹ã€‚å¦‚æœå…¶ä¸­æ²¡æœ‰åˆé€‚çš„æ¨¡å‹ï¼Œä½†æ˜¯ä½ æ‰‹ä¸Šåˆæœ‰ç‰¹åˆ«æƒ³ç”¨çš„æ¨¡å‹ï¼Œå¯ä»¥æŒ‰ç…§ ModelResourceä»“åº“æä¾›çš„æŒ‡å¼• è¿›è¡ŒPull Requestè¯·æ±‚ä¸Šä¼ æ¨¡å‹ã€‚ä¸€æ—¦ä½ çš„Pull Requestè¢«åŒæ„ï¼ŒGithubå·¥ä½œæµä¼šç«‹å³å°†ä½ ä¸Šä¼ çš„æ¨¡å‹éƒ¨ç½²åˆ°ä»“åº“ç½‘é¡µä¸­ä¾›ä½¿ç”¨å¹¶ä»¥é‚®ä»¶å½¢å¼é€šçŸ¥ã€‚ ç›¸å…³ä¿¡æ¯
å¦‚æœæ‰‹ä¸­æœ‰ä¸‰ç»´æ¨¡å‹èµ„æºï¼Œå¯ä»¥åœ¨3D Viewerä¸­æŸ¥çœ‹ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è¿™ä¸ªç½‘ç«™å¯¼å‡ºä¸º .glb æ¨¡å‹`},{header:"light",slug:"light",content:"è®¾ç½®å…‰æºçš„æ–¹å‘ï¼Œå¯é€‰å‚æ•° vertices ä¸ºä¸€ä¸ªä¸‰ç»´å‘é‡ï¼Œè¡¨ç¤ºå…‰çš„ç…§å°„æ–¹å‘ã€‚ç”±äºMicroCity Webçš„åœºæ™¯ä¸­å·²ç»è®¾ç½®äº†å¾ˆå¼ºçš„å…‰æºï¼Œå› æ­¤æ­¤å¤„ä¸è¿‡å¤šåšä»‹ç»ã€‚"},{header:"mesh",slug:"mesh",content:"å¤šä¸ªç‚¹æ„æˆçš„é¢ï¼Œå¤šè§äºå¼•ç”¨çš„å¤–éƒ¨æ¨¡å‹ä¸­ã€‚ç”±äºåº”ç”¨è¾ƒå°‘æ­¤å¤„ä¸åšä»‹ç»ã€‚"},{header:"å¯¹è±¡æ§åˆ¶å‡½æ•°",slug:"å¯¹è±¡æ§åˆ¶å‡½æ•°",content:"ä¸‹é¢å‡å®šè¦æ“ä½œçš„ä¸‰ç»´å¯¹è±¡ä¸º obj"},{header:"getpos()",slug:"getpos",content:`è·å– obj å¯¹è±¡çš„ä½ç½®åæ ‡ (x, y, z)
local x, y, z = obj:getpos()`},{header:"setpos()",slug:"setpos",content:`è®¾ç½® obj å¯¹è±¡çš„ä½ç½®åæ ‡ä¸º (x, y, z)
obj:setpos(x, y, z)`},{header:"getrot()",slug:"getrot",content:`è·å– obj å¯¹è±¡åœ¨ x, y, z æ–¹å‘ä¸Šçš„æ—‹è½¬å¼§åº¦å€¼ (rx, ry, rz)
local rx, ry, rz = obj:getrot()`},{header:"setrot()",slug:"setrot",content:`è®¾ç½® obj å¯¹è±¡åœ¨ x, y, z æ–¹å‘ä¸Šçš„æ—‹è½¬å¼§åº¦å€¼ä¸º (rx, ry, rz)
obj:setrot(rx, ry, rz)`},{header:"getscale()",slug:"getscale",content:`è·å– obj å¯¹è±¡åœ¨ x, y, z æ–¹å‘ä¸Šçš„ç¼©æ”¾æ¯”ä¾‹ sx, sy, sz
local rx, ry, rz = obj:getrot()`},{header:"setscale()",slug:"setscale",content:`è®¾ç½® obj å¯¹è±¡åœ¨ x, y, z æ–¹å‘ä¸Šçš„ç¼©æ”¾æ¯”ä¾‹ sx, sy, sz
local rx, ry, rz = obj:getrot()`},{header:"getchildren()",slug:"getchildren",content:`è·å– obj å¯¹è±¡çš„å­å¯¹è±¡è¡¨
local children = obj:getchildren()`},{header:"getchildren()",slug:"getchildren-1",content:`è®¾ç½® obj å¯¹è±¡çš„å­å¯¹è±¡è¡¨
obj:setchildren(children_table)`},{header:"getparent()",slug:"getparent",content:`è·å– obj å¯¹è±¡çš„çˆ¶å¯¹è±¡
local num = obj:getparent() æ­¤å¤„åªè¿”å›ä¸€ä¸ªæ•°å€¼`},{header:"setparent()",slug:"setparent",content:`è®¾ç½® obj å¯¹è±¡çš„çˆ¶å¯¹è±¡ä¸º obj0
obj:setparent(obj0)`},{header:"delete()",slug:"delete",content:`åˆ é™¤ obj å¯¹è±¡
obj:delete()`}]},{path:"/notes/3d-scene.html",title:"3D åœºæ™¯",pathLocale:"/",contents:[{header:"3D åœºæ™¯",slug:"_3d-åœºæ™¯",content:"æœ¬èŠ‚å°†ä»‹ç» MicroCity Web ä¸­çš„ä¸‰ç»´åœºæ™¯åŠå…¶è®¾ç½®ã€‚"},{header:"MicroCityWebä¸‰ç»´åœºæ™¯åæ ‡ç³»",slug:"microcitywebä¸‰ç»´åœºæ™¯åæ ‡ç³»",content:`MicroCity Webä¸­çš„ä¸‰ç»´åœºæ™¯åæ ‡ç³»ç¬¦åˆå³æ‰‹åæ ‡ç³»ï¼Œå„ä¸ªåæ ‡è½´çš„æ­£æ–¹å‘å…·ä½“è§ä¸‹å›¾ã€‚ MicroCity Webä¸­çš„åæ ‡ç³» æ‰‹åŠ¨ç»˜åˆ¶ä¸Šå›¾åæ ‡è½´çš„ä»£ç 
scene.setenv({grid="plane"}) -- x
scene.addobj("polyline", {vertices = {0,0,0, 10,0,0}, color = "blue"})
scene.addobj("points", {vertices = {10,0,0}, color = "blue", size = 5})
local labelx = scene.addobj("label",{text="x"})
labelx:setpos(10,1,0)
-- y
scene.addobj("polyline", {vertices = {0,0,0, 0,10,0}, color = "green"})
scene.addobj("points", {vertices = {0,10,0}, color = "green", size = 5})
local labelx = scene.addobj("label",{text="y"})
labelx:setpos(0,11,0)
-- z
scene.addobj("polyline", {vertices = {0,0,0, 0,0,10}, color = "red"})
scene.addobj("points", {vertices = {0,0,10}, color = "red", size = 5})
local labelx = scene.addobj("label",{text="z"})
labelx:setpos(0,1,10) scene.render()`},{header:"è®¾ç½®åœºæ™¯",slug:"è®¾ç½®åœºæ™¯",content:`è®¾ç½®åœºæ™¯éœ€è¦ç”¨åˆ° setenv å‡½æ•°ï¼Œå…·ä½“ç”¨æ³•å¦‚ä¸‹
local s = scene.setenv({grid="plane|sphere|none", bgcolor="rgb(255, 255, 255)", rotspeed=1, transpeed=1, camtype="ortho|persp", clear=true})
å¯ä»¥ç®€å•åœ°è¡¨ç¤ºä¸ºå¦‚ä¸‹å½¢å¼
local s = scene.setenv({key1 = value1, key2 = value2, ...})
å…¶ä¸­å˜é‡ s å­˜æ”¾è¿”å›çš„ç¯å¢ƒå¯¹è±¡ã€‚ä¸‹é¢å°†è¯¦ç»†ä»‹ç»å‡½æ•°çš„å¯é€‰å‚æ•°ã€‚`},{header:"åœºæ™¯å¯é€‰å‚æ•°",slug:"åœºæ™¯å¯é€‰å‚æ•°",content:""},{header:"å‚æ•°åˆ—è¡¨",slug:"å‚æ•°åˆ—è¡¨",content:`gridï¼šåœºæ™¯çš„èƒŒæ™¯ç½‘æ ¼
bgcolorï¼šåœºæ™¯èƒŒæ™¯é¢œè‰²
camtypeï¼šæ‘„åƒæœºè§†è§’
clearï¼šæ˜¯å¦æ¸…é™¤åœºæ™¯
rotspeed & transpeed*ï¼šé¼ æ ‡æ“ä½œé€Ÿåº¦è°ƒæ•´`},{header:"gridï¼šåœºæ™¯çš„èƒŒæ™¯ç½‘æ ¼",slug:"grid-åœºæ™¯çš„èƒŒæ™¯ç½‘æ ¼",content:`å¯é€‰å€¼ å€¼
å«ä¹‰ "none"
é»˜è®¤å€¼ï¼Œæ— ç½‘æ ¼ "plane"
å¹³åœ°ç½‘æ ¼ "sphere"
çƒå½¢ç½‘æ ¼`},{header:"bgcolorï¼šåœºæ™¯èƒŒæ™¯é¢œè‰²",slug:"bgcolor-åœºæ™¯èƒŒæ™¯é¢œè‰²",content:`å¯é€‰å€¼ç±»å‹ å€¼ç±»å‹
ç¤ºä¾‹ å†…ç½®é¢œè‰²
"black", "white", "gray" ç­‰ åå…­è¿›åˆ¶é¢œè‰²
"#ffffff", "#fff", "#000000", "#000"ç­‰ RGBè¡¨ç¤ºçš„é¢œè‰²
"rgb(255, 255, 255)", "rgb(0, 0, 0)" ç­‰ å®ä¾‹
scene.setenv({bgcolor='gray'}) --è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸ºå†…ç½®çš„gray
scene.setenv({bgcolor='#eee'}) --è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸º#eee
scene.setenv({bgcolor='rgb(255, 255, 255)'}) --è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸ºç™½è‰²`},{header:"camtypeï¼šæ‘„åƒæœºè§†è§’",slug:"camtype-æ‘„åƒæœºè§†è§’",content:`å¯é€‰å€¼ å€¼
å«ä¹‰ "ortho"
æ­£è§†ã€‚ç›¸å½“äºå‘xå’Œyæ„æˆçš„å¹³é¢æŠ•å½±ï¼Œç”¨æˆ·è§†è§’åœ¨äºŒç»´ç©ºé—´ä¸­ã€‚ "persp"
é€è§†ï¼ˆé»˜è®¤å€¼ï¼‰ã€‚ç”¨æˆ·è§†è§’åœ¨ä¸‰ç»´ç©ºé—´ä¸­ã€‚`},{header:"clearï¼šæ˜¯å¦æ¸…é™¤åœºæ™¯",slug:"clear-æ˜¯å¦æ¸…é™¤åœºæ™¯",content:"å€¼è®¾ç½®ä¸º true æ—¶ï¼Œæ¸…é™¤åœºæ™¯ setenv å‡½æ•°é»˜è®¤ä¸æ¸…é™¤åŸæ¥çš„åœºæ™¯ï¼Œé™¤éæ‰‹åŠ¨è®¾ç½®å‚æ•° clear çš„å€¼ä¸º true"},{header:"rotspeed & transpeed",slug:"rotspeed-transpeed",content:`å€¼
å«ä¹‰ rotspeed
è®¾ç½®é¼ æ ‡çš„æ—‹è½¬ä¸‰ç»´å¯¹è±¡çš„é€Ÿåº¦ transpeed
è®¾ç½®é¼ æ ‡å¹³ç§»ä¸‰ä½å¯¹è±¡çš„é€Ÿåº¦ æç¤º
è¿™ä¸¤ä¸ªå‚æ•°é€šå¸¸ä¸éœ€è¦ç‰¹åˆ«è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼å³å¯ã€‚`},{header:"å…¶ä»–",slug:"å…¶ä»–",content:""},{header:"æœ‰å…³é«˜é¢‘ç‡è®¾ç½®åœºæ™¯",slug:"æœ‰å…³é«˜é¢‘ç‡è®¾ç½®åœºæ™¯",content:`2023/03/21ï¼šç›®å‰å‘ç°è¿‡é«˜é¢‘æ¬¡è®¾ç½®åœºæ™¯ä¼šå¯¼è‡´å†…å­˜å ç”¨è¿‡é«˜ï¼Œè¿›è€Œå¯¼è‡´æµè§ˆå™¨å´©æºƒçš„é—®é¢˜ã€‚å› æ­¤å»ºè®®å°½é‡ä¸è¦å¾ªç¯è°ƒç”¨ scene.setenv() å‡½æ•°ã€‚
å¦‚æœå¿…é¡»è¿™ä¹ˆåšï¼Œè¯·ç¡®ä¿è°ƒç”¨é¢‘ç‡ç›¸å¯¹è¾ƒä½ï¼Œè¿™æ ·å…è®¸æµè§ˆå™¨æœ‰ä¸€å®šçš„æ—¶é—´è¿›è¡ŒGCï¼ˆåƒåœ¾æ¸…ç†ï¼‰ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´æµè§ˆå™¨å´©æºƒã€‚`}]},{path:"/notes/",title:"ç¬”è®°",pathLocale:"/",contents:[{header:"ç¬”è®°",slug:"ç¬”è®°",content:""},{header:"é€šç”¨çŸ¥è¯†",slug:"é€šç”¨çŸ¥è¯†",content:`Luaè¯­è¨€å¿«é€Ÿä¸Šæ‰‹
MicroCityçš„ç‰ˆæœ¬
æ—¶é—´æ¨è¿›æ³•
é¢å‘å¯¹è±¡ç¼–ç¨‹
æœ‰å…³å·¥å…·`},{header:"MicroCityï¼ˆæ¡Œé¢ç‰ˆï¼‰",slug:"microcity-æ¡Œé¢ç‰ˆ",content:`ç»“æœå¯è§†åŒ–
æ“ä½œç½‘ç»œ
æ¨¡å‹æ±‚è§£`},{header:"MicroCityWeb",slug:"microcityweb",content:`ç”¨æˆ·ç•Œé¢ç®€ä»‹
3D åœºæ™¯
3D å¯¹è±¡
ç¦»æ•£äº‹ä»¶ä»¿çœŸå’Œç¨‹åºæ§åˆ¶
æ··åˆæ•´æ•°è§„åˆ’
è°ƒè¯•ç›¸å…³`},{header:"æ€è·¯",slug:"æ€è·¯",content:`ä»“åº“ä»¿çœŸ
é€šç”¨ç»˜å›¾ä»£ç 
æ¸¯å£AGVæœåŠ¡æµç¨‹ä¸‰ç»´ä»¿çœŸæ€è·¯ æœ¬é¡µç›®å½•æ‰€æŒ‡çš„ç¬”è®°å†…å®¹é€‚ç”¨äºç›¸åº”ç‰ˆæœ¬çš„MicroCityã€‚ç‰¹åˆ«æ„Ÿè°¢åœ¨ç¼–å†™å’Œæ•´ç†çš„è¿‡ç¨‹ä¸­ å­™å“è€å¸ˆ(MicroCityä½œè€…) ç»™äºˆçš„æŒ‡å¯¼å’Œå¸®åŠ©ã€‚`}]},{path:"/notes/cy-simulation.html",title:"æ¸¯å£AGVæœåŠ¡æµç¨‹ä¸‰ç»´ä»¿çœŸæ€è·¯",pathLocale:"/",contents:[{header:"æ¸¯å£AGVæœåŠ¡æµç¨‹ä¸‰ç»´ä»¿çœŸæ€è·¯",slug:"æ¸¯å£agvæœåŠ¡æµç¨‹ä¸‰ç»´ä»¿çœŸæ€è·¯",content:"æœ¬æ–‡æ€è·¯ä»…ä¾›å‚è€ƒã€‚ é›†è£…ç®±ç å¤´çš„æµç¨‹ä»¿çœŸæ˜¯ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„ä»¿çœŸï¼Œéœ€è¦è€ƒè™‘çš„å› ç´ ã€æ¶‰åŠåˆ°çš„å¯¹è±¡æ¯”è¾ƒå¤šã€‚æœ¬æ–‡ä¸»è¦ä»‹ç»å¦‚ä½•ä½¿ç”¨MicroCityWebå®ç°AGVä»æ¥æ”¶åœºæ¡¥æœåŠ¡åˆ°æ¥å—å²¸æ¡¥æœåŠ¡æµç¨‹çš„æ€è·¯ã€‚"},{header:"å®ç°åœºæ¡¥å¯¹é›†è£…ç®±çš„æŠ“å–",slug:"å®ç°åœºæ¡¥å¯¹é›†è£…ç®±çš„æŠ“å–",content:""},{header:"æ€»ä½“æ€è·¯",slug:"æ€»ä½“æ€è·¯",content:"å®ç°åœºæ¡¥å¯¹é›†è£…ç®±çš„æŠ“å–æ˜¯å®ç°å †åœºä»¿çœŸçš„ç¬¬ä¸€æ­¥ã€‚è¿™ä¸ªéƒ¨åˆ†æˆ‘æ‰“ç®—ä½¿ç”¨é¢å‘å¯¹è±¡çš„æ–¹æ³•å®ç°ï¼Œå³å°†åœºæ¡¥å’Œå †åœºæŠ½è±¡ä¸ºå¯¹è±¡ã€‚"},{header:"æ€»ä½“ç»“æ„",slug:"æ€»ä½“ç»“æ„",content:`å…·ä½“çš„æƒ³æ³•æ˜¯å°†å †åœºå¯¹è±¡ä½œä¸ºæ•°æ®æ¨¡å‹(DataModel)ï¼Œä¸»è¦å­˜æ”¾å„ç§æ•°æ®ï¼Œå¦‚å­˜æ”¾é›†è£…ç®±å®ä½“ã€å¯¹åº”ä½ç½®(è¡Œã€åˆ—ã€é«˜åº¦)çš„é›†è£…ç®±åæ ‡ç­‰æ•°æ®ï¼›å°†åœºæ¡¥å¯¹è±¡ä½œä¸ºæ“ä½œå™¨(Operator)ï¼Œä¸»è¦å®ç°åœºæ¡¥çš„ä¸‰ç»´åŠ¨ç”»ã€å®ç°å¯¹å †åœºå¯¹è±¡ä¸­æ•°æ®çš„ç®¡ç†ã€‚
è¿™æ ·åšçš„å¥½å¤„æ˜¯å¯ä»¥å°†åœºæ¡¥å’Œå †åœºè§£è€¦åˆï¼Œæ–¹ä¾¿åç»­çš„æ‰©å±•ã€‚æ­¤å¤–ï¼Œå¦‚æœå¯¹è±¡å±æ€§è€ƒè™‘å¾—æ¯”è¾ƒå‘¨å…¨ï¼Œå¯ä»¥æ–¹ä¾¿åœ°åœ¨åŒä¸€ä¸ªåœºæ™¯ä¸­åˆ›å»ºå¤šä¸ªå¯¹è±¡ï¼Œå®ç°å¤šä¸ªåœºæ¡¥å¯¹å †åœºçš„æ“ä½œã€‚`},{header:"äº‹ä»¶å’Œä»»åŠ¡",slug:"äº‹ä»¶å’Œä»»åŠ¡",content:"æˆ‘æ‰“ç®—ä¸ºæ•´ä½“æµç¨‹ä¸­æ¶‰åŠåˆ°éœ€è¦ç§»åŠ¨çš„ä¸»è¦å®ä½“å¯¹è±¡åˆ›å»ºä»»åŠ¡åºåˆ—ã€‚è¿™æ ·å¯ä»¥åšåˆ°åœ¨åŒä¸€ä¸ªåœºæ™¯ä¸­å®ç°å¤šä¸ªåœºæ¡¥çš„å¹¶è¡Œæ“ä½œï¼Œå„ä¸ªåœºæ¡¥æ‰§è¡Œå„è‡ªçš„ä»»åŠ¡ï¼Œäº’ä¸å¹²æ‰°ã€‚æ­¤å¤–ï¼Œè¿˜éœ€è¦ä¸€ä¸ªæ€»æ§åˆ¶ç¨‹åºæ§åˆ¶æ¯ä¸ªæ—¶é—´èŠ‚ç‚¹çš„ä»»åŠ¡æ‰§è¡Œæƒ…å†µï¼Œå¹¶æ§åˆ¶åœºæ¡¥çš„ä¸‰ç»´åŠ¨ç”»ã€‚"},{header:"ä¸šåŠ¡æµç¨‹",slug:"ä¸šåŠ¡æµç¨‹",content:"åœ¨è¿™éƒ¨åˆ†çš„ä»¿çœŸä¸­ä¸»è¦ä¸šåŠ¡æµç¨‹èšç„¦äºé›†è£…ç®±çš„ç§»åŠ¨ã€‚å› æ­¤ï¼Œæœ€é‡è¦çš„å°±æ˜¯é›†è£…ç®±æ‰€æœ‰æƒçš„æµè½¬ã€‚é›†è£…ç®±çš„æ‰€æœ‰æƒæµè½¬æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š é›†è£…ç®±å¯¹è±¡æµè½¬è¿‡ç¨‹"},{header:"å¯¹è±¡ç»“æ„",slug:"å¯¹è±¡ç»“æ„",content:"ä»¥ä¸‹æ˜¯è¿™ä¸ªä»¿çœŸä¸­ä¸»è¦æ¶‰åŠåˆ°çš„å¯¹è±¡çš„ç»“æ„"},{header:"å®ç°æ–¹æ³•",slug:"å®ç°æ–¹æ³•",content:""},{header:"å †åœºè§„æ¨¡",slug:"å †åœºè§„æ¨¡",content:`å¯¹äºå †åœºå¯¹è±¡ï¼Œç”±äºå®ƒçš„åŠŸèƒ½ä¸»è¦æ˜¯å­˜æ”¾é›†è£…ç®±å¯¹è±¡åŠå…¶ç›¸å…³æ•°æ®ï¼ˆæ¯”å¦‚å¯¹åº”ä½ç½®çš„åæ ‡ï¼‰ï¼Œé‚£ä¹ˆå°±è¿˜ä¼šå‡ºç°ä¸€ä¸ªé—®é¢˜ï¼Œå †åœºçš„è§„æ¨¡æœ‰å¤šå¤§ï¼Ÿå› æ­¤ç¡®å®šå †åœºçš„è§„æ¨¡æ˜¯ä¸€ä¸ªå¿…è¦çš„æ­¥éª¤ã€‚åœ¨åˆ›å»ºå †åœºå¯¹è±¡æ—¶éœ€è¦ç¡®å®šæ‰€åˆ›å»ºçš„å †åœºçš„è§„æ¨¡ï¼Œå³è¡Œæ•°ã€åˆ—æ•°ã€é«˜åº¦ã€‚è¿™æ ·å¯ä»¥åœ¨åˆ›å»ºå †åœºå¯¹è±¡æ—¶å°±ç¡®å®šå †åœºçš„è§„æ¨¡ï¼Œæ–¹ä¾¿åç»­çš„æ“ä½œã€‚
æˆ‘çš„åšæ³•æ˜¯é¦–å…ˆç¡®å®šå †åœºå¯¹è±¡çš„å åœ°å¤§å°å’Œé›†è£…ç®±å±‚æ•°ï¼Œç„¶åç”±ç›¸å…³æ•°æ®å»è®¡ç®—æœ€å¤šèƒ½æ‘†æ”¾å‡ è¡Œå‡ åˆ—çš„é›†è£…ç®±ã€‚ å †åœºå åœ°å¤§å°æ–¹é¢ï¼Œé€šè¿‡åœ¨åˆ›å»ºå¯¹è±¡æ—¶è¾“å…¥ä¸¤ç‚¹åæ ‡æ¥ç¡®å®šï¼Œæ ¹æ®ä¸¤ç‚¹è¿æˆçš„å¯¹è§’çº¿æ„æˆä¸€ä¸ªçŸ©å½¢ï¼Œä»è€Œç¡®å®šå †åœºçš„å åœ°é¢ç§¯ã€‚
é›†è£…ç®±å±‚æ•°æ–¹é¢ï¼Œé€šè¿‡åœ¨åˆ›å»ºå¯¹è±¡æ—¶è¾“å…¥ä¸€ä¸ªæ•°å­—æ¥ç¡®å®šã€‚æ ¹æ®è¿™ä¸¤ä¸ªè¾“å…¥å°±å°±å¯ä»¥ç¡®å®šå †åœºçš„è§„æ¨¡ã€‚`},{header:"äº‹ä»¶å’Œä»»åŠ¡",slug:"äº‹ä»¶å’Œä»»åŠ¡-1",content:`ç”±äºåœ¨è¿™ä¸ªä»¿çœŸä¸­éœ€è¦ç§»åŠ¨çš„å¯¹è±¡ä¸»è¦æ˜¯åœºæ¡¥ï¼Œå› æ­¤æ¯æ¬¡å¾ªç¯æ‰§è¡Œä»»åŠ¡çš„æ—¶å€™åªéœ€è¦æ“ä½œåœºæ¡¥å³å¯ã€‚
å› æ­¤ï¼Œæˆ‘æ‰“ç®—å°†åœºæ¡¥çš„ä»»åŠ¡åºåˆ—ä½œä¸ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œæ¯æ¬¡å¾ªç¯æ‰§è¡Œä»»åŠ¡çš„æ—¶å€™ï¼Œä»å¯¹è±¡çš„ä»»åŠ¡åºåˆ—ä¸­å–å‡ºç¬¬ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œï¼Œæ‰§è¡Œå®Œæ¯•ååˆ¤æ–­æ˜¯å¦æ»¡è¶³ä»»åŠ¡æ‰§è¡Œå®Œæ¯•çš„æ¡ä»¶ï¼Œå¦‚æœæ»¡è¶³åˆ™åˆ é™¤è¿™ä¸ªä»»åŠ¡ï¼Œæ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚è¿™æ ·å¯ä»¥ä¿è¯æ¯æ¬¡å¾ªç¯æ‰§è¡Œä»»åŠ¡çš„æ—¶å€™ï¼Œåœºæ¡¥å¯¹è±¡èƒ½å¤ŸæŒ‰ç…§æ¬¡åºæ‰§è¡Œä»»åŠ¡ã€‚
æ‰§è¡Œä»»åŠ¡çš„æ–¹æ³•ä¸º executeTask(dt) ï¼Œå¯¹è±¡æ ¹æ®æ¨è¿›æ—¶é—´çš„é•¿çŸ­ dt æ‰§è¡Œä»»åŠ¡ã€‚åœ¨ executeTask(dt) ä¸­å­˜æ”¾äº†å¤„ç†ä»»åŠ¡çš„é€»è¾‘ï¼ŒåŒ…æ‹¬åˆ¤æ–­ä»»åŠ¡ç±»å‹ã€æ‰§è¡Œä»»åŠ¡ã€åˆ é™¤ä»»åŠ¡ç­‰ã€‚
å¦‚æœåœºæ™¯ä¸­å­˜åœ¨å¤šä¸ªåœºæ¡¥ï¼Œåªéœ€è¦å°†è¿™äº›å¯¹è±¡æ·»åŠ åˆ°æ‰§è¡Œä»»åŠ¡å¯¹è±¡çš„åˆ—è¡¨ä¸­å³å¯ã€‚ä¸»æ§ç¨‹åºæ¯æ¬¡å¾ªç¯æ‰§è¡Œä»»åŠ¡æ—¶ï¼Œä¼šéå†è¿™ä¸ªå¯¹è±¡åˆ—è¡¨ï¼Œä¾æ¬¡æ‰§è¡Œæ¯ä¸ªå¯¹è±¡çš„ä»»åŠ¡ã€‚ æç¤º
æ³¨æ„æ­¤å¤„ä»»åŠ¡æ‰§è¡Œè™½ç„¶åœ¨æ—¶é—´ç‚¹ä¸Šçœ‹æ˜¯åŒæ—¶æ‰§è¡Œçš„ï¼Œä½†æ˜¯å…¶å®å’Œå¯¹è±¡æ‰€å¤„çš„åºåˆ—ä½ç½®æœ‰å…³ã€‚
ä¸€ä¸ªä¾‹å­å°±æ˜¯ï¼šå‡è®¾ä¸¤ä¸ªå¯¹è±¡åŒæ—¶éœ€è¦æŠ¢å ä½ç½®Aï¼Œé‚£ä¹ˆæŒ‰ç…§ä»»åŠ¡åºåˆ—çš„é¡ºåºï¼Œå…ˆæ‰§è¡Œçš„å¯¹è±¡ä¼šæŠ¢å åˆ°ä½ç½®Aï¼Œåæ‰§è¡Œçš„å¯¹è±¡ä¼šæŠ¢å å¤±è´¥ï¼Œå°½ç®¡å®ƒä»¬åœ¨åŒä¸€æ—¶åˆ»éƒ½åœ¨æŠ¢å ä½ç½®Aã€‚å› æ­¤ï¼Œæ­¤å¤„ä¸æ˜¯ä¸¥æ ¼çš„åŒæ—¶æ‰§è¡Œï¼Œè€Œæ˜¯åŒä¸€æ—¶åˆ»æŒ‰ç…§ä»»åŠ¡åºåˆ—çš„é¡ºåºæ‰§è¡Œã€‚`},{header:"ä¸šåŠ¡æµç¨‹",slug:"ä¸šåŠ¡æµç¨‹-1",content:`åœºæ¡¥é¦–å…ˆä»å †åœºä¸­è·å–å¯¹åº”ä½ç½®(è¡Œã€åˆ—ã€é«˜åº¦)é›†è£…ç®±çš„åæ ‡ï¼Œå¹¶å°†åŠå…·ç§»åŠ¨åˆ°å †åœºæŒ‡å®šé›†è£…ç®±ä½ç½®ï¼ŒæŠ“å–é›†è£…ç®±ã€‚é›†è£…ç®±æ‰€æœ‰æƒä»å †åœºï¼ˆcy.containersï¼‰è½¬ç§»åˆ°åœºæ¡¥åŠå…·ï¼ˆrmg.attachedï¼‰ï¼ˆé€šè¿‡è§£é™¤è¡¨å¼•ç”¨å®ç°ï¼Œå°†å€¼è®¾ä¸º nilï¼‰ã€‚
åœºæ¡¥å°†é›†è£…ç®±ç§»åŠ¨åˆ°è¿‡é“å¹¶æ”¾ä¸‹é›†è£…ç®±ã€‚ä»¥åŒæ ·çš„æ–¹å¼å°†é›†è£…ç®±æ‰€æœ‰æƒä»åœºæ¡¥åŠå…·ï¼ˆrmg.attachedï¼‰ç§»åŠ¨åˆ°è¿‡é“ï¼ˆrmg.stashï¼‰ï¼Œè¡¨æ˜é›†è£…ç®±å¯ä»¥è¢«æå–ã€‚
å¦‚æœæœ‰è½¦è¾†å°†é›†è£…ç®±æ¥èµ°ï¼Œåˆ™å¯ä»¥è¿›ä¸€æ­¥å°†é›†è£…ç®±æ‰€æœ‰æƒä»åœºæ¡¥è¿‡é“ï¼ˆrmg.stashï¼‰ç§»åŠ¨åˆ°è½¦è¾†ä¸Šã€‚`},{header:"è¿è¡Œç»“æœ",slug:"è¿è¡Œç»“æœ",content:""},{header:"å®ç°AGVåˆ°è¾¾è‡³æœåŠ¡çš„å…¨æµç¨‹",slug:"å®ç°agvåˆ°è¾¾è‡³æœåŠ¡çš„å…¨æµç¨‹",content:""},{header:"é—®é¢˜æè¿°",slug:"é—®é¢˜æè¿°",content:"ä½¿ç”¨äº‹ä»¶è°ƒåº¦æ³•å®ç°ä»¥ä¸Šæµç¨‹çš„ä¸‰ç»´åŒ–å½¢å¼"},{header:"What's New",slug:"what-s-new",content:`ä¸Šä¸€ä¸ªä»¿çœŸçš„å®ç°æ˜¯å®ç°è¿™ä¸ªä»¿çœŸçš„åŸºç¡€ã€‚ç›¸æ¯”äºä¸Šä¸€ä¸ªä»¿çœŸï¼Œè¿™ä¸ªä»¿çœŸæœ€ä¸ºæ˜¾è‘—çš„æ”¹è¿›ä½“ç°åœ¨ï¼š ä½¿ç”¨é¢å‘å¯¹è±¡ç¼–ç¨‹æ¨¡å¼ï¼Œåˆ›å»ºåœºæ¡¥ã€å †åœºï¼ˆæ•°æ®æ¨¡å‹ï¼‰ã€AGVã€å²¸æ¡¥ã€èˆ¹ï¼ˆæ•°æ®æ¨¡å‹ï¼‰å…±4ä¸ªç±»å‹çš„å¯¹è±¡ï¼Œå¹¶å®ç°å¯¹è±¡æœ¬ä½“å’Œå…¶å„éƒ¨ä»¶çš„ç§»åŠ¨æ–¹æ³•ã€‚ å¦‚æœä¸äº†è§£é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œå¯ä»¥å‚è€ƒé€šç”¨çŸ¥è¯†-é¢å‘å¯¹è±¡ç¼–ç¨‹ å»¶ç»­é¢å‘äº‹ä»¶çš„ä»¿çœŸçš„æ€è·¯ï¼Œå®ç°äº†æ€»æ§åˆ¶æµç¨‹ï¼Œå®ç°åŒä¸€æ—¶åˆ»å¯¹å¤šä¸ªå¯¹è±¡åŒæ—¶è¿›è¡Œæ§åˆ¶ï¼ˆä¸»è¦é€šè¿‡å¯¹è±¡çš„ executeTask(dt) å’Œ maxStep() åŠç›¸å…³å‡½æ•°å®ç°ï¼‰ã€‚åœ¨é¢å‘å¯¹è±¡çš„ç¼–ç¨‹æ¨¡å¼ä¸­ï¼Œå¯ä»¥å°† executeTask(dt) å’Œ maxStep() è§†ä¸ºæ¥å£ï¼Œä¸»ç¨‹åºé€šè¿‡å®ç°è¿™ä¸¤ä¸ªæ¥å£ï¼Œå®ç°å¯¹å¯¹è±¡çš„æ§åˆ¶ã€‚ï¼ˆå°½ç®¡luaä¸­ä¼¼ä¹æ²¡æœ‰è¿™éƒ¨åˆ†çš„æ¦‚å¿µï¼‰
ä½¿ç”¨ä»»åŠ¡åºåˆ—å®ç°å„ä¸ªå¯¹è±¡çš„æµç¨‹ï¼Œå®ç°åœºæ¡¥å’ŒAGVä¹‹é—´ã€AGVå’Œå²¸æ¡¥ä¹‹é—´çš„ç›¸äº’ç­‰å¾…ï¼Œå®ç°ä¸åŒå¯¹è±¡ä¹‹é—´çš„ä»»åŠ¡ååŒã€‚
å°è¯•å°†æµç¨‹ä»å †åœºè‡³AGVå»¶ä¼¸è‡³å²¸æ¡¥ã€èˆ¹ï¼Œå®ç°ä¸¤çº§æ’é˜Ÿç­‰å¾…ã€‚`},{header:"å¯¹è±¡è®¾è®¡",slug:"å¯¹è±¡è®¾è®¡",content:`ç”±äºå±æ€§å’Œå‡½æ•°å®åœ¨å¤ªå¤šï¼Œå› æ­¤ä½¿ç”¨æ€ç»´å¯¼å›¾çš„å½¢å¼å±•ç¤ºå¯¹è±¡çš„è®¾è®¡ã€‚ æç¤º
æ­¤å¤„å ç”¨ç¯‡å¹…è¾ƒå¤§ï¼Œæ‚¨ä¹Ÿå¯ä»¥ç›´æ¥è·³è½¬åˆ°ä¸‹ä¸€éƒ¨åˆ†æ€»ä½“å¸ƒå±€`},{header:"å †åœº",slug:"å †åœº",content:"å †åœºä»ç„¶ä½œä¸ºæ•°æ®æ¨¡å‹ã€‚"},{header:"åœºæ¡¥",slug:"åœºæ¡¥",content:""},{header:"AGV",slug:"agv",content:""},{header:"å²¸æ¡¥",slug:"å²¸æ¡¥",content:"å²¸æ¡¥çš„ä»£ç å’Œæ¶‰åŠç»“æ„ä¸»è¦è¡ç”Ÿè‡ªå †åœºï¼Œå› æ­¤åé¢ä¸è¯¦ç»†å™è¿°ã€‚"},{header:"èˆ¹",slug:"èˆ¹",content:"èˆ¹å¯¹è±¡çš„ä¸»è¦ä½œç”¨ä¹Ÿæ˜¯ä½œä¸ºæ•°æ®æ¨¡å‹ï¼Œè®¾è®¡æ€è·¯åŒå †åœºã€‚"},{header:"æ€»ä½“å¸ƒå±€",slug:"æ€»ä½“å¸ƒå±€",content:""},{header:"æ€»ä½“æµç¨‹",slug:"æ€»ä½“æµç¨‹",content:"é›†è£…ç®±æµè½¬æµç¨‹ ç›¸æ¯”äºä¹‹å‰çš„ä»¿çœŸï¼Œè¿™ä¸ªä»¿çœŸåœ¨æµç¨‹ä¸Šæ›´è¿›äº†ä¸€æ­¥ï¼Œæ·»åŠ äº†AGVåˆ°è¾¾ã€æ’é˜Ÿçš„æµç¨‹ï¼Œè¿˜æ·»åŠ äº†å²¸æ¡¥æœåŠ¡ã€é›†è£…ç®±è£…èˆ¹çš„æµç¨‹ã€‚"},{header:"æµç¨‹åˆ†æ",slug:"æµç¨‹åˆ†æ",content:`AGVå‡ºç°åï¼Œåœºæ¡¥ã€å²¸æ¡¥å’ŒAGVä¹‹é—´çš„æµç¨‹ä¹Ÿå˜å¾—æ›´åŠ å¤æ‚ã€‚é¦–å…ˆï¼ŒAGVçš„åˆ°è¾¾æ˜¯éšæœºçš„ï¼Œå› æ­¤å¯èƒ½é€ æˆæ’é˜Ÿç°è±¡ã€‚å…¶æ¬¡ï¼ŒAGVçš„åˆ°è¾¾ä¼šè§¦å‘åœºæ¡¥å’ŒAGVçš„æµç¨‹ï¼Œè€Œåœºæ¡¥å’ŒAGVçš„æµç¨‹åˆä¼šè§¦å‘å²¸æ¡¥çš„æµç¨‹ã€‚å› æ­¤ï¼Œè¿™ä¸ªä»¿çœŸçš„æµç¨‹æ˜¯ä¸€ä¸ªå¤šçº§æµç¨‹ï¼Œéœ€è¦è€ƒè™‘å¤šä¸ªå¯¹è±¡ä¹‹é—´çš„æµç¨‹ååŒã€‚
ç‰¹åˆ«æ˜¯AGVå’Œåœºæ¡¥ä¹‹é—´çš„æµç¨‹ï¼Œå…¶ä¸­å­˜åœ¨AGVå’Œåœºæ¡¥çš„ç›¸äº’ç­‰å¾…ã€‚AGVåˆ°è¾¾çš„æ—¶å€™éœ€è¦é€šçŸ¥åœºæ¡¥æå–è´§ç‰©ã€‚åœ¨åœºæ¡¥æå–çš„è¿‡ç¨‹ä¸­: åœºæ¡¥éœ€è¦ç­‰å¾…AGVåˆ°è¾¾æŒ‡å®šä½ç½®åï¼Œæ‰èƒ½å°†è´§ç‰©ç§»åŠ¨åˆ°AGVä¸Š
AGVéœ€è¦ç­‰å¾…åœºæ¡¥çš„æŠ“å–å¹¶å°†é›†è£…ç®±æ”¾åœ¨AGVä¸Šä»¥åï¼Œæ‰èƒ½å°†é›†è£…ç®±çš„æ‰€æœ‰æƒä»åœºæ¡¥è½¬ç§»åˆ°AGVä¸Š å› æ­¤ï¼ŒAGVå’Œåœºæ¡¥ä¹‹é—´çš„æµç¨‹æ˜¯ä¸€ä¸ªç›¸äº’ç­‰å¾…çš„æµç¨‹ã€‚å…·ä½“æµç¨‹å¯ä»¥å‚è€ƒä¸‹å›¾ã€‚ è€Œå²¸æ¡¥çš„æµç¨‹å’Œåœºæ¡¥çš„æµç¨‹ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªç›¸äº’ç­‰å¾…çš„æµç¨‹ã€‚ä¸»è¦ä½“ç°åœ¨ï¼š å½“AGVåˆ°è¾¾æŒ‡å®šä½ç½®æ—¶ï¼Œå²¸æ¡¥å¯èƒ½åœ¨æœåŠ¡åˆ«çš„AGVï¼Œæ­¤æ—¶AGVè¦è¿›è¡Œç­‰å¾…
å½“AGVåˆšè¿›å…¥å²¸æ¡¥çš„æœåŠ¡åŒºåŸŸæ—¶ï¼Œé€šçŸ¥å²¸æ¡¥åˆ°è¾¾æŒ‡å®šä½ç½®ï¼Œå¦‚æœå²¸æ¡¥å…ˆåˆ°è¾¾æŒ‡å®šä½ç½®ï¼Œåˆ™æ­¤æ—¶å²¸æ¡¥è¦è¿›è¡Œç­‰å¾…`},{header:"å®ç°æ–¹æ³•",slug:"å®ç°æ–¹æ³•-1",content:""},{header:"æ’é˜Ÿæµç¨‹çš„å®ç°",slug:"æ’é˜Ÿæµç¨‹çš„å®ç°",content:`AGVæ’é˜Ÿçš„æƒ…å†µæˆ‘é€‰æ‹©ä½¿ç”¨å…ƒèƒè‡ªåŠ¨æœºä½œä¸ºåœè½¦ä½çš„æ•°æ®æ¨¡å‹ã€‚å…¶ä¸­ï¼Œåœè½¦ä½çš„é•¿åº¦ä¸ºï¼š
åœè½¦ä½é•¿åº¦=å¯¹åº”æ•°æ®æ¨¡å‹ä¸­1ä¸ªé›†è£…ç®±çš„é•¿åº¦+é›†è£…ç®±é—´éš”é•¿åº¦
\\text{åœè½¦ä½é•¿åº¦}=\\text{å¯¹åº”æ•°æ®æ¨¡å‹ä¸­1ä¸ªé›†è£…ç®±çš„é•¿åº¦}+\\text{é›†è£…ç®±é—´éš”é•¿åº¦}
åœè½¦ä½é•¿åº¦=å¯¹åº”æ•°æ®æ¨¡å‹ä¸­1ä¸ªé›†è£…ç®±çš„é•¿åº¦+é›†è£…ç®±é—´éš”é•¿åº¦
ç”±äºAGVçš„é•¿åº¦æ¯”1ä¸ªé›†è£…ç®±ç•¥é•¿ï¼Œå› æ­¤éœ€è¦å ç”¨2ä¸ªåœè½¦ä½çš„é•¿åº¦ã€‚æ¯æ¬¡æ‰§è¡Œä»»åŠ¡æ—¶ï¼ŒAGVä¼šåˆ¤æ–­å‰æ–¹ç©ºé—´æ˜¯å¦è¢«é˜»å¡ï¼Œå¦‚æœæ²¡è¢«é˜»å¡åˆ™å‘å‰ç§»åŠ¨ã€‚å¦‚æœå‰æ–¹ä½ç½®ä¸ºç›®æ ‡bayï¼Œåˆ™å‰è¿›åç­‰å¾…åœºæ¡¥ä½œä¸šï¼Œè·å–é›†è£…ç®±åç»§ç»­ä»¥å…ƒèƒä¸ºå•ä½å‘å‰ç§»åŠ¨ç›´åˆ°ç¦»å¼€ã€‚åœºæ¡¥éƒ¨åˆ†æ’é˜Ÿå’Œå²¸æ¡¥éƒ¨åˆ†æ’é˜ŸåŸç†ä¹Ÿç›¸åŒã€‚ AGVå…ƒèƒè‡ªåŠ¨æœºæ’é˜Ÿæ¨¡å‹ç¤ºæ„å›¾`},{header:"äº‹ä»¶è°ƒåº¦æ³•çš„å®ç°",slug:"äº‹ä»¶è°ƒåº¦æ³•çš„å®ç°",content:`åœ¨ä¹‹å‰çš„ä»¿çœŸä¸­ï¼Œæˆ‘ä½¿ç”¨äº†éå›ºå®šæ­¥é•¿çš„æ—¶é—´æ¨è¿›æ³•æ¥å®ç°ä»¿çœŸã€‚åœ¨è¿™ä¸ªä»¿çœŸä¸­ï¼Œæˆ‘ä½¿ç”¨äº†äº‹ä»¶è°ƒåº¦æ³•æ¥å®ç°ä»¿çœŸã€‚ç›¸æ¯”äºæ—¶é—´æ¨è¿›æ³•ï¼Œäº‹ä»¶è°ƒåº¦æ³•çš„ç‰¹ç‚¹æ˜¯å¯ä»¥å‡†ç¡®åœ°å°†äº‹ä»¶æ¨è¿›åˆ°å‘ç”Ÿçš„æ—¶åˆ»ï¼Œä»è€Œæ‰§è¡Œå¯¹åº”äº‹ä»¶ã€‚
ä½ å¯èƒ½æ³¨æ„åˆ°äº†å¯¹è±¡è®¾è®¡éƒ¨åˆ†æˆ‘å°† executeTask() å’Œ maxstep() æ ‡è®°ä¸º(interface)ï¼Œè¿™æ˜¯ç”±äºä¸ºäº†è®¡ç®—å‡†ç¡®çš„æ¨è¿›æ—¶é—´ï¼Œæˆ‘éœ€è¦åœ¨æ¯ä¸ªå¯¹è±¡ä¸­å®ç° executeTask() å’Œ maxstep() æ–¹æ³•ã€‚å…¶ä¸­ï¼ŒexecuteTask() æ–¹æ³•ç”¨äºæ‰§è¡Œä»»åŠ¡ï¼Œmaxstep() æ–¹æ³•ç”¨äºè®¡ç®—è·ç¦»åˆ°è¾¾ä¸‹ä¸€ä¸ªäº‹ä»¶çš„å‘ç”Ÿæ—¶é—´ï¼ˆå½“å‰ä»»åŠ¡è¿˜å‰©å¤šä¹…èƒ½æ‰§è¡Œå®Œï¼‰ï¼Œç„¶åå¾—åˆ°æœ€å¤§èƒ½å¤Ÿæ¨è¿›çš„æ—¶é—´ï¼Œå†å»è·Ÿç³»ç»Ÿè¿è¡Œå¾—åˆ°çš„é—´éš”æ—¶é—´dtè¿›è¡Œæ¯”è¾ƒå¾—åˆ°æœ€å¤§çš„æ¨è¿›æ—¶é—´ã€‚
æˆ‘è®¤ä¸ºè¯¾ä»¶ä¸­çš„ä¸‹é¢è¿™å¼ å›¾èƒ½å¤Ÿå¾ˆå¥½åœ°è¡¨ç¤ºå¦‚ä½•ä½¿ç”¨äº‹ä»¶è°ƒåº¦æ³•æ¥è¿›è¡Œä»¿çœŸå¹¶åˆ·æ–°åœºæ™¯ã€‚å…¶ä¸­ï¼Œç¬¬ä¸€è¡ŒæŒ‡çš„æ˜¯ä»¿çœŸçš„ä¸šåŠ¡æµç¨‹ï¼Œç¬¬äºŒè¡ŒRefreshéƒ¨åˆ†æŒ‡çš„æ˜¯åˆ·æ–°åœºæ™¯ã€‚`},{header:"è¿è¡Œç»“æœ",slug:"è¿è¡Œç»“æœ-1",content:`æ³¨æ„
ç”±äºä»¥ä¸‹éƒ¨åˆ†å†…å®¹å‡ä¸ºåŠ¨å›¾ä¸”å›¾ç‰‡ä½“ç§¯è¾ƒå¤§ã€‚ç”±äºæœ¬ç«™æ‰˜ç®¡äºGitHubPageï¼Œå› æ­¤å¦‚æœæ‚¨æ²¡æœ‰çš„ç‰¹æ®Šç½‘ç»œç¯å¢ƒå¯èƒ½ä¼šé€ æˆåŠ¨å›¾åŠ è½½ç¼“æ…¢ç”šè‡³åŠ è½½å¤±è´¥ã€‚ æç¤º
å¦‚æœæ‚¨ç›´æ¥è§‚çœ‹åŠ¨å›¾çš„æ—¶å€™åŠ¨å›¾åŒºåŸŸå‡ºç°äº†æ‘©å°”çº¹ï¼Œå¯ä»¥å°è¯•å°†åŠ¨å›¾ç‚¹å¼€æ”¾å¤§çœ‹ï¼Œå†çœ‹çœ‹æ˜¯å¦æœ‰æ”¹å–„ã€‚ åœºæ¡¥è¿è¡Œè¿‡ç¨‹ å²¸æ¡¥è¿è¡Œè¿‡ç¨‹ æ€»ä½“è¿è¡Œè¿‡ç¨‹`}]},{path:"/notes/debug.html",title:"è°ƒè¯•ç›¸å…³",pathLocale:"/",contents:[{header:"è°ƒè¯•ç›¸å…³",slug:"è°ƒè¯•ç›¸å…³",content:"æœ¬é¡µä»‹ç» MicroCity Web è°ƒè¯•ï¼ˆdebugï¼‰ç›¸å…³çš„å‡½æ•°å’Œå¿«æ·é”®ã€‚"},{header:"æ¸…é™¤è¾“å‡º",slug:"æ¸…é™¤è¾“å‡º",content:"å³é”®è¾“å‡ºåŒºåŸŸå¯ä»¥è¾“å…¥å‘½ä»¤ï¼Œè¾“å…¥ print() å¯ä»¥æ¸…é™¤è¾“å‡ºåŒºåŸŸçš„å†…å®¹ã€‚"},{header:"è°ƒè¯•å™¨å¿«æ·é”®",slug:"è°ƒè¯•å™¨å¿«æ·é”®",content:`åœ¨è°ƒè¯•ç¨‹åºçš„è¿‡ç¨‹ä¸­ï¼Œç‰¹åˆ«æ˜¯åœ¨æ–­ç‚¹å¤„ï¼Œå¯ä»¥ä½¿ç”¨F9ï¼ˆStep Overï¼‰ã€F10ï¼ˆStep Intoï¼‰ã€F11ï¼ˆStep Outï¼‰æ§åˆ¶ç¨‹åºè¿è¡Œã€‚ F9 Step Overï¼šè·³è¿‡å½“å‰è¡Œï¼Œæ‰§è¡Œä¸‹ä¸€è¡Œ
F10 Step Intoï¼šè¿›å…¥å½“å‰è¡Œï¼Œå¦‚æœå½“å‰è¡Œæ˜¯å‡½æ•°è°ƒç”¨ï¼Œåˆ™è¿›å…¥å‡½æ•°å†…éƒ¨
F11 Step Outï¼šè·³å‡ºå½“å‰å‡½æ•°ï¼Œæ‰§è¡Œå‡½æ•°è°ƒç”¨çš„ä¸‹ä¸€è¡Œ`},{header:"Debugå‘½ä»¤",slug:"debugå‘½ä»¤",content:""},{header:"ç›‘è§†å˜é‡",slug:"ç›‘è§†å˜é‡",content:`åœ¨æ§åˆ¶å°ä½¿ç”¨ debug.watch() å‘½ä»¤ç›‘è§†å˜é‡ã€‚
ä¾‹å¦‚ï¼Œåœ¨è°ƒè¯•çš„è¿‡ç¨‹ä¸­æƒ³è¦ç›‘è§† a å˜é‡çš„å€¼ï¼Œå¯ä»¥ä½¿ç”¨ debug.watch('a') å‘½ä»¤ã€‚ å³é”®è¾“å‡ºåŒºåŸŸå¯ä»¥è¾“å…¥å‘½ä»¤`},{header:"å †æ ˆè·Ÿè¸ª",slug:"å †æ ˆè·Ÿè¸ª",content:`ä½¿ç”¨ debug.traceback() å‡½æ•°å¯ä»¥æ‰“å°å‡ºå½“å‰çš„å †æ ˆè·Ÿè¸ªä¿¡æ¯
function myFunction() -- æŸäº›ä»£ç é€»è¾‘ print(debug.traceback("Stack trace")) -- å…¶ä»–ä»£ç é€»è¾‘
end function anotherFunction() myFunction()
end anotherFunction()
è¾“å‡ºç»“æœ
Stack trace
stack traceback:
[string "function myFunction() ..."]:3: in function 'myFunction'
[string "function myFunction() ..."]:8: in function 'anotherFunction'
[string "function myFunction() ..."]:11: in main chunk`},{header:"è¿è¡ŒçŠ¶æ€",slug:"è¿è¡ŒçŠ¶æ€",content:`debug.debug() è¿›å…¥Debugæ¨¡å¼ã€‚å¸¸ç”¨äºåœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­è¿›å…¥Debugæ¨¡å¼ã€‚å¦‚æœæƒ³è¦å¯åŠ¨æ—¶å°±è¿›å…¥Debugæ¨¡å¼ï¼Œå¯ä»¥å³é”®é¡¶éƒ¨â–¶ï¸æŒ‰é’®ã€‚è¯¦è§ ç”¨æˆ·ç•Œé¢ç®€ä»‹ - è¿è¡ŒçŠ¶æ€ã€‚
debug.pause() æš‚åœç¨‹åºè¿è¡Œã€‚é¡¶éƒ¨è¿è¡ŒæŒ‰é’®â–¶ï¸ä¼šäº®èµ·ï¼Œæš‚åœæŒ‰é’®â¸ï¸ç†„ç­ã€‚`},{header:"å…¶ä»–è°ƒè¯•å‘½ä»¤",slug:"å…¶ä»–è°ƒè¯•å‘½ä»¤",content:`Lua çš„ Debug å‡½æ•°å¤§å¤šéƒ½é€‚ç”¨äº MicroCity Webï¼Œå¯ä»¥å‚è€ƒï¼š The Debug Library | Lua 5.4 Reference Manual
Lua è°ƒè¯•(Debug) | èœé¸Ÿæ•™ç¨‹`},{header:"æ–‡ä»¶ä¿å­˜",slug:"æ–‡ä»¶ä¿å­˜",content:`MicroCity Web åœ¨ä¿å­˜æ–‡ä»¶æ—¶å¯ä»¥é€‰æ‹©ä¿å­˜ä¸º .mw æ–‡ä»¶å’Œ .lua æ–‡ä»¶ã€‚ .mw æ–‡ä»¶ï¼šæ‰“åŒ…å½“å‰çš„æ•´ä¸ªé¡¹ç›®ï¼ŒåŒ…å«å½“å‰æ‰“å¼€çš„ä»£ç æ–‡ä»¶å’Œè™šæ‹Ÿç£ç›˜ä¸­çš„æ–‡ä»¶ã€‚
.lua æ–‡ä»¶ï¼šä»…ä¿å­˜å½“å‰ç¼–è¾‘çš„ä»£ç æ–‡ä»¶ã€‚å¸¸ç”¨äºä»…ç¼–å†™ lua è„šæœ¬å’Œä¿®æ”¹è‡ªå®šä¹‰.luaåº“æ–‡ä»¶çš„æƒ…å†µã€‚`}]},{path:"/notes/event-scheduling.html",title:"ç¦»æ•£äº‹ä»¶ä»¿çœŸå’Œç¨‹åºæ§åˆ¶",pathLocale:"/",contents:[{header:"ç¦»æ•£äº‹ä»¶ä»¿çœŸå’Œç¨‹åºæ§åˆ¶",slug:"ç¦»æ•£äº‹ä»¶ä»¿çœŸå’Œç¨‹åºæ§åˆ¶",content:"æœ¬æ–‡ä¸»è¦ä»‹ç»å¦‚ä½•åœ¨ MicroCity Web ä¸­å®ç°ç¦»æ•£äº‹ä»¶ä»¿çœŸå’Œç¨‹åºæ§åˆ¶ã€‚"},{header:"åç¨‹",slug:"åç¨‹",content:"MicroCity Webä¸­æä¾›äº†å‡ ä¸ªåç¨‹ç›¸å…³å‡½æ•°ï¼Œæ–¹ä¾¿å®ç°äº‹ä»¶è°ƒåº¦æ³•ã€‚å¦‚æœä¸»è¦ç”¨äºå®ç°äº‹ä»¶è°ƒåº¦æ³•ä¸”å°šä¸æ¸…æ¥šäº‹ä»¶è°ƒåº¦æ³•çš„åŸç†ï¼Œå¯ä»¥é˜…è¯» æ—¶é—´æ¨è¿›æ³•-äº‹ä»¶è°ƒåº¦æ³• éƒ¨åˆ†äº†è§£ç›¸å…³æ¦‚å¿µã€‚"},{header:"coroutine.queue",slug:"coroutine-queue",content:`å°†å‡½æ•°æˆ–åç¨‹æ·»åŠ åˆ°åç¨‹é˜Ÿåˆ—ä¸­ç­‰å¾…
coroutine.queue(rt, f|co [, å‚æ•°åˆ—è¡¨...])
å‚æ•° å‚æ•°
å«ä¹‰ rt
ç›¸å¯¹å½“å‰é˜Ÿåˆ—çš„æ—¶é—´ï¼Œè¦æ±‚å¤§äºç­‰äº0ã€‚æ¢å¥è¯è¯´ï¼Œä¹Ÿå°±æ˜¯å†è¿‡rtæ‰§è¡Œè¾“å…¥çš„å‡½æ•°æˆ–åç¨‹ f/co
å‡½æ•°æˆ–åç¨‹ã€‚å¦‚æœæ˜¯å‡½æ•°ï¼Œåªéœ€è¦è¾“å…¥å‡½æ•°å`},{header:"coroutine.qtime",slug:"coroutine-qtime",content:`è·å–å½“å‰é˜Ÿåˆ—çš„æ—¶é—´
local time = coroutine.qtime()`},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹",content:`æ­¤å¤„æä¾›ä¸¤ä¸ªç¤ºä¾‹ åç¨‹æ·»åŠ ä»»åŠ¡ï¼šä½¿ç”¨åç¨‹æ·»åŠ ä»»åŠ¡ï¼Œå¹¶åœ¨å‡½æ•°ä¸­æ˜¾ç¤ºå½“å‰é˜Ÿåˆ—æ—¶é—´
è½¦è¾†ç§»åŠ¨ï¼šä½¿ç”¨åç¨‹å®ç°ä»¥çœŸå®ä¸–ç•Œçš„æ—¶é—´åˆ·æ–°åœºæ™¯`},{header:"åç¨‹æ·»åŠ ä»»åŠ¡",slug:"åç¨‹æ·»åŠ ä»»åŠ¡",content:`è¿™ä¸ªç¤ºä¾‹ä¸­å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨åç¨‹æ·»åŠ ä»»åŠ¡ï¼Œå¹¶åœ¨å‡½æ•°ä¸­æ˜¾ç¤ºå½“å‰é˜Ÿåˆ—æ—¶é—´
function Show() print("å½“å‰æ—¶é—´ï¼š",coroutine.qtime())
end
function ShowShort() print("å½“å‰æ—¶é—´shortï¼š",coroutine.qtime())
end coroutine.queue(10, Show)
coroutine.queue(20, Show)
coroutine.queue(15, ShowShort)
coroutine.queue(5, Show) -- ç»“æœï¼š
-- å½“å‰æ—¶é—´ï¼š 5.0
-- å½“å‰æ—¶é—´ï¼š 10.0
-- å½“å‰æ—¶é—´shortï¼š 15.0
-- å½“å‰æ—¶é—´ï¼š 20.0`},{header:"è½¦è¾†ç§»åŠ¨",slug:"è½¦è¾†ç§»åŠ¨",content:`è¿™ä¸ªç¤ºä¾‹ä¸­å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨åç¨‹å®ç°ä»¥çœŸå®ä¸–ç•Œçš„æ—¶é—´åˆ·æ–°åœºæ™¯
scene.setenv({grid='plane'}) -- è®¾ç½®åœºæ™¯ç½‘æ ¼èƒŒæ™¯ -- è½¦è¾†
local car = scene.addobj('/res/2axle.glb')
car.speed = 1 --è½¦é€Ÿåº¦ -- åˆå§‹æ—¶é—´
local t = os.clock()
local dt = 0 -- åˆ·æ–°æ—¶é—´çŠ¶æ€tå’Œdt(æŒ‰ç…§CPUé—´éš”æ­¥è¿›ï¼Œè¾¾åˆ°å’ŒçœŸå®æ—¶é—´åŒæ­¥)
function refreshtime() dt = os.clock() - t t = os.clock()
end -- åç¨‹æ›´æ–°åœºæ™¯
function update() if not scene.render() then return end --æ¸²æŸ“åœºæ™¯å¹¶æ£€æŸ¥ç¨‹åºæ˜¯å¦ä¸­æ­¢ coroutine.queue(dt, update) --æ ¹æ®CPUæ­¥è¿›æ—¶é—´æ·»åŠ ä¸‹ä¸€æ¬¡æ›´æ–° carmove() --ç§»åŠ¨è½¦è¾† refreshtime() --è®¡ç®—æœ¬æ¬¡dt
end -- è½¦è¾†ç§»åŠ¨
function carmove() print() print("car move at ",t) local x, y, z = car:getpos() car:setpos(x,y,z+dt*car.speed)
end -- åˆå§‹æ›´æ–°ï¼ˆæ·»åŠ ç¬¬ä¸€æ¬¡æ›´æ–°ï¼‰
-- ç”±äºå‡½æ•°ä¸­æ¶‰åŠåˆ°æ·»åŠ åç»­æ›´æ–°ï¼Œå› æ­¤æ›´æ–°ä¼šè‡ªåŠ¨å¾ªç¯
coroutine.queue(dt,update)
åœ¨MicroCityWebä¸­æ‰“å¼€`},{header:"éšæœºæ•°",slug:"éšæœºæ•°",content:""},{header:"éšæœºæ•°ç”ŸæˆåŸç†ç®€ä»‹",slug:"éšæœºæ•°ç”ŸæˆåŸç†ç®€ä»‹",content:`åœ¨è®¡ç®—æœºç§‘å­¦é¢†åŸŸï¼Œæ‰€è°“çš„â€œéšæœºé€‰æ‹©â€å®é™…ä¸Šå¹¶éçœŸæ­£çš„éšæœºã€‚äº‹å®ä¸Šï¼Œè®¡ç®—æœºè¿›è¡Œçš„ä¸€åˆ‡æ“ä½œéƒ½ä¸å…·å¤‡çœŸæ­£çš„éšæœºæ€§ã€‚å·²ç»æœ‰ç ”ç©¶è¯æ˜äº†â€œæ— æ³•åˆ¶é€ ä¸€å°çœŸæ­£èƒ½å¤Ÿç”Ÿæˆç»å¯¹éšæœºæ•°çš„è®¡ç®—æœºâ€çš„äº‹å®ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ç›®å‰æ‰€ä½¿ç”¨çš„éšæœºæ•°å®é™…ä¸Šæ˜¯ä¼ªéšæœºæ•°ã€‚
é‚£ä¹ˆï¼Œå¦‚ä½•ç”Ÿæˆè¿™äº›ä¼ªéšæœºæ•°å‘¢ï¼Ÿä¸€ç§å¸¸è§çš„æ–¹æ³•æ˜¯åˆ©ç”¨ç®—æ³•ï¼Œæ ¹æ®ç»™å®šçš„åˆå§‹æ•°å­—ï¼ˆéšæœºæ•°ç§å­ï¼‰æ¥äº§ç”Ÿä¸€ä¸ªæ•°å­—åºåˆ—ã€‚è¯¥ç®—æ³•æ ¹æ®ç§å­è¿›è¡Œåˆå§‹åŒ–ï¼Œå¹¶ä¸æ–­è¿­ä»£ç”Ÿæˆåç»­çš„éšæœºæ•°åºåˆ—ã€‚å¦‚æœä½¿ç”¨ç›¸åŒçš„ç§å­ï¼Œé‚£ä¹ˆç”Ÿæˆçš„éšæœºæ•°åºåˆ—ä¹Ÿå°†æ˜¯ç›¸åŒçš„ã€‚
ä¸ºäº†äº§ç”Ÿä¸åŒçš„éšæœºåºåˆ—ï¼Œé€šå¸¸ä¼šåˆ©ç”¨è®¡ç®—æœºçš„æ—¶é’Ÿä½œä¸ºç§å­ã€‚è¿™ç§æ–¹æ³•çš„åŸºæœ¬åŸç†æ˜¯ï¼šç”±äºæˆ‘ä»¬æ— æ³•å‡†ç¡®çŸ¥é“ç¨‹åºå¯åŠ¨çš„æ—¶åˆ»ï¼Œå› æ­¤æ¯æ¬¡å¯åŠ¨ç¨‹åºéƒ½å¯ä»¥è®¤ä¸ºæ˜¯å¾—åˆ°äº†ä¸€ä¸ªéšæœºçš„æ—¶åˆ»ï¼Œä»è€Œè·å¾—ä¸€ä¸ªä¸åŒçš„ç§å­ã€‚ç”±äºæˆ‘ä»¬æ— æ³•ç¡®å®šç§å­çš„å…·ä½“å–å€¼ï¼Œå› æ­¤è¿™ç§æ–¹æ³•äº§ç”Ÿçš„éšæœºæ•°åºåˆ—æ˜¯ä¸å¯é¢„æµ‹çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ— æ³•ç¡®å®šç§å­çš„å…·ä½“å–å€¼ã€‚`},{header:"åˆ›å»ºéšæœºæ•°ç§å­",slug:"åˆ›å»ºéšæœºæ•°ç§å­",content:`local seed = math.randomseed(x [, dist])
å‚æ•° å‚æ•°
å«ä¹‰ x
éšæœºæ•°ç§å­ï¼Œä¼šæ ¹æ®è¾“å…¥çš„ä¸åŒæ•°å€¼è¿”å›ä¸åŒçš„éšæœºæ•°ã€‚å¦‚æœéœ€è¦æ¯æ¬¡çš„å€¼éƒ½ä¸ä¸€æ ·ï¼Œå¯ä»¥è€ƒè™‘å°†éšæœºæ•°ç§å­xè®¾ç½®ä¸ºå½“å‰æ—¶é—´ dist
éšæœºæ•°åˆ†å¸ƒï¼ˆå¯é€‰å‚æ•°ï¼‰ã€‚å¦‚æœä¸è®¾ç½®ï¼Œé»˜è®¤ä¸ºå‡åŒ€åˆ†å¸ƒã€‚å¦‚æœè®¾ç½®è¿™ä¸ªå‚æ•°ï¼Œè¿˜å¯ä»¥è®¾ç½® mu å’Œ sigma ä½œä¸ºå¯¹åº”åˆ†å¸ƒçš„å‚æ•° distå‚æ•°å¯ä»¥è®¾ç½®é”®å€¼ä¸ºä¸‰ç§åˆ†å¸ƒï¼š 'normal'ï¼šæ­£æ€åˆ†å¸ƒ
'exponential'ï¼šæŒ‡æ•°åˆ†å¸ƒ
'poisson'ï¼šæ³Šæ¾åˆ†å¸ƒ æ­¤å¤–ï¼Œè¿˜å¯ä»¥è®¾ç½®è¿™å‡ ç§åˆ†å¸ƒçš„å‚æ•°ï¼Œå…¶ä¸­ mu é”®ä¸ºå‡å€¼ï¼Œsigma é”®ä¸ºæ–¹å·®ã€‚`},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹-1",content:`-- åˆ›å»ºæ³Šæ¾åˆ†å¸ƒçš„éšæœºæ•°ç§å­
local seed = math.randomseed(os.time(), {distribution = "poisson", mu = "3"}) -- æ³Šæ¾åˆ†å¸ƒï¼Œå‡å€¼ä¸º3 -- è¾“å‡ºéšæœºæ•°
print(seed:random())`},{header:"ç¨‹åºæ§åˆ¶",slug:"ç¨‹åºæ§åˆ¶",content:`æœ¬æ–‡ä¸­çš„ç¨‹åºæ§åˆ¶ä¸»è¦æ˜¯æŒ‡å¦‚ä½•ä½¿ç”¨ç”¨æˆ·ç•Œé¢ä¸­çš„æŒ‰é’®æ§åˆ¶ç¨‹åºçš„è¿è¡Œï¼ŒåŒ…æ‹¬æš‚åœã€æ¢å¤ã€åœæ­¢ç­‰ã€‚ å‘½ä»¤æ  ä¸»è¦æ˜¯æŒ‡å‘½ä»¤æ çš„å‰3ä¸ªæŒ‰é’® MicroCity Webä¸­çš„ç¨‹åºæ§åˆ¶ä¸»è¦æ˜¯æŒ‡3Dç•Œé¢æ¸²æŸ“ä¸­é€šè¿‡ scene å¯¹è±¡å®ç°çš„3Dç•Œé¢è¿åŠ¨çš„æš‚åœã€æ¢å¤ã€åœæ­¢ï¼Œå…·ä½“çš„å‡½æ•°å¦‚ä¸‹ï¼š
local state = scene.render()
scene.render()å‡½æ•°çš„è¿”å›å€¼ä¸å‘½ä»¤æ ä¸­çš„åœæ­¢æŒ‰é’®â¹ç»‘å®šï¼Œå¯ä»¥ç”¨äºæ£€æŸ¥ç¨‹åºçš„è¿è¡ŒçŠ¶æ€ï¼štrueè¡¨ç¤ºç¨‹åºæ­£åœ¨è¿è¡Œï¼Œfalseè¡¨ç¤ºç¨‹åºå·²ç»è¢«ç»ˆæ­¢ã€‚æ­¤å¤„ç¤ºä¾‹å°†ç¨‹åºçš„è¿è¡ŒçŠ¶æ€å­˜æ”¾äº state å˜é‡ä¸­ï¼Œå¯ä»¥é€šè¿‡ state å˜é‡çš„å€¼æ¥æ§åˆ¶ç¨‹åºçš„è¿è¡ŒçŠ¶æ€ã€‚
3Då¯¹è±¡çš„æš‚åœæ¸²æŸ“ä¹Ÿæ˜¯é€šè¿‡è°ƒç”¨ scene.render() æ¥å®ç°çš„ã€‚å¦‚æœåˆ·æ–°3Då¯¹è±¡æ˜¯é€šè¿‡ä¸æ–­è°ƒç”¨ scene.render() å‡½æ•°å®ç°ï¼Œå¹¶ä¸”åˆ·æ–°é—´éš”æ—¶é—´ä¸æ˜¯é€šè¿‡ os.sleep() æ¥æ§åˆ¶ï¼Œé‚£ä¹ˆå¯ä»¥å®ç°åœ¨3Dç•Œé¢ä¸Šå°†æ¸²æŸ“æš‚åœåœ¨æŸä¸ªçŠ¶æ€ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœä½¿ç”¨ os.sleep() æ¥æ§åˆ¶3Då¯¹è±¡çš„è¿åŠ¨é€Ÿåº¦ï¼Œé‚£ä¹ˆå½“ç‚¹å‡»æš‚åœæŒ‰é’®æ—¶ï¼Œå¾ˆå¯èƒ½æ­£å¥½å¤„äº os.sleep() çš„è¿‡ç¨‹ä¸­ï¼Œå¯¼è‡´ç¨‹åºæ— æ³•ç«‹å³å“åº”ï¼Œä»è€Œå¯¼è‡´æš‚åœæŒ‰é’®æ— æ•ˆã€‚å› æ­¤ï¼Œå»ºè®®åœ¨æ§åˆ¶3Då¯¹è±¡çš„è¿åŠ¨é€Ÿåº¦æ—¶é¿å…ä½¿ç”¨ os.sleep()ï¼Œè€Œæ˜¯é€šè¿‡æ·»åŠ å…¶ä»–å‚æ•°çš„æ–¹å¼æ¥æ§åˆ¶æ¨è¿›æ—¶é•¿ï¼Œä»¥è¾¾åˆ°æ§åˆ¶3Då¯¹è±¡è¿åŠ¨é€Ÿåº¦çš„ç›®çš„ã€‚`}]},{path:"/notes/lp.html",title:"æ¨¡å‹æ±‚è§£",pathLocale:"/",contents:[{header:"æ¨¡å‹æ±‚è§£",slug:"æ¨¡å‹æ±‚è§£",content:`åœ¨MicroCityä¸­å¯ä»¥å¯¹æ•°å­¦æ¨¡å‹è¿›è¡Œæ±‚è§£ã€‚æ¥ä¸‹æ¥ï¼Œæœ¬æ–‡å°†ä»‹ç»åœ¨MicroCityä¸­æ±‚è§£æ•°å­¦æ¨¡å‹çš„å¸¸è§è¿‡ç¨‹ï¼Œå¹¶æä¾›ä¸€äº›æŠ€å·§å¸®åŠ©ä½ æ›´å¥½åœ°å»ºæ¨¡ã€‚
è§„åˆ’æ¨¡å‹ä¸­æ‰€æœ‰å‡½æ•°çš„è¯¦ç»†ç”¨æ³•å¯ä»¥å‚è€ƒæ–‡æ¡£ 4.8æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ æç¤º
æœ¬é¡µå†…å®¹åŸºäº MicroCity æ¡Œé¢ç‰ˆã€‚å¦‚æœä½ åœ¨å¯»æ‰¾ MicroCity Web ç‰ˆçš„æ··åˆæ•´æ•°è§„åˆ’æ±‚è§£æ–¹æ³•ï¼Œè¯·å‚è€ƒ MicroCity Web ç¬”è®°ä¸­å¯¹åº”çš„ æ··åˆæ•´æ•°è§„åˆ’ éƒ¨åˆ†ã€‚`},{header:"åˆ›å»ºæ¨¡å‹å¯¹è±¡",slug:"åˆ›å»ºæ¨¡å‹å¯¹è±¡",content:`åˆ›å»ºè§„åˆ’æ¨¡å‹å¯¹è±¡ï¼Œå­˜å…¥å˜é‡lpä¸­ã€‚
local lp = CreateLP() å®˜æ–¹æ–‡æ¡£ä¸­å°†åˆ›å»ºçš„æ•°å­¦æ¨¡å‹å¯¹è±¡å­˜å…¥å˜é‡LPModelä¸­ï¼Œä½œç”¨åŒæœ¬æ–‡çš„lp`},{header:"å†™å…¥æ•°å­¦æ¨¡å‹",slug:"å†™å…¥æ•°å­¦æ¨¡å‹",content:`æ­¤æ—¶ï¼Œæ•°å­¦æ¨¡å‹çš„å¯¹è±¡å·²ç»åˆ›å»ºå¹¶å­˜å…¥äº†å˜é‡lpä¸­ï¼Œå¯ä»¥å¯¹å…¶è¿›è¡Œæ›´è¿›ä¸€æ­¥çš„æ“ä½œã€‚æ•°å­¦æ¨¡å‹ä¸€èˆ¬åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š ç›®æ ‡å‡½æ•°
çº¦æŸæ–¹ç¨‹ æ¥ä¸‹æ¥ï¼Œå…ˆä»‹ç»åˆ›å»ºç›®æ ‡å‡½æ•°çš„å…·ä½“åšæ³•ã€‚`},{header:"åˆ›å»ºç›®æ ‡å‡½æ•°",slug:"åˆ›å»ºç›®æ ‡å‡½æ•°",content:`MicroCityä¸­ï¼Œä½¿ç”¨SetObjectFunction()è®¾ç½®æ¨¡å‹å¯¹è±¡çš„ç›®æ ‡å‡½æ•°ã€‚å…è®¸é€‰æ‹©ç›®æ ‡å‡½æ•°æ±‚æœ€å¤§å€¼æˆ–æœ€å°å€¼ã€‚å…·ä½“ç”¨æ³•å¦‚ä¸‹ï¼š æœ€å¤§å€¼
æœ€å°å€¼ SetObjFunction(lp, coeff, "max") --æ±‚æœ€å¤§å€¼ SetObjFunction(lp, coeff, "min") --æ±‚æœ€å°å€¼ "min"å’Œ"max"ä¸åŒºåˆ†å¤§å°å†™ï¼Œå†™"MIN"å’Œ"MAX"ä¹Ÿå¯ä»¥`},{header:"å‚æ•°è¯´æ˜åŠç¤ºä¾‹",slug:"å‚æ•°è¯´æ˜åŠç¤ºä¾‹",content:`å‚æ•°
ä½œç”¨ lp
æ•°å­¦æ¨¡å‹å¯¹è±¡ã€‚å°†æ•°å­¦æ¨¡å‹è¾“å…¥å‡½æ•°ä¸­ï¼Œä¸ºæ¨¡å‹è®¾ç½®ç›®æ ‡å‡½æ•° coeff
ç›®æ ‡å‡½æ•°ç³»æ•°ï¼Œæ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡ã€‚ç”¨äºç¡®å®šæ¨¡å‹ä¸­ç›®æ ‡å‡½æ•°çš„ç³»æ•°ã€‚ "min"æˆ–"max"
ç¡®å®šç›®æ ‡å‡½æ•°æ±‚æœ€å¤§è¿˜æ˜¯æ±‚æœ€å°ã€‚ coeffæ˜¯ç›®æ ‡å‡½æ•°çš„ç³»æ•°åˆ—è¡¨ï¼Œæ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡ã€‚å‡è®¾ä½ è¦æ±‚å‡½æ•°4x1+12x2+18x34x_1+12x_2+18x_34x1â€‹+12x2â€‹+18x3â€‹çš„æœ€å°å€¼ï¼Œåˆ™æ·»åŠ ç›®æ ‡å‡½æ•°çš„åšæ³•å¦‚ä¸‹ï¼š
-- å‡è®¾ä½ å·²ç»åˆ›å»ºäº†æ¨¡å‹å¯¹è±¡ï¼Œå¹¶å­˜å…¥å˜é‡lpä¸­ -- 4*x1 + 12*x2 + 18*x3
local coeff = {4, 12, 18} -- è®¾ç½®ç›®æ ‡å‡½æ•°ï¼šæ±‚æœ€å°
SetObjFunction(lp, coeff, "min")`},{header:"æ·»åŠ çº¦æŸæ–¹ç¨‹",slug:"æ·»åŠ çº¦æŸæ–¹ç¨‹",content:`åœ¨MicroCityä¸­ï¼Œæ·»åŠ æ¨¡å‹çº¦æŸçš„å‡½æ•°ä¸ºAddConstraint()ï¼Œç”¨æ³•å¦‚ä¸‹ï¼š â‰¤
â‰¥
= -- ä½¿ç”¨ç¬¦å·è¡¨è¾¾
AddConstraint(lp, cons, "<=", b) -- æˆ–è€…å¯ä»¥ä½¿ç”¨ç¼©å†™è¡¨è¾¾
AddConstraint(lp, cons, "le", b) -- ä½¿ç”¨ç¬¦å·è¡¨è¾¾
AddConstraint(lp, cons, ">=", b) -- æˆ–è€…å¯ä»¥ä½¿ç”¨ç¼©å†™è¡¨è¾¾
AddConstraint(lp, cons, "ge", b) -- ä½¿ç”¨ç¬¦å·è¡¨è¾¾
AddConstraint(lp, cons, "==", b) -- æˆ–è€…å¯ä»¥ä½¿ç”¨ç¼©å†™è¡¨è¾¾
AddConstraint(lp, cons, "eq", b)`},{header:"å‚æ•°è¯´æ˜",slug:"å‚æ•°è¯´æ˜",content:`å‚æ•°
ä½œç”¨ lp
æ•°å­¦æ¨¡å‹å¯¹è±¡ã€‚å°†æ•°å­¦æ¨¡å‹è¾“å…¥å‡½æ•°ä¸­ï¼Œä¸ºæ¨¡å‹æ·»åŠ çº¦æŸ cons
çº¦æŸæ–¹ç¨‹ç³»æ•°ã€‚å’Œè®¾ç½®ç›®æ ‡å‡½æ•°ä¸­çš„consä¸€æ ·ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡ã€‚ç”¨äºç¡®å®šçº¦æŸæ–¹ç¨‹ä¸­å„ä¸ªå˜é‡çš„ç³»æ•°ã€‚ "<=" æˆ– ">=" æˆ– "=="ï¼Œæˆ–å…¶å¯¹åº”çš„å­—æ¯è¡¨è¾¾
ç¡®å®šçº¦æŸæ–¹ç¨‹ä¸å³ç«¯é¡¹çš„å…³ç³» b
ä¸€ä¸ªæ•°å­—ï¼Œè¡¨ç¤ºçº¦æŸæ–¹ç¨‹çš„å³ç«¯é¡¹ã€‚å¯ä»¥æ˜¯å˜é‡ä¹Ÿå¯ä»¥æ˜¯å¸¸é‡`},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹",content:`ä¸Šé¢å·²ç»è®¾ç½®äº†ç›®æ ‡å‡½æ•°ä¸º4x1+12x2+18x34x_1+12x_2+18x_34x1â€‹+12x2â€‹+18x3â€‹ï¼Œå‡è®¾ä½ è¦ä¸ºè¿™ä¸ªå‡½æ•°æ·»åŠ ä¸¤ä¸ªçº¦æŸæ–¹ç¨‹ï¼š
{x1+3x3â‰¥32x2+2x3â‰¥5
\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\end{matrix}\\right. {x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5â€‹
æ·»åŠ å¯¹åº”çº¦æŸæ–¹ç¨‹ï¼š
-- æ·»åŠ çº¦æŸï¼šx1+3*x3â‰¥3
cons = { 1, 0, 3 }
AddConstraint(lp, cons, ">=", 3) -- æ·»åŠ çº¦æŸï¼š2*x2+2*x3â‰¥5
cons = { 0, 2, 2 }
AddConstraint(lp, cons, ">=", 5)
ä¸éš¾æ³¨æ„åˆ°ï¼Œç³»æ•°çš„ä¸ªæ•°å’Œç›®æ ‡å‡½æ•°ä¸­å˜é‡çš„ä¸ªæ•°ä¸€è‡´ã€‚å› æ­¤ï¼Œåœ¨ç¼–ç¨‹æ±‚è§£ä¹‹å‰é¦–å…ˆè¦ææ¸…æ¥šå˜é‡çš„æ€»æ•°ï¼Œå¹¶å®‰æ’å¥½å„ä¸ªå˜é‡çš„ä½ç½®ã€‚`},{header:"è®¾ç½®å˜é‡ç±»å‹",slug:"è®¾ç½®å˜é‡ç±»å‹",content:`MicroCityä¸­çš„æ•°å­¦è§„åˆ’æ”¯æŒæ•´æ•°è§„åˆ’ã€‚å¦‚æœæ²¡æœ‰å¯¹å˜é‡è®¾ç½®SetUnbounded()ï¼Œé»˜è®¤å˜é‡çš„å–å€¼èŒƒå›´æ˜¯éè´Ÿå®æ•°(â‰¥0)ã€‚ä¸‹é¢ä»‹ç»å˜é‡ç±»å‹è®¾ç½®çš„è¯¦ç»†åšæ³•ã€‚
ä½ å¯ä»¥å°†æ¨¡å‹ä¸­ç¬¬iä¸ªå˜é‡è®¾ç½®ä¸ºæ•´æ•°å˜é‡æˆ–0-1å˜é‡ã€‚å¦‚æœä¸å°†å˜é‡è®¾ç½®ä¸ºè¿™äº›ç±»å‹ï¼Œåˆ™é»˜è®¤å˜é‡ä¸ºéè´Ÿå®æ•°ã€‚ æ•´æ•°å˜é‡
0-1å˜é‡ SetInteger(lp, i) --æ•´æ•°å˜é‡ SetBinary(lp, i) --0-1å˜é‡ è®©ç¬¬iä¸ªå˜é‡çš„å€¼å¯ä»¥æ˜¯è´Ÿæ•°ï¼ˆé»˜è®¤å–ä¸åˆ°è´Ÿæ•°ï¼‰ï¼š
SetUnbounded(lp, i)`},{header:"æ¨¡å‹æ±‚è§£å’Œè¾“å‡º",slug:"æ¨¡å‹æ±‚è§£å’Œè¾“å‡º",content:""},{header:"æ¨¡å‹æ±‚è§£",slug:"æ¨¡å‹æ±‚è§£-1",content:`ç”±äºç›®æ ‡å‡½æ•°å’Œçº¦æŸæ–¹ç¨‹éƒ½å·²ç»æ·»åŠ å®Œæ¯•ï¼Œå› æ­¤æ¨¡å‹çš„æ±‚è§£å°±å¾ˆç®€å•äº†ï¼Œåªéœ€è¦ä¸€æ­¥ï¼š
SolveLP(lp)
æ‰§è¡Œå®Œè¿™æ¡è¯­å¥åï¼Œå­˜æ”¾äºå˜é‡lpå†…çš„æ•°å­¦æ¨¡å‹å°±æ±‚è§£å®Œæ¯•äº†ğŸ‰`},{header:"è¾“å‡º",slug:"è¾“å‡º",content:`æ±‚è§£å®Œè¿˜éœ€è¦è¾“å‡ºï¼Œå¦åˆ™å°±ä¸çŸ¥é“æ±‚è§£çš„ç»“æœå¦‚ä½•ã€‚ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„è¾“å‡ºæ±‚è§£ç»“æœçš„å‡½æ•°ã€‚
è·å–ç›®æ ‡å‡½æ•°å€¼ï¼š
GetObjective(lp)
è·å–ç¬¬iä¸ªå˜é‡çš„å€¼ï¼š
GetVariable(lp, i)`},{header:"SolveLP",slug:"solvelp",content:`SolveLP()å‡½æ•°åœ¨æ±‚è§£å®Œæ¯•åä¹Ÿæœ‰è¾“å‡ºï¼Œè¾“å‡ºä»£ç çš„å«ä¹‰å¦‚ä¸‹ï¼š è¾“å‡ºä»£ç 
å«ä¹‰ 0
æˆåŠŸ -1
æ— æ•ˆçš„LPæ¨¡å‹ -2
æ— å†…å­˜ 1
æ¬¡ä¼˜ 2
æ— å¯è¡Œè§£ 3
æ— ç•Œè§£ 4
é€€åŒ– 5
é‡åˆ°æ•°å€¼é”™è¯¯ 6
ç”¨æˆ·ç»ˆæ­¢äº†æ±‚è§£ 7
è¶…æ—¶é”™è¯¯ å…¶ä»–è¿”å›å€¼è¡¨ç¤ºçš„å«ä¹‰è¯·å‚é˜…æ–‡æ¡£ 4.8æ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ ä¸­çš„SolveLP()å‡½æ•°ã€‚`},{header:"æ¨¡å‹æ±‚è§£ç¤ºä¾‹",slug:"æ¨¡å‹æ±‚è§£ç¤ºä¾‹",content:`è¿™é‡Œæä¾›ä¸€ä¸ªç®€å•çš„ä»å»ºæ¨¡è‡³æ±‚è§£çš„ç¤ºä¾‹ä¾›å‚è€ƒã€‚ï¼ˆå…¶å®å°±æ˜¯å°†å‰é¢çš„æ‹¼èµ·æ¥ï¼‰
ç®—ä¾‹ï¼š
minf=4x1+12x2+18x3s.t.{x1+3x3â‰¥32x2+2x3â‰¥5x1,x2,x3âˆˆN
minf=4x_1+12x_2+18x_3\\\\
s.t.\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\\\ x_1,x_2,x_3\\in N
\\end{matrix}\\right. minf=4x1â€‹+12x2â€‹+18x3â€‹s.t.â©â¨â§â€‹x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5x1â€‹,x2â€‹,x3â€‹âˆˆNâ€‹ Nè¡¨ç¤ºè‡ªç„¶æ•°ï¼ˆéè´Ÿæ•´æ•°é›†åˆï¼‰ è„šæœ¬
-- åˆ›å»ºçº¿æ€§è§„åˆ’å¯¹è±¡
local lp = CreateLP() local n = 3 --è®¾ç½®ç›®æ ‡å‡½æ•°ä¸ªæ•° -- ç›®æ ‡å‡½æ•°ï¼š4*x1 + 12*x2 + 18*x3
-- è®¾ç½®ç›®æ ‡å‡½æ•°ç³»æ•°ï¼Œç›®æ ‡å‡½æ•°æ±‚æœ€å°
local coeff = { 4, 12, 18 }
SetObjFunction(lp, coeff, "min") -- æ·»åŠ çº¦æŸ1ï¼šx1 + 3*x3 â‰¥ 3
cons = { 1, 0, 3 }
AddConstraint(lp, cons, ">=", 3) -- æ·»åŠ çº¦æŸ2ï¼š2*x2 + 2*x3 â‰¥ 5
cons = { 0, 2, 2 }
AddConstraint(lp, cons, ">=", 5) -- ç”±äºæ²¡æœ‰è®¾ç½®SetUnbounded()ï¼Œ
-- é»˜è®¤æ‰€æœ‰å˜é‡å–å€¼éè´Ÿï¼Œ
-- å› æ­¤ä¸ç”¨é’ˆå¯¹å˜é‡éè´Ÿæ·»åŠ çº¦æŸã€‚ -- è®¾ç½®æ‰€æœ‰å˜é‡ä¸ºæ•´æ•°
for i = 1, n do SetInteger(lp, i)
end -- æ±‚è§£æ¨¡å‹
SolveLP(lp) -- è¾“å‡ºç›®æ ‡å‡½æ•°å€¼
print("ç›®æ ‡å‡½æ•°å€¼ï¼š",GetObjective(lp)) -- è¾“å‡ºå„ä¸ªå˜é‡çš„å€¼
for i = 1, n do print("x",i,"=",GetVariable(lp, i))
end
è¾“å‡ºç»“æœ
ç›®æ ‡å‡½æ•°å€¼ï¼š42
x1=0
x2=2
x3=1`},{header:"å»ºæ¨¡çš„ä¸€äº›æŠ€å·§",slug:"å»ºæ¨¡çš„ä¸€äº›æŠ€å·§",content:""},{header:"çº¿æ€§åŒ–",slug:"çº¿æ€§åŒ–",content:`æœ‰æ—¶å€™æˆ‘ä»¬ä¼šé‡åˆ°å¤šä¸‹æ ‡çš„å»ºæ¨¡é—®é¢˜ï¼Œå¦‚å†³ç­–å˜é‡ä¸ºxijx_{ij}xijâ€‹ï¼Œè¿™ä¸ªæ—¶å€™å°±è¦å°†å…¶è¿›è¡Œçº¿æ€§åŒ–ç¼–ç ã€‚
å‡è®¾å†³ç­–å˜é‡æœ¬èº«çš„å½¢çŠ¶å…±æœ‰3è¡Œ4åˆ—ï¼Œå³ï¼š åˆ—1
åˆ—2
åˆ—3
åˆ—4 x11x_{11}x11â€‹
x12x_{12}x12â€‹
x13x_{13}x13â€‹
x14x_{14}x14â€‹ x21x_{21}x21â€‹
x22x_{22}x22â€‹
x23x_{23}x23â€‹
x24x_{24}x24â€‹ x31x_{31}x31â€‹
x32x_{32}x32â€‹
x33x_{33}x33â€‹
x34x_{34}x34â€‹ å‡è®¾ç›®æ ‡å‡½æ•°è¦å°†è¿™äº›å†³ç­–å˜é‡æ±‚å’Œï¼Œå³ F=âˆ‘i=13âˆ‘j=14xijF=\\sum_{i=1}^3\\sum_{j=1}^4x_{ij}F=âˆ‘i=13â€‹âˆ‘j=14â€‹xijâ€‹ å¦‚æœè¦å°†å…¶è¾“å…¥ç›®æ ‡å‡½æ•°ï¼Œæ­¤æ—¶å¯ä»¥å°†å…¶çº¿æ€§åŒ–ä¸º x11+x12+...+x14+x21+...+x24+x31+...+x34x_{11}+x_{12}+...+x_{14}+x_{21}+...+x_{24}+x_{31}+...+x_{34}x11â€‹+x12â€‹+...+x14â€‹+x21â€‹+...+x24â€‹+x31â€‹+...+x34â€‹
ç”±äºåªæœ‰ä¸¤ä¸ªç»´åº¦ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªforå®ç°ï¼š
local cons = {}
for i = 1, 3 do -- ç¬¬ä¸€ç»´ for j = 1, 4 do -- ç¬¬äºŒç»´ cons[4 * (i - 1) + j] = 1 -- å¡«å…¥ç³»æ•° -- å…¶ä¸­ 4 * (i - 1) + j çš„æ€æƒ³ç±»ä¼¼äºè¿›ä½ end
end --ç»“æœï¼š
-- consé•¿åº¦ä¸º12ï¼Œå€¼éƒ½ä¸º1`},{header:"ä¾‹é¢˜ï¼šæŒ‡æ´¾æ¨¡å‹",slug:"ä¾‹é¢˜-æŒ‡æ´¾æ¨¡å‹",content:`ä¸‹é¢ä»¥ä¸€ä¸ªå®é™…çš„ä¾‹é¢˜æ¥çœ‹çœ‹å¤šç»´çº¿æ€§åŒ–çš„å…·ä½“ä½¿ç”¨æ–¹æ³•åŠå…¶æ–¹ä¾¿ä¹‹å¤„ã€‚
ç”²ã€ä¹™ã€ä¸™ã€ä¸å››äººé…é€Aï¼ŒBï¼ŒCï¼ŒDå››ç§è´§ç‰©ï¼Œæ‰€éœ€æ—¶é—´å¦‚è¡¨æ‰€ç¤ºã€‚è‹¥ä¸€ç§è´§ç‰©åªäº¤ä¸€äººé€è´§ï¼Œåˆ™åº”æŒ‡æ´¾ä½•äººé…é€ä½•ç§è´§ç‰©ï¼Œèƒ½ä½¿æ€»çš„æ—¶é—´æœ€å°‘ï¼Ÿ äºº\\å·¥ä»¶
A
B
C
D ç”²
14
9
4
15 ä¹™
11
7
9
10 ä¸™
13
2
10
5 ä¸
17
9
15
13 å‡è®¾è´§ç‰©Aã€Bã€Cã€Då¯¹åº”çš„ç¼–å·ä¾æ¬¡ä¸º1ã€2ã€3ã€4ï¼Œè®¾ xij=1x_{ij}=1xijâ€‹=1 æ—¶è¡¨ç¤ºç¬¬iä¸ªäººé€jè´§ï¼Œxij=0x_{ij}=0xijâ€‹=0 æ—¶è¡¨ç¤ºç¬¬iä¸ªäººä¸é€jè´§ã€‚
åˆ™ä¸Šè¿°é—®é¢˜çš„æ•°å­¦æ¨¡å‹å¯ä»¥è¡¨ç¤ºä¸º
minZ=âˆ‘i=14âˆ‘j=14cijxijs.t.{âˆ‘j=14xij=1,i=1,2,...,4âˆ‘i=14xij=1,j=1,2,...,4xij=0,1
minZ=\\sum_{i=1}^4\\sum_{j=1}^4c_{ij}x_{ij}\\\\
s.t.\\left\\{\\begin{matrix} \\sum_{j=1}^4x_{ij}=1, i=1,2,...,4 \\\\ \\sum_{i=1}^4x_{ij}=1, j=1,2,...,4 \\\\ x_{ij}=0,1
\\end{matrix}\\right. minZ=i=1âˆ‘4â€‹j=1âˆ‘4â€‹cijâ€‹xijâ€‹s.t.â©â¨â§â€‹âˆ‘j=14â€‹xijâ€‹=1,i=1,2,...,4âˆ‘i=14â€‹xijâ€‹=1,j=1,2,...,4xijâ€‹=0,1â€‹
æ±‚è§£ä»£ç 
-- æ•ˆç‡çŸ©é˜µ
local cost = { { 14, 9, 4, 15 }, { 11, 7, 9, 10 }, { 13, 2, 10, 5 }, { 17, 9, 15, 13 }
} local lp = CreateLP() -- åˆ›å»ºç›®æ ‡å‡½æ•°
local coeff = {}
for i = 1, 4 do for j = 1, 4 do -- æ­¤å¤„å¯ä»¥è½»æ¾å°†äºŒç»´æ•°ç»„è½¬æ¢ä¸ºä¸€ç»´æ•°ç»„ coeff[4 * (i - 1) + j] = cost[i][j] end
end SetObjFunction(lp, coeff, "min") --æ·»åŠ çº¦æŸ
for k = 1, 4 do -- ç¬¬iç»´çš„å€¼æ§åˆ¶ local cons = {} for i = 1, 4 do for j = 1, 4 do if i == k then -- jæ±‚å’Œï¼Œåˆ¤æ–­i cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end AddConstraint(lp, cons, "==", 1)
end for k = 1, 4 do -- ç¬¬jç»´çš„å€¼æ§åˆ¶ local cons = {} for i = 1, 4 do for j = 1, 4 do if j == k then --iæ±‚å’Œï¼Œåˆ¤æ–­j cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end AddConstraint(lp, cons, "==", 1)
end -- æ±‚è§£æ¨¡å‹
SolveLP(lp) -- è¾“å‡ºç›®æ ‡å‡½æ•°å€¼
print("ç›®æ ‡å‡½æ•°å€¼ï¼š",GetObjective(lp)) -- è¾“å‡ºå†³ç­–å˜é‡
for i = 1, 4 do -- ç¬¬ä¸€ç»´ for j = 1, 4 do -- ç¬¬äºŒç»´ local x = GetVariable(lp, 4 * (i - 1) + j) if x~=0 then print("x[", i, "][", j, "]=", x) end end
end
è¾“å‡º
ç›®æ ‡å‡½æ•°å€¼ï¼š29
x[1][3]=1
x[2][1]=1
x[3][4]=1
x[4][2]=1 ç»“æœ
äºº
é…é€å·¥ä»¶ x13=1x_{13}=1x13â€‹=1
ç”²
C x21=1x_{21}=1x21â€‹=1
ä¹™
A x34=1x_{34}=1x34â€‹=1
ä¸™
D x42=1x_{42}=1x42â€‹=1
ä¸
B`},{header:"ä¸­é—´å˜é‡çš„å¤„ç†",slug:"ä¸­é—´å˜é‡çš„å¤„ç†",content:`æœ‰æ—¶å€™æ¨¡å‹ä¸­ä¼šå­˜åœ¨ä¸€äº›ä¸­é—´å˜é‡ï¼Œè¿™äº›å˜é‡å¿…é¡»è¦åœ¨çŸ©é˜µä¸­æœ‰å¯¹åº”çš„ä½ç½®æ‰èƒ½å¯¹å…¶è¿›è¡Œæ±‚è§£ï¼Œè€Œè¿™äº›ä¸­é—´å˜é‡ä¸å‚ä¸ç›®æ ‡å‡½æ•°å€¼çš„è¿ç®—ã€‚å¯ä»¥å°†ä¸­é—´å˜é‡å¯¹åº”ä½ç½®çš„ç³»æ•°è®¾ä¸º0ã€‚
å‡è®¾x1,x2,x3,x4x_1,x_2,x_3,x_4x1â€‹,x2â€‹,x3â€‹,x4â€‹ä¸ºå†³ç­–å˜é‡ï¼Œy1,y2y_1,y_2y1â€‹,y2â€‹ä¸ºä¸­é—´å˜é‡ã€‚ç›®æ ‡å‡½æ•°ä¸º:
z=âˆ‘i=14xi
z=\\sum_{i=1}^4x_i
z=i=1âˆ‘4â€‹xiâ€‹
åˆ™ç›®æ ‡å‡½æ•°ç³»æ•°å¯ä»¥è®¾ä¸ºï¼š
local fcons = {1, 1, 1, 1, 0, 0}
æ¥ä¸‹æ¥æŒ‰ç…§ä¸€èˆ¬æµç¨‹åšå°±å¯ä»¥å•¦ğŸ˜`}]},{path:"/notes/lua.html",title:"Luaè¯­è¨€å¿«é€Ÿä¸Šæ‰‹",pathLocale:"/",contents:[{header:"Luaè¯­è¨€å¿«é€Ÿä¸Šæ‰‹",slug:"luaè¯­è¨€å¿«é€Ÿä¸Šæ‰‹",content:"ç”±äºMicroCityé‡‡ç”¨çš„è„šæœ¬è¯­è¨€æ˜¯Luaï¼Œå› æ­¤åœ¨å¼€å§‹ä½¿ç”¨MicroCityç¼–å†™è„šæœ¬ä¹‹å‰éœ€è¦å…ˆç†Ÿæ‚‰Luaçš„åŸºæœ¬ç”¨æ³•ã€‚æœ¬æ–‡ä»‹ç»äº†MicroCityç¼–å†™Luaè„šæœ¬çš„å¸¸ç”¨çš„è¯­æ³•ï¼Œèƒ½å¤Ÿå¸®åŠ©ä½ å¿«é€Ÿåœ°æ ¹æ®å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­çš„æ¦‚å¿µç†è§£MicroCityè„šæœ¬ç¼–å†™çš„æ€»ä½“æ€è·¯ã€‚"},{header:"å˜é‡å’Œå‡½æ•°å®šä¹‰",slug:"å˜é‡å’Œå‡½æ•°å®šä¹‰",content:`luaä¼šè‡ªåŠ¨è¯†åˆ«å˜é‡ç±»å‹ï¼Œå› æ­¤æ— éœ€åœ¨å˜é‡åç§°å‰å®šä¹‰å˜é‡ç±»å‹ï¼Œç›´æ¥èµ‹å€¼å³å¯ã€‚
a = 1.5
b = "string"
c = {} -- cä¸ºè¡¨ï¼Œè§ä¸‹æ–‡ä»‹ç»
å‡½æ•°çš„å®šä¹‰
function add(a, b) return a + b
end
ä¸Šæ–¹ç®€å•å®šä¹‰äº†ä¸€ä¸ªadd()å‡½æ•°ï¼Œç›®çš„æ˜¯æŠŠè¾“å…¥çš„ä¸¤ä¸ªå˜é‡ç›¸åŠ è¿”å›ç»“æœã€‚
å˜é‡åˆ†ä¸ºå…¨å±€å˜é‡å’Œå±€éƒ¨å˜é‡ï¼Œå‡½æ•°ä¹Ÿæ˜¯å¦‚æ­¤ã€‚å±€éƒ¨å˜é‡å’Œå‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ã€‚
-- å®šä¹‰å±€éƒ¨å‡½æ•°
local function show(msg) print(msg)
end -- å®šä¹‰å±€éƒ¨å˜é‡
local a = 1
å¦‚æœå±€éƒ¨å®šä¹‰çš„å†…å®¹ï¼ˆå‡½æ•°æˆ–å˜é‡ï¼‰å’Œå…¨å±€å®šä¹‰çš„å†…å®¹æœ‰å†²çªï¼Œä»¥å±€éƒ¨çš„å†…å®¹ä¼˜å…ˆã€‚å­˜åœ¨è¿™ç§å†²çªæ—¶ï¼Œä½ æ“ä½œçš„å†…å®¹æ˜¯å±€éƒ¨çš„å†…å®¹ã€‚
å¦‚æœæ²¡æœ‰æ˜ç¡®éœ€è¦æ“ä½œå…¨å±€å˜é‡ï¼Œå»ºè®®å°½é‡å°†å˜é‡å®šä¹‰ä¸ºå±€éƒ¨å˜é‡ã€‚è¿™ç§åšæ³•å¯èƒ½ä¼šå‡å°‘bugçš„å‡ºç°ï¼Œä¹Ÿæ˜¯æ›´åŠ å®‰å…¨çš„åšæ³•ã€‚`},{header:"æ¡ä»¶",slug:"æ¡ä»¶",content:`å°±æ˜¯ifï¼Œå…·ä½“å®ç°å½¢å¼æœ‰å¦‚ä¸‹å‡ ç§ï¼š æ™®é€šå½¢å¼ if condition then print("condition==true")
end å¸¦elseçš„å½¢å¼ if condition then print("condition==true")
else print("condition==false")
end ä»¥åŠä½¿ç”¨elseifçš„å½¢å¼ if number > 0 then print("number>0")
elseif number < 0 then print("number<0")
else print("number==0")
end
Luaä¸­ç›¸ç­‰åˆ¤æ–­çš„è¿ç®—ç¬¦ä¸º==ï¼Œä¸ç­‰åˆ¤æ–­çš„è¿ç®—ç¬¦ä¸º~=ã€‚æ‚¨å¯ä»¥å°†è¿ç®—ç¬¦è¿ç”¨äºæ¡ä»¶è¡¨è¾¾å¼ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¸¾ä¾‹ï¼š
print(1==1) -- true
print(1~=1) -- false`},{header:"å¾ªç¯",slug:"å¾ªç¯",content:"è®°å½•ä¸€ä¸‹æœ€å¸¸ç”¨çš„ä¸¤ç§å¾ªç¯: for&while"},{header:"for",slug:"for",content:`æœ€æ™®é€šçš„å½¢å¼
-- è¾“å‡º1åˆ°10å…±10ä¸ªæ•°
for i = 1:10 do print(i)
end
å¦‚æœä½ æ¯”è¾ƒç†Ÿæ‚‰Cè¯­è¨€æˆ–Cç±»è¯­è¨€ï¼Œä»¥ä¸Šä»£ç å¯¹åº”çš„å½¢å¼å¦‚ä¸‹
for(int i=1; i<=10; i++){ printf("%d\\n",i);
}
è€ƒè™‘æ­¥é•¿
-- è¾“å‡º10åˆ°1å…±10ä¸ªæ•°ï¼Œæ­¥é•¿ä¸º-1
for i = 10:1:-1 do print(i)
end æ­¥é•¿ä¸ºè´Ÿæ•°æ—¶ï¼Œéœ€è¦æ³¨æ„å¼€å§‹å’Œç»“æŸçš„æ•°å­—ä¹Ÿåº”è¯¥ä¸ºå€’åº æ³›å‹å¾ªç¯
å¯ä»¥ç›´æ¥éå†ä¸€ä¸ªè¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚
iä¸ºè¡¨å…ƒç´ çš„ä¸‹æ ‡ï¼Œä»1å¼€å§‹ï¼›vä¸ºè¡¨å…ƒç´ çš„å€¼ã€‚
a = {4,7,9}
for i,v in ipairs(a) do print("index=",i,"\\tvalue=",v)
end ipairsé€‚ç”¨äºæ•°ç»„ï¼ˆiä¼°è®¡æ˜¯integerçš„æ„æ€ï¼‰ï¼Œpairsé€‚ç”¨äºå¯¹è±¡ï¼Œå› ä¸ºæ•°ç»„ä¹Ÿæ˜¯å¯¹è±¡ï¼Œæ‰€ä»¥pairsç”¨äºæ•°ç»„ä¹Ÿæ²¡é—®é¢˜ã€‚`},{header:"while",slug:"while",content:`whileçš„å¸¸ç”¨æ–¹æ³•å°±ä¸€ä¸ª
local condition = true
while condition do print("while==true") condition = false
end
å’ŒCç±»è¯­è¨€ä¸€æ ·ã€‚åªè¦conditionä¸ºtrueçš„æ—¶å€™whileå°±ä¼šä¸€ç›´æ‰§è¡Œã€‚å½“conditionè¢«è®¾ç½®ä¸ºfalseçš„æ—¶å€™ï¼Œwhileå°±ä¼šç»“æŸè¿è¡Œã€‚`},{header:"å¾ªç¯æ“ä½œç¬¦",slug:"å¾ªç¯æ“ä½œç¬¦",content:`åŒå…¶ä»–è¯­è¨€çš„è§„å®šä¸€æ ·ï¼Œbreakå…³é”®å­—ç”¨äºè·³å‡ºå¾ªç¯ã€‚
LUAä¸­æ²¡æœ‰continueï¼Œåªæœ‰breakã€‚ä½†æ˜¯å¯ä»¥å¯ä»¥é€šè¿‡ä½¿ç”¨if+breakçš„å½¢å¼å®ç°continueçš„åŠŸèƒ½ã€‚`},{header:"Luaçš„å°ç‰¹æ€§ï¼šè¡¨",slug:"luaçš„å°ç‰¹æ€§-è¡¨",content:`è™½ç„¶Luaé‡Œé¢æŠŠå®ƒè‡ªå·±çš„æ•°ç»„ç§°ä½œtableï¼Œä½†æ˜¯æˆ‘è®¤ä¸ºè¿™ä¸ªæ•°æ®ç»“æ„æ›´ç±»ä¼¼äºPythonçš„é›†åˆæˆ–è€…jsonï¼Œé‡Œé¢å¯ä»¥å­˜å‚¨ä»»ä½•ä¸œè¥¿ï¼Œä¸å—ç»“æ„çº¦æŸã€‚
collection = {{"a", 1, 2}, "abc", {2, 3}}
å¦‚æœéœ€è¦æŸ¥è¯¢æ•°ç»„çš„é•¿åº¦ï¼Œåªéœ€è¦åœ¨æ•°ç»„åå‰é¢æ·»åŠ #å³å¯å¾—åˆ°
list = {1, 2, 3, 4, 5}
for i=1,#list do print(list[i])
end
Luaçš„æ•°ç»„ï¼ˆè¡¨ï¼‰ä¸‹æ ‡ä»1å¼€å§‹ï¼Œä¸åŒäºCç±»è¯­è¨€çš„0ã€‚æ­¤å¤„ä»¥å‰é¢å®šä¹‰çš„collectionä¸ºä¾‹ï¼š
-- collection = {{"a", 1, 2}, "abc", {2, 3}}
print(collection[1][1]) --a
print(collection[2]) --abc
print(collection[3][2]) --3`},{header:"ç´¢å¼•",slug:"ç´¢å¼•",content:`Luaçš„è¡¨çš„ç´¢å¼•éå¸¸çµæ´»ï¼Œå¯ä»¥æ˜¯æ•°å­—ï¼Œä¹Ÿå¯ä»¥æ˜¯å­—ç¬¦ä¸²ï¼Œç”šè‡³æ˜¯å…¶ä»–ç±»å‹çš„æ•°æ®ã€‚
ä¸‹é¢æ˜¯ä¸€äº›ç®€å•çš„ä¾‹å­ï¼š
local list = {} -- ä»¥æ•°å­—ä¸ºç´¢å¼•
list[1] = "a" -- ä»¥å­—ç¬¦ä¸²ä¸ºç´¢å¼•
list["b"] = 2
list.message = "hello world" -- ç­‰ä»·äºlist["message"] = "hello world" print(list[1]) -- a
print(list["b"]) -- 2
print(list.message) -- hello world`},{header:"æ·»åŠ å…ƒç´ ",slug:"æ·»åŠ å…ƒç´ ",content:`å‘æŒ‡å®šä½ç½®æ·»åŠ 
table.insert(table, pos, value) --åœ¨æŒ‡å®šä½ç½®(pos)æ·»åŠ å…ƒç´ 
æˆ–è€…
table.insert(table, value) --å‘æœ€åæ·»åŠ å…ƒç´ 
ç¤ºä¾‹
list = {1, 2, 3, 4, 5}
table.insert(list, 6)
-- {1, 2, 3, 4, 5, 6}`},{header:"åˆ é™¤å…ƒç´ ",slug:"åˆ é™¤å…ƒç´ ",content:`table.remove(table, pos)
ç¤ºä¾‹
list = {1, 2, 3, 4, 5}
table.remove(list, 2)
-- {1, 3, 4, 5}`},{header:"tableçš„æ’åº",slug:"tableçš„æ’åº",content:""},{header:"é»˜è®¤æ’åºæ–¹æ³•",slug:"é»˜è®¤æ’åºæ–¹æ³•",content:`å¯ä»¥ä½¿ç”¨å‡½æ•°å¯¹åˆ—è¡¨è¿›è¡Œæ’åºï¼Œæœ€ç®€å•çš„ç”¨æ³•å¦‚ä¸‹
table.sort(list) -- é»˜è®¤å‡åºæ’åº
æ­¤å¤„æä¾›ä¸€ä¸ªå®éªŒæ¡ˆä¾‹
-- å‡½æ•°ï¼šæ‰“å°åˆ—è¡¨
function PrintList(list) -- è¾“å‡ºåˆ—è¡¨ local listStr = "" for i = 1, #list do listStr = listStr .. list[i] .. " " end print(listStr)
end local list = { 3, 7, 2, 5, 4 } -- åŸå§‹åˆ—è¡¨ PrintList(list) -- è¾“å‡ºåŸå§‹åˆ—è¡¨
table.sort(list) -- å¯¹åˆ—è¡¨è¿›è¡Œæ’åº
PrintList(list) -- è¾“å‡ºæ’åºåçš„åˆ—è¡¨ -- ç»“æœï¼š
-- 3 7 2 5 4 (åŸå§‹åˆ—è¡¨)
-- 2 3 4 5 7 (æ’åºåçš„åˆ—è¡¨)`},{header:"è‡ªå®šä¹‰æ’åºæ–¹æ³•",slug:"è‡ªå®šä¹‰æ’åºæ–¹æ³•",content:`table.sortå‡½æ•°ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰æ’åºè§„åˆ™ï¼Œä½†æ˜¯è¿™ä¸ªè§„åˆ™ä½ éœ€è¦å†™åœ¨å‡½æ•°é‡Œã€‚
table.sort(list, function(a, b))
function(a, b)æ˜¯è‡ªå®šä¹‰çš„æ’åºè§„åˆ™ï¼Œè¦æ±‚æœ€ç»ˆè¿”å›ä¸€ä¸ªboolå€¼(trueæˆ–false)ã€‚aå’Œbåˆ†åˆ«ä¸ºåˆ—è¡¨ä¸­çš„ä»»æ„ä¸¤é¡¹ï¼Œå¦‚æœå‡½æ•°è¿”å›trueï¼Œåˆ™aåœ¨bçš„å‰é¢ï¼Œå¦åˆ™båœ¨açš„å‰é¢ã€‚
ä¸‹é¢æä¾›äº†2ä¸ªç¤ºä¾‹ä¾›å‚è€ƒã€‚`},{header:"ç¤ºä¾‹1ï¼šä¸Šé¢ä»£ç æ”¹ä¸ºé™åºè¾“å‡º",slug:"ç¤ºä¾‹1-ä¸Šé¢ä»£ç æ”¹ä¸ºé™åºè¾“å‡º",content:`-- æ­¤å¤„çœç•¥PrintList()å‡½æ•°ï¼Œå‡½æ•°ä»£ç ä¸ä¸Šæ–¹ç›¸åŒ local list = { 3, 7, 2, 5, 4 } -- åŸå§‹åˆ—è¡¨ PrintList(list) -- è¾“å‡ºåŸå§‹åˆ—è¡¨
table.sort(list, function(a, b) -- å¯¹åˆ—è¡¨è¿›è¡Œæ’åº return a > b -- é™åºæ’åºï¼Œå¦‚æœa>bï¼Œåˆ™aåœ¨bå‰é¢
end)
PrintList(list) -- è¾“å‡ºæ’åºåçš„åˆ—è¡¨ -- ç»“æœï¼š
-- 3 7 2 5 4 (åŸå§‹åˆ—è¡¨)
-- 7 5 4 3 2 (æ’åºåçš„åˆ—è¡¨)`},{header:"ç¤ºä¾‹2ï¼šäºŒç»´æ•°ç»„ä¸­çš„æ’åº",slug:"ç¤ºä¾‹2-äºŒç»´æ•°ç»„ä¸­çš„æ’åº",content:`-- å‡½æ•°ï¼šæ‰“å°åˆ—è¡¨
function PrintList(list) -- è¾“å‡ºåˆ—è¡¨ local listStr = "" for i = 1, #list do listStr = listStr .. "\\n" .. list[i][1] .. ", " .. list[i][2] end print(listStr)
end -- åŸå§‹åˆ—è¡¨
local list = { { 3, 5 }, { 7, 6 }, { 2, 2 }, { 5, 1 }, { 4, 3 } } PrintList(list) -- è¾“å‡ºåŸå§‹åˆ—è¡¨ -- ä»¥åˆ—è¡¨ä¸­æ¯é¡¹çš„ç¬¬1ç»´é™åºæ’åº
table.sort(list, function(a, b) return a[1] > b[1]
end)
PrintList(list) -- è¾“å‡ºæ’åºåçš„åˆ—è¡¨ -- ä»¥åˆ—è¡¨ä¸­æ¯é¡¹çš„ç¬¬2ç»´é™åºæ’åº
table.sort(list, function(a, b) return a[2] > b[2] end)
PrintList(list) -- è¾“å‡ºæ’åºåçš„åˆ—è¡¨ -- ç»“æœï¼š
-- åŸå§‹åˆ—è¡¨ï¼š
-- 3, 5
-- 7, 6
-- 2, 2
-- 5, 1
-- 4, 3 -- ä»¥ç¬¬1ç»´é™åºæ’åºï¼š
-- 7, 6
-- 5, 1
-- 4, 3
-- 3, 5
-- 2, 2 -- ä»¥ç¬¬2ç»´é™åºæ’åºï¼š
-- 7, 6
-- 3, 5
-- 4, 3
-- 2, 2
-- 5, 1`},{header:"tableçš„å¼•ç”¨",slug:"tableçš„å¼•ç”¨",content:`å½“æ²¡æœ‰å¯¹tableè¿›è¡Œå¯¹æ‹·ï¼Œè€Œç›´æ¥å¤åˆ¶çš„æ—¶å€™ï¼Œåˆšåˆšæ–°å¾—åˆ°çš„list2ç›¸å½“äºåŸlist1çš„å¼•ç”¨ï¼Œç§°ä¸ºæµ…æ‹·è´ã€‚å½“ä½ ä¿®æ”¹æµ…æ‹·è´å¾—åˆ°çš„list2ä¸­çš„å…ƒç´ æ—¶ï¼Œç”±äºä¸¤ä¸ªtableæ˜¯å¼•ç”¨çš„å…³ç³»ï¼Œlist1ä¸­çš„å…ƒç´ ä¹Ÿä¼šéšä¹‹æ”¹å˜ã€‚
ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¹Ÿéµå¾ªäº†è¿™ä¸€åŸç†ã€‚ä¸‹é¢å°†ç”¨ä¸€ä¸ªæ–°çš„ä¾‹å­çªå‡ºè¿™ä¸€ç‰¹ç‚¹ã€‚`},{header:"ç¤ºä¾‹ï¼šæµ…æ‹·è´",slug:"ç¤ºä¾‹-æµ…æ‹·è´",content:`function PrintList(list) -- è¾“å‡ºåˆ—è¡¨ local listStr = "" for i = 1, #list do listStr = listStr .. list[i] .. " " end print(listStr)
end list1 = { 1, 2, 3, 4, 5 }
PrintList(list1)
-- 1 2 3 4 5 list2 = list1
PrintList(list2)
-- 1 2 3 4 5 -- ä¿®æ”¹list2çš„ç¬¬2ä¸ªå…ƒç´ 
list2[2] = 10
PrintList(list2)
-- 1 10 3 4 5 PrintList(list1)
-- 1 10 3 4 5`},{header:"ç¤ºä¾‹ï¼šæ·±æ‹·è´",slug:"ç¤ºä¾‹-æ·±æ‹·è´",content:`è€Œå¦‚æœæƒ³è¦å¤åˆ¶ä¸€ä¸ªå…¨æ–°çš„åˆ—è¡¨list2æ€ä¹ˆåŠå‘¢ï¼Ÿé‚£ä¹ˆä½ å°±éœ€è¦å¯¹tableä¸­çš„å…ƒç´ è¿›è¡Œé€ä¸ªå¤åˆ¶ï¼Œä¹Ÿç§°æ·±æ‹·è´ã€‚
-- PrintListå‡½æ•°ä»£ç ä¸ä¸Šæ–¹ç›¸åŒ list1 = { 1, 2, 3, 4, 5 }
PrintList(list1)
-- 1 2 3 4 5 list2 = {} -- æ–°å»ºä¸€ä¸ªç©ºåˆ—è¡¨ -- å°†list1çš„å…ƒç´ å¤åˆ¶åˆ°list2
for index, value in pairs(list1) do table.insert(list2, value)
end
PrintList(list2)
-- 1 2 3 4 5 -- ä¿®æ”¹list2çš„ç¬¬2ä¸ªå…ƒç´ 
list2[2] = 10
PrintList(list2)
-- 1 10 3 4 5 PrintList(list1)
-- 1 2 3 4 5 (æ²¡æœ‰å‘ç”Ÿå˜åŒ–)
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¿®æ”¹æ·±æ‹·è´å¾—åˆ°çš„list2ä¸­çš„å…ƒç´ å¹¶ä¸ä¼šå¯¹åŸæ¥çš„list1äº§ç”Ÿå½±å“ã€‚`}]},{path:"/notes/mip.html",title:"æ··åˆæ•´æ•°è§„åˆ’",pathLocale:"/",contents:[{header:"æ··åˆæ•´æ•°è§„åˆ’",slug:"æ··åˆæ•´æ•°è§„åˆ’",content:"æœ¬æ–‡æ¡£ä»‹ç»MicroCity Webä¸­æ··åˆæ•´æ•°è§„åˆ’çš„å»ºæ¨¡æ–¹æ³•ã€‚"},{header:"åˆ›å»ºæ··åˆæ•´æ•°è§„åˆ’æ¨¡å‹",slug:"åˆ›å»ºæ··åˆæ•´æ•°è§„åˆ’æ¨¡å‹",content:`åˆ›å»ºæ•´æ•°è§„åˆ’æ¨¡å‹å¯¹è±¡
local mip = math.newmip() -- å°†åˆ›å»ºçš„æ¨¡å‹å¯¹è±¡èµ‹å€¼ç»™ mip`},{header:"è®¾ç½®ç›®æ ‡å‡½æ•°",slug:"è®¾ç½®ç›®æ ‡å‡½æ•°",content:`MicroCity Webä¸­ï¼Œæ¨¡å‹çš„ç¬¬ä¸€è¡Œæ˜¯ç›®æ ‡å‡½æ•°ï¼Œä½¿ç”¨mip:addrow()å‡½æ•°æ·»åŠ ã€‚
å…è®¸é€‰æ‹©ç›®æ ‡å‡½æ•°æ±‚æœ€å¤§å€¼æˆ–æœ€å°å€¼ã€‚å…·ä½“ç”¨æ³•å¦‚ä¸‹ï¼š æœ€å¤§å€¼
æœ€å°å€¼ mip:addrow(coeff, 'max') --æ±‚æœ€å¤§å€¼ mip:addrow(coeff, 'min') --æ±‚æœ€å°å€¼`},{header:"å‚æ•°è¯´æ˜åŠç¤ºä¾‹",slug:"å‚æ•°è¯´æ˜åŠç¤ºä¾‹",content:`å‚æ•°
ä½œç”¨ mip
æ•°å­¦æ¨¡å‹å¯¹è±¡ã€‚å°†æ•°å­¦æ¨¡å‹è¾“å…¥å‡½æ•°ä¸­ï¼Œä¸ºæ¨¡å‹è®¾ç½®ç›®æ ‡å‡½æ•° coeff
ç›®æ ‡å‡½æ•°ç³»æ•°ï¼Œæ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡ã€‚ç”¨äºç¡®å®šæ¨¡å‹ä¸­ç›®æ ‡å‡½æ•°çš„ç³»æ•°ã€‚ "min"æˆ–"max"
ç¡®å®šç›®æ ‡å‡½æ•°æ±‚æœ€å¤§è¿˜æ˜¯æ±‚æœ€å°ã€‚ coeffæ˜¯ç›®æ ‡å‡½æ•°çš„ç³»æ•°åˆ—è¡¨ï¼Œæ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡ã€‚å‡è®¾ä½ è¦æ±‚å‡½æ•°
4x1+12x2+18x3
4x_1+12x_2+18x_3
4x1â€‹+12x2â€‹+18x3â€‹
çš„æœ€å°å€¼ï¼Œåˆ™æ·»åŠ ç›®æ ‡å‡½æ•°çš„åšæ³•å¦‚ä¸‹ï¼š
-- å‡è®¾ä½ å·²ç»åˆ›å»ºäº†æ¨¡å‹å¯¹è±¡ï¼Œå¹¶å­˜å…¥å˜é‡mipä¸­
-- è®¾å®šç›®æ ‡å‡½æ•°ä¸º 4*x1 + 12*x2 + 18*x3ï¼Œæ±‚æœ€å°
mip:addrow({4, 12, 18}, "min")`},{header:"æ·»åŠ çº¦æŸ",slug:"æ·»åŠ çº¦æŸ",content:""},{header:"æ·»åŠ çº¦æŸæ–¹ç¨‹",slug:"æ·»åŠ çº¦æŸæ–¹ç¨‹",content:`åœ¨MicroCity Webä¸­ï¼Œä½¿ç”¨mip:addrow()æ·»åŠ å‰©ä¸‹çš„çº¦æŸæ–¹ç¨‹ï¼Œç”¨æ³•å¦‚ä¸‹ï¼š â‰¤
â‰¥
= mip:addrow(cons, "<=", b) mip:addrow(cons, ">=", b) mip:addrow(cons, "==", b)`},{header:"å‚æ•°è¯´æ˜",slug:"å‚æ•°è¯´æ˜",content:`å‚æ•°
ä½œç”¨ mip
ä¸€å¼€å§‹åˆ›å»ºçš„æ•´æ•°è§„åˆ’æ¨¡å‹å¯¹è±¡ cons
çº¦æŸæ–¹ç¨‹ç³»æ•°ã€‚å’Œè®¾ç½®ç›®æ ‡å‡½æ•°ä¸­çš„consä¸€æ ·ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡ã€‚ç”¨äºç¡®å®šçº¦æŸæ–¹ç¨‹ä¸­å„ä¸ªå˜é‡çš„ç³»æ•°ã€‚ "<=" æˆ– ">=" æˆ– "=="
ç¡®å®šçº¦æŸæ–¹ç¨‹ä¸å³ç«¯é¡¹çš„å…³ç³» b
çº¦æŸæ–¹ç¨‹çš„å³ç«¯é¡¹ã€‚`},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹",content:`ä¸Šé¢å·²ç»è®¾ç½®äº†ç›®æ ‡å‡½æ•°ä¸º4x1+12x2+18x34x_1+12x_2+18x_34x1â€‹+12x2â€‹+18x3â€‹ï¼Œå‡è®¾ä½ è¦ä¸ºè¿™ä¸ªå‡½æ•°æ·»åŠ ä¸¤ä¸ªçº¦æŸæ–¹ç¨‹ï¼š
{x1+3x3â‰¥32x2+2x3â‰¥5
\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\end{matrix}\\right. {x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5â€‹
æ·»åŠ å¯¹åº”çº¦æŸæ–¹ç¨‹ï¼š
-- æ·»åŠ çº¦æŸï¼šx1+3*x3â‰¥3
mip:addrow({ 1, 0, 3 }, ">=", 3) -- æ·»åŠ çº¦æŸï¼š2*x2+2*x3â‰¥5
mip:addrow({ 0, 2, 2 }, ">=", 5)
ä¸éš¾æ³¨æ„åˆ°ï¼Œç³»æ•°çš„ä¸ªæ•°å’Œç›®æ ‡å‡½æ•°ä¸­å˜é‡çš„ä¸ªæ•°ä¸€è‡´ã€‚å› æ­¤ï¼Œåœ¨ç¼–ç¨‹æ±‚è§£ä¹‹å‰é¦–å…ˆè¦ææ¸…æ¥šå˜é‡çš„æ€»æ•°ï¼Œå¹¶å®‰æ’å¥½å„ä¸ªå˜é‡çš„ä½ç½®ã€‚`},{header:"è®¾ç½®å˜é‡ç±»å‹",slug:"è®¾ç½®å˜é‡ç±»å‹",content:`MicroCity Web ä¸­çš„æ•°å­¦è§„åˆ’æ”¯æŒæ•´æ•°è§„åˆ’ã€‚é»˜è®¤å˜é‡çš„å–å€¼èŒƒå›´æ˜¯éè´Ÿå®æ•°(â‰¥0)ã€‚ä¸‹é¢ä»‹ç»å˜é‡ç±»å‹è®¾ç½®çš„è¯¦ç»†åšæ³•ã€‚
ä½ å¯ä»¥å°†æ¨¡å‹ä¸­ç¬¬iä¸ªå˜é‡è®¾ç½®ä¸ºæ•´æ•°å˜é‡æˆ–0-1å˜é‡ã€‚å¦‚æœä¸å°†å˜é‡è®¾ç½®ä¸ºè¿™äº›ç±»å‹ï¼Œåˆ™é»˜è®¤å˜é‡ä¸ºéè´Ÿå®æ•°ã€‚ æ•´æ•°å˜é‡
0-1å˜é‡ mip:addrow('c1', 'int') --å°†ç¬¬1ä¸ªå˜é‡ï¼ˆç¬¬ä¸€åˆ—ï¼Œcol 1ï¼‰è®¾ç½®ä¸ºæ•´æ•°å˜é‡(Integer) mip:addrow('c2', 'bin') --å°†ç¬¬2ä¸ªå˜é‡ï¼ˆç¬¬äºŒåˆ—ï¼Œcol 2ï¼‰è®¾ç½®ä¸º0-1å˜é‡(Binary)`},{header:"æ¨¡å‹æ±‚è§£å’Œè¾“å‡º",slug:"æ¨¡å‹æ±‚è§£å’Œè¾“å‡º",content:""},{header:"æ¨¡å‹æ±‚è§£",slug:"æ¨¡å‹æ±‚è§£",content:`ç”±äºç›®æ ‡å‡½æ•°å’Œçº¦æŸæ–¹ç¨‹éƒ½å·²ç»æ·»åŠ å®Œæ¯•ï¼Œå› æ­¤æ¨¡å‹çš„æ±‚è§£å°±å¾ˆç®€å•äº†ï¼Œåªéœ€è¦ä¸€æ­¥ï¼š
mip:solve()
æ‰§è¡Œå®Œè¿™æ¡è¯­å¥åï¼Œå­˜æ”¾äºå˜é‡mipå†…çš„æ•°å­¦æ¨¡å‹å°±æ±‚è§£å®Œæ¯•äº†ğŸ‰`},{header:"è¾“å‡º",slug:"è¾“å‡º",content:`æ±‚è§£å®Œè¿˜éœ€è¦è¾“å‡ºï¼Œå¦åˆ™å°±ä¸çŸ¥é“æ±‚è§£çš„ç»“æœå¦‚ä½•ã€‚ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„è¾“å‡ºæ±‚è§£ç»“æœçš„å‡½æ•°ã€‚
è·å–ç›®æ ‡å‡½æ•°å€¼ï¼š
mip['obj']
è·å–ç¬¬iä¸ªå˜é‡çš„å€¼ï¼š
mip['c'..i]
è¿™é‡Œæä¾›ä¸€ä¸ªç®€å•çš„ä»å»ºæ¨¡è‡³æ±‚è§£çš„ç¤ºä¾‹ä¾›å‚è€ƒã€‚ï¼ˆå…¶å®å°±æ˜¯å°†å‰é¢çš„æ‹¼èµ·æ¥ï¼‰
ç®—ä¾‹ï¼š
minf=4x1+12x2+18x3s.t.{x1+3x3â‰¥32x2+2x3â‰¥5x1,x2,x3âˆˆN
minf=4x_1+12x_2+18x_3\\\\
s.t.\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\\\ x_1,x_2,x_3\\in N
\\end{matrix}\\right. minf=4x1â€‹+12x2â€‹+18x3â€‹s.t.â©â¨â§â€‹x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5x1â€‹,x2â€‹,x3â€‹âˆˆNâ€‹ Nè¡¨ç¤ºè‡ªç„¶æ•°ï¼ˆéè´Ÿæ•´æ•°é›†åˆï¼‰ è„šæœ¬
local mip = math.newmip() -- è®¾ç½®ç›®æ ‡å‡½æ•°
mip:addrow({4, 12, 18}, "min") -- æ·»åŠ çº¦æŸ
mip:addrow({ 1, 0, 3 }, ">=", 3) -- x1+3*x3â‰¥3
mip:addrow({ 0, 2, 2 }, ">=", 5) -- 2*x2+2*x3â‰¥5 -- è®¾ç½®æ‰€æœ‰å˜é‡ä¸ºæ•´æ•°
for i = 1, 3 do mip:addrow('c'..i, 'int')
end -- æ±‚è§£æ¨¡å‹
mip:solve() -- è¾“å‡ºç›®æ ‡å‡½æ•°å€¼
print("ç›®æ ‡å‡½æ•°å€¼:", mip['obj']) -- è¾“å‡ºå„ä¸ªå˜é‡çš„å€¼
for i = 1, 3 do print("x"..i.."=",mip['c'..i])
end
è¾“å‡ºç»“æœ
ç›®æ ‡å‡½æ•°å€¼: 42.0
x1= 0.0
x2= 2.0
x3= 1.0 åœ¨çº¿è¿è¡Œ
åœ¨MicroCity Webä¸­æŸ¥çœ‹è¿™ä¸ªç¤ºä¾‹`},{header:"å»ºæ¨¡çš„ä¸€äº›æŠ€å·§",slug:"å»ºæ¨¡çš„ä¸€äº›æŠ€å·§",content:""},{header:"çº¿æ€§åŒ–",slug:"çº¿æ€§åŒ–",content:`æœ‰æ—¶å€™æˆ‘ä»¬ä¼šé‡åˆ°å¤šä¸‹æ ‡çš„å»ºæ¨¡é—®é¢˜ï¼Œå¦‚å†³ç­–å˜é‡ä¸ºxijx_{ij}xijâ€‹ï¼Œè¿™ä¸ªæ—¶å€™å°±è¦å°†å…¶è¿›è¡Œçº¿æ€§åŒ–ç¼–ç ã€‚
å‡è®¾å†³ç­–å˜é‡æœ¬èº«çš„å½¢çŠ¶å…±æœ‰3è¡Œ4åˆ—ï¼Œå³ï¼š åˆ—1
åˆ—2
åˆ—3
åˆ—4 x11x_{11}x11â€‹
x12x_{12}x12â€‹
x13x_{13}x13â€‹
x14x_{14}x14â€‹ x21x_{21}x21â€‹
x22x_{22}x22â€‹
x23x_{23}x23â€‹
x24x_{24}x24â€‹ x31x_{31}x31â€‹
x32x_{32}x32â€‹
x33x_{33}x33â€‹
x34x_{34}x34â€‹ å‡è®¾ç›®æ ‡å‡½æ•°è¦å°†è¿™äº›å†³ç­–å˜é‡æ±‚å’Œï¼Œå³ F=âˆ‘i=13âˆ‘j=14xijF=\\sum_{i=1}^3\\sum_{j=1}^4x_{ij}F=âˆ‘i=13â€‹âˆ‘j=14â€‹xijâ€‹ å¦‚æœè¦å°†å…¶è¾“å…¥ç›®æ ‡å‡½æ•°ï¼Œæ­¤æ—¶å¯ä»¥å°†å…¶çº¿æ€§åŒ–ä¸º x11+x12+...+x14+x21+...+x24+x31+...+x34x_{11}+x_{12}+...+x_{14}+x_{21}+...+x_{24}+x_{31}+...+x_{34}x11â€‹+x12â€‹+...+x14â€‹+x21â€‹+...+x24â€‹+x31â€‹+...+x34â€‹
ç”±äºåªæœ‰ä¸¤ä¸ªç»´åº¦ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªforå®ç°ï¼š
local cons = {}
for i = 1, 3 do -- ç¬¬ä¸€ç»´ for j = 1, 4 do -- ç¬¬äºŒç»´ cons[4 * (i - 1) + j] = 1 -- å¡«å…¥ç³»æ•° -- å…¶ä¸­ 4 * (i - 1) + j çš„æ€æƒ³ç±»ä¼¼äºè¿›ä½ end
end --ç»“æœï¼š
-- consé•¿åº¦ä¸º12ï¼Œå€¼éƒ½ä¸º1`},{header:"ä¾‹é¢˜ï¼šæŒ‡æ´¾æ¨¡å‹",slug:"ä¾‹é¢˜-æŒ‡æ´¾æ¨¡å‹",content:`ä¸‹é¢ä»¥ä¸€ä¸ªå®é™…çš„ä¾‹é¢˜æ¥çœ‹çœ‹å¤šç»´çº¿æ€§åŒ–çš„å…·ä½“ä½¿ç”¨æ–¹æ³•åŠå…¶æ–¹ä¾¿ä¹‹å¤„ã€‚
ç”²ã€ä¹™ã€ä¸™ã€ä¸å››äººé…é€Aï¼ŒBï¼ŒCï¼ŒDå››ç§è´§ç‰©ï¼Œæ‰€éœ€æ—¶é—´å¦‚è¡¨æ‰€ç¤ºã€‚è‹¥ä¸€ç§è´§ç‰©åªäº¤ä¸€äººé€è´§ï¼Œåˆ™åº”æŒ‡æ´¾ä½•äººé…é€ä½•ç§è´§ç‰©ï¼Œèƒ½ä½¿æ€»çš„æ—¶é—´æœ€å°‘ï¼Ÿ äºº\\å·¥ä»¶
A
B
C
D ç”²
14
9
4
15 ä¹™
11
7
9
10 ä¸™
13
2
10
5 ä¸
17
9
15
13 å‡è®¾è´§ç‰©Aã€Bã€Cã€Då¯¹åº”çš„ç¼–å·ä¾æ¬¡ä¸º1ã€2ã€3ã€4ï¼Œè®¾ xij=1x_{ij}=1xijâ€‹=1 æ—¶è¡¨ç¤ºç¬¬iä¸ªäººé€jè´§ï¼Œxij=0x_{ij}=0xijâ€‹=0 æ—¶è¡¨ç¤ºç¬¬iä¸ªäººä¸é€jè´§ã€‚
åˆ™ä¸Šè¿°é—®é¢˜çš„æ•°å­¦æ¨¡å‹å¯ä»¥è¡¨ç¤ºä¸º
minZ=âˆ‘i=14âˆ‘j=14cijxijs.t.{âˆ‘j=14xij=1,i=1,2,...,4âˆ‘i=14xij=1,j=1,2,...,4xij=0,1
minZ=\\sum_{i=1}^4\\sum_{j=1}^4c_{ij}x_{ij}\\\\
s.t.\\left\\{\\begin{matrix} \\sum_{j=1}^4x_{ij}=1, i=1,2,...,4 \\\\ \\sum_{i=1}^4x_{ij}=1, j=1,2,...,4 \\\\ x_{ij}=0,1
\\end{matrix}\\right. minZ=i=1âˆ‘4â€‹j=1âˆ‘4â€‹cijâ€‹xijâ€‹s.t.â©â¨â§â€‹âˆ‘j=14â€‹xijâ€‹=1,i=1,2,...,4âˆ‘i=14â€‹xijâ€‹=1,j=1,2,...,4xijâ€‹=0,1â€‹
æ±‚è§£ä»£ç 
-- æ•ˆç‡çŸ©é˜µ
local cost = {{14, 9, 4, 15}, {11, 7, 9, 10}, {13, 2, 10, 5}, {17, 9, 15, 13}} local mip = math.newmip() -- åˆ›å»ºç›®æ ‡å‡½æ•°
local coeff = {}
for i = 1, 4 do for j = 1, 4 do -- æ­¤å¤„å¯ä»¥è½»æ¾å°†äºŒç»´æ•°ç»„è½¬æ¢ä¸ºä¸€ç»´æ•°ç»„ coeff[4 * (i - 1) + j] = cost[i][j] end
end mip:addrow(coeff, "min") -- æ·»åŠ çº¦æŸ
for k = 1, 4 do -- ç¬¬iç»´çš„å€¼æ§åˆ¶ local cons = {} for i = 1, 4 do for j = 1, 4 do if i == k then -- jæ±‚å’Œï¼Œåˆ¤æ–­i cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end mip:addrow(cons, "==", 1)
end for k = 1, 4 do -- ç¬¬jç»´çš„å€¼æ§åˆ¶ local cons = {} for i = 1, 4 do for j = 1, 4 do if j == k then -- iæ±‚å’Œï¼Œåˆ¤æ–­j cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end mip:addrow(cons, "==", 1)
end -- æ±‚è§£æ¨¡å‹
mip:solve() -- è¾“å‡ºç›®æ ‡å‡½æ•°å€¼
print("ç›®æ ‡å‡½æ•°å€¼:", mip['obj']) -- è¾“å‡ºå†³ç­–å˜é‡
for i = 1, 4 do -- ç¬¬ä¸€ç»´ for j = 1, 4 do -- ç¬¬äºŒç»´ local x = mip['c' .. 4 * (i - 1) + j] if x ~= 0 then print("x[" .. i .. "][" .. j .. "]=", x) end end
end
è¾“å‡º
ç›®æ ‡å‡½æ•°å€¼: 29.0
x[1][3]= 1.0
x[2][1]= 1.0
x[3][4]= 1.0
x[4][2]= 1.0 åœ¨çº¿è¿è¡Œ
åœ¨MicroCity Webä¸­æŸ¥çœ‹è¿™ä¸ªç¤ºä¾‹ ç»“æœ
äºº
é…é€å·¥ä»¶ x13=1x_{13}=1x13â€‹=1
ç”²
C x21=1x_{21}=1x21â€‹=1
ä¹™
A x34=1x_{34}=1x34â€‹=1
ä¸™
D x42=1x_{42}=1x42â€‹=1
ä¸
B`},{header:"ä¸­é—´å˜é‡çš„å¤„ç†",slug:"ä¸­é—´å˜é‡çš„å¤„ç†",content:`æœ‰æ—¶å€™æ¨¡å‹ä¸­ä¼šå­˜åœ¨ä¸€äº›ä¸­é—´å˜é‡ï¼Œè¿™äº›å˜é‡å¿…é¡»è¦åœ¨çŸ©é˜µä¸­æœ‰å¯¹åº”çš„ä½ç½®æ‰èƒ½å¯¹å…¶è¿›è¡Œæ±‚è§£ï¼Œè€Œè¿™äº›ä¸­é—´å˜é‡ä¸å‚ä¸ç›®æ ‡å‡½æ•°å€¼çš„è¿ç®—ã€‚å¯ä»¥å°†ä¸­é—´å˜é‡å¯¹åº”ä½ç½®çš„ç³»æ•°è®¾ä¸º0ã€‚
å‡è®¾x1,x2,x3,x4x_1,x_2,x_3,x_4x1â€‹,x2â€‹,x3â€‹,x4â€‹ä¸ºå†³ç­–å˜é‡ï¼Œy1,y2y_1,y_2y1â€‹,y2â€‹ä¸ºä¸­é—´å˜é‡ã€‚ç›®æ ‡å‡½æ•°ä¸º:
z=âˆ‘i=14xi
z=\\sum_{i=1}^4x_i
z=i=1âˆ‘4â€‹xiâ€‹
åˆ™ç›®æ ‡å‡½æ•°ç³»æ•°å¯ä»¥è®¾ä¸ºï¼š
local fcons = {1, 1, 1, 1, 0, 0} -- å‰é¢4ä½ä¸ºå†³ç­–å˜é‡ï¼Œåé¢2ä½ä¸ºä¸­é—´å˜é‡
æ¥ä¸‹æ¥æŒ‰ç…§ä¸€èˆ¬æµç¨‹åšå°±å¯ä»¥å•¦ğŸ˜`}]},{path:"/notes/network.html",title:"æ“ä½œç½‘ç»œ",pathLocale:"/",contents:[{header:"æ“ä½œç½‘ç»œ",slug:"æ“ä½œç½‘ç»œ",content:""},{header:"ç½‘ç»œæ‹“è¡¥åŒ–",slug:"ç½‘ç»œæ‹“è¡¥åŒ–",content:`ç½‘ç»œæ‹“è¡¥åŒ–ç®€å•æ¥è¯´å°±æ˜¯ä¸€ä¸ªç½‘ç»œæœ‰èŠ‚ç‚¹ï¼Œæœ‰èŠ‚ç‚¹ä¹‹é—´çš„è¿çº¿ã€‚å¦‚æœæŠŠè¿çº¿ç†è§£ä¸ºé“è·¯ï¼Œé‚£ä¹ˆä½ éœ€è¦è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š è¿™æ¡è·¯æ˜¯å•å‘é€šè¡Œçš„è¿˜æ˜¯åŒå‘é€šè¡Œï¼Ÿ
è¿™æ¡è·¯çš„èµ·ç‚¹æ˜¯å“ªï¼Ÿç»ˆç‚¹æ˜¯å“ªï¼Ÿ ä¸€èˆ¬è®¤ä¸ºä¸€ä¸ªç½‘ç»œå›¾ä¸­ï¼Œæ¯æ¡é“è·¯éƒ½æ˜¯å•å‘çš„ã€‚å¦‚æœéœ€è¦ä¸€æ¡åŒå‘é€šè¡Œçš„é“è·¯ï¼Œåªéœ€è¦åå‘æ·»åŠ ä¸€æ¡é“è·¯å³å¯ã€‚åƒè¿™æ ·ï¼š è¿™æ ·ï¼Œæ¯æ¡è·¯å°±æœ‰äº†é€šè¡Œæ–¹å‘ã€‚ä¸€èˆ¬è§„å®šå‡ºå‘ç‚¹çš„ç¬¦å·ä¸ºOï¼Œç›®çš„ç‚¹çš„ç¬¦å·ä¸ºDï¼Œè¿™æ ·ï¼Œä½¿ç”¨Oå’ŒDå°±èƒ½æ¸…æ™°åœ°æè¿°æ¯æ¡è·¯çš„æ–¹å‘ã€‚
å¯¹äºä¸Šå›¾çš„ç¤ºä¾‹ï¼Œä¸Šæ–¹çš„é“è·¯O=1ï¼ŒD=2ï¼Œæ‰€ä»¥æ–¹å‘æè¿°ä¸ºä»1åˆ°2ï¼›ä¸‹æ–¹çš„é“è·¯O=2ï¼ŒD=1ï¼Œæ–¹å‘æè¿°ä¸ºä»2åˆ°1ã€‚`},{header:"ä½¿ç”¨å‡½æ•°å¯¹ç½‘ç»œè¿›è¡Œæ‹“è¡¥",slug:"ä½¿ç”¨å‡½æ•°å¯¹ç½‘ç»œè¿›è¡Œæ‹“è¡¥",content:`MicroCityå¯ä»¥å¤„ç†ç½‘ç»œï¼Œæ‰€æœ‰å‡½æ•°çš„å…·ä½“ç”¨æ³•è§å‚è€ƒæ–‡æ¡£ï¼š4.6 ç½‘ç»œ
æ­¤å¤„ç®€å•åˆ—ä¸¾å‡ ç§åˆ›å»ºMicroCityä¸­ç½‘ç»œå¯¹è±¡çš„æ–¹æ³•ï¼š
local network = CreateNetwork() åˆ›å»ºä¸€ä¸ªç©ºç½‘ç»œå¯¹è±¡å¹¶è¿”å›æ­¤å¯¹è±¡ã€‚networkå°±æ˜¯è¿”å›å¾—åˆ°çš„ç©ºç½‘ç»œå¯¹è±¡ã€‚
åˆ›å»ºå¯¹è±¡åï¼Œå¯ä»¥ä½¿ç”¨AddLinkå’ŒDelLinkç­‰å‡½æ•°åœ¨ç½‘ç»œå¯¹è±¡ä¸­åˆ›å»ºè¿æ¥ã€‚å…·ä½“ç”¨æ³•è§å‚è€ƒæ–‡æ¡£ã€‚
local network, nodes, links = CreateNetwork(Lines)
æ­¤å¤„çš„Linesä¸ºä¸€ä¸ªçŸ¢é‡å›¾å½¢å¯¹è±¡ï¼Œç±»å‹ä¸ºLineã€‚MicroCityä¸­çš„CreateNetwork()å‡½æ•°åœ¨è¿™ç§ç”¨æ³•ä¸­å¯ä»¥ç›´æ¥å¸®ä½ åœ¨é“è·¯è¿çº¿ä¸Šæ·»åŠ èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œå¹¶è‡ªåŠ¨åœ¨è¿”å›çš„linkså¯¹è±¡ä¸­æ ‡ä¸ŠOç‚¹å’ŒDç‚¹çš„ç¼–å·ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ åªéœ€è¦æä¾›ç½‘ç»œè¿çº¿å³å¯ï¼Œå‰©ä¸‹çš„æ‹“è¡¥åŒ–å·¥ä½œå¯ä»¥ç”±å‡½æ•°è‡ªåŠ¨å®Œæˆã€‚æˆ‘è®¤ä¸ºè¿™å¯èƒ½æ˜¯æœ€å¸¸ç”¨çš„åˆ›å»ºç½‘ç»œå›¾å¹¶è¿›è¡Œæ‹“è¡¥åŒ–çš„æ–¹æ³•ã€‚`},{header:"ç½‘ç»œæ‹“è¡¥çš„ç®€å•ç¤ºä¾‹",slug:"ç½‘ç»œæ‹“è¡¥çš„ç®€å•ç¤ºä¾‹",content:`-- æ‰“å¼€è¿çº¿å›¾å±‚
Shapes = Open("Shapes.shp") -- æ‹“è¡¥åŒ–ç½‘ç»œ
network, network_nodes, network_links = CreateNetwork(Shapes) -- åˆ›å»ºå›¾å±‚ï¼Œç”¨äºå­˜æ”¾æ‹“è¡¥åçš„ç½‘ç»œèŠ‚ç‚¹
Nodes = CreateShapes("Nodes", "point")
-- å°†æ‹“è¡¥åŒ–ç½‘ç»œå¾—åˆ°çš„ç½‘ç»œèŠ‚ç‚¹å¤åˆ¶åˆ°å›¾å±‚ä¸­
AddField(Nodes, "ID", "int")
for i = 1, GetRecCount(network_nodes) do CopyShapeTo(Nodes, 0, 0, GetShape(network_nodes, i))
end -- åˆ›å»ºå›¾å±‚ï¼Œç”¨äºå­˜æ”¾æ‹“è¡¥åçš„ç½‘ç»œè¿çº¿
Links = CreateShapes("Links", "line")
-- å°†ç½‘ç»œè¿çº¿ä¸­åŸæœ‰çš„å±æ€§å­—æ®µå¤åˆ¶åˆ°å›¾å±‚ä¸­
for i = 1, GetFieldCount(Shapes) do AddField(Links, GetField(Shapes, i))
end
-- ä¸ºè¿çº¿æ·»åŠ å±æ€§å­—æ®µï¼Œç¨åä¼šé€šè¿‡å‡½æ•°å°†å¯¹åº”çš„æ•°æ®æ·»åŠ åˆ°å…¶ä¸­
AddField(Links, "ID", "int")
AddField(Links, "O", "int")
AddField(Links, "D", "int")
AddField(Links, "IMPEDANCE", "double") --é˜»æŠ—
AddField(Links, "DIRECTION", "int") --æ–¹å‘
AddField(Links, "CAPACITY", "double") --å®¹é‡
-- å°†æ‹“è¡¥åŒ–ç½‘ç»œå¾—åˆ°çš„ç½‘ç»œçº¿è·¯å¤åˆ¶åˆ°å›¾å±‚ä¸­ï¼ˆåŒ…æ‹¬å¯¹åº”æ•°æ®ï¼‰
for i = 1, GetRecCount(network_links) do CopyShapeTo(Links, 0, 0, GetShape(network_links, i))
end -- æ›´æ–°å›¾å±‚
Update(Nodes)
Update(Links) ç¤ºä¾‹æ”¹è‡ªMicroCityè‡ªå¸¦çš„ç¼–è¾‘å™¨ è™½ç„¶ä¸€å¼€å§‹å°±è¾“å…¥äº†ç½‘ç»œè¿çº¿ï¼Œä½†æ˜¯åœ¨æ‹“è¡¥åŒ–çš„è¿‡ç¨‹ä¸­å¯èƒ½ç”±äºè¿çº¿ä¸Šçš„èŠ‚ç‚¹é‡åˆï¼Œåœ¨æ‹“è¡¥åŒ–çš„è¿‡ç¨‹ä¸­ä¼šæŠŠè¿ç»­çš„è¿çº¿æ‹†æˆå¤šæ®µï¼Œå› æ­¤å¾—åˆ°çš„Linkså›¾å±‚å¯èƒ½ä¸è¾“å…¥çš„å›¾å±‚å­˜åœ¨ä¸åŒã€‚è€Œæ‹“è¡¥åŒ–å¾—åˆ°çš„èŠ‚ç‚¹Nodeså’Œå¾—åˆ°çš„è¿çº¿Linksæ˜¯å¯¹åº”çš„ï¼Œå› æ­¤æ¨èä½¿ç”¨æ‹“è¡¥åŒ–å¤„ç†å®Œçš„Linkså›¾å±‚ä½œä¸ºç½‘ç»œèŠ‚ç‚¹ä¹‹é—´çš„è¿çº¿ã€‚`},{header:"è¸©å‘ç»éªŒï¼šåˆ›å»ºç½‘ç»œå¯¹è±¡",slug:"è¸©å‘ç»éªŒ-åˆ›å»ºç½‘ç»œå¯¹è±¡",content:`å¦‚æœéœ€è¦ä½¿ç”¨CreateNetwork(Nodes, Links)å‡½æ•°å†æ¬¡å»ºç«‹ç½‘ç»œï¼Œéœ€è¦ä¿ç•™ä»¥ä¸‹åœ¨æ‹“è¡¥åŒ–è¿‡ç¨‹ä¸­æ·»åŠ çš„å±æ€§ï¼Œå¦åˆ™å°†ä¼šå‡ºç°ç½‘ç»œåˆå§‹åŒ–é”™è¯¯çš„é—®é¢˜ï¼š
AddField(Links, "ID", "int")
AddField(Links, "O", "int")
AddField(Links, "D", "int")
AddField(Links, "IMPEDANCE", "double") --é˜»æŠ—
AddField(Links, "DIRECTION", "int") --æ–¹å‘
AddField(Links, "CAPACITY", "double") --å®¹é‡
å¦‚æœåªæ˜¯ä¸€æ¬¡æ€§åœ°è¿›è¡Œç½‘ç»œæ‹“è¡¥ï¼Œä¸ä¼šå†ç”¨æ‹“è¡¥åŒ–è¿‡çš„ç½‘ç»œé‡æ–°åˆ›å»ºç½‘ç»œå¯¹è±¡ï¼Œä¹Ÿéœ€è¦å…ˆåˆ›å»ºä»¥ä¸Šå±æ€§ã€‚æ‹“è¡¥åŒ–åæ•°æ®å¹¶ä¸ä¼šæ ¹æ®å±æ€§åç§°å¡«å…¥ï¼Œè€Œæ˜¯æ ¹æ®ä½ç½®å¡«å…¥ã€‚
å¦‚æœåªåˆ›å»ºäº†Oå’ŒDä¸¤ä¸ªå±æ€§ï¼Œåˆ™Oçš„å±æ€§ä¸­ä¼šè¢«å¡«å…¥IDæ•°æ®ï¼Œè€ŒDçš„å±æ€§ä¸­ä¼šè¢«å¡«å…¥Oçš„æ•°æ®ã€‚è€Œå¦‚æœåªæ ¹æ®ä¸Šé¢çš„é¡ºåºåˆ›å»ºäº†IDã€Oã€Dä¸‰ä¸ªå±æ€§ï¼Œç”±äºæ•°æ®é¡ºåºæ ¹æ®ä½ç½®å¡«å…¥ï¼Œåˆ™æœ€ç»ˆçš„å¡«å…¥çš„æ•°æ®æ˜¯æ­£ç¡®çš„ã€‚`},{header:"CopyShapeToå‡½æ•°",slug:"copyshapetoå‡½æ•°",content:`æ‹“è¡¥çš„æ“ä½œä¸­ä½¿ç”¨äº†CopyShapeTo()å‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†ä¸€ä¸ªShapeå¯¹è±¡å¤åˆ¶åˆ°Shapeså›¾å±‚ä¸­çš„å¯¹åº”ä½ç½®ï¼Œå¹¶æ ¹æ®è¾“å…¥çš„dxå’Œdyåœ¨Shapeså›¾å±‚ä¸­è¿›è¡Œä½ç½®å˜æ¢ã€‚å…¶ä¸­ï¼Œdxå’Œdyåˆ†åˆ«ä¸ºåœ¨xå’Œyæ–¹å‘ä¸Šçš„ä½ç§»é‡ï¼ˆç†è§£ä¸ºdeltaxå’Œdeltayï¼‰ã€‚
CopyShapeTo(TargetShapes, dx, dy, Shape1 [, Shape2, ...])
æ ¹æ®å‡½æ•°çš„ç”¨æ³•å¯ä»¥çœ‹åˆ°ï¼Œè¿˜æ”¯æŒå¤åˆ¶åˆ°å¤šä¸ªå›¾å±‚ä¸Šçš„å¯¹åº”ä½ç½®åå†è¿›è¡Œå˜æ¢ã€‚
å¦‚æœåªæƒ³å°†å›¾å½¢å¤åˆ¶åˆ°å¯¹åº”å›¾å±‚çš„å¯¹åº”ä½ç½®ï¼Œè€Œä¸è¿›è¡Œå˜æ¢ï¼Œå¯ä»¥å°†dxå’Œdyè®¾ä¸º0ï¼Œåƒè¿™æ ·ï¼š
CopyShapeTo(TargetShapes, 0, 0, Shape1 [, Shape2, ...])
CopyShapeTo()å‡½æ•°çš„å…·ä½“ç”¨æ³•è§ 4.3 çŸ¢é‡å›¾å½¢å’Œè¡¨æ ¼`},{header:"ç½‘ç»œæ‹“è¡¥åŒ–åç®—æ³•çš„ä½¿ç”¨",slug:"ç½‘ç»œæ‹“è¡¥åŒ–åç®—æ³•çš„ä½¿ç”¨",content:"å¯¹ç½‘ç»œè¿›è¡Œæ‹“è¡¥åŒ–åï¼Œå¯ä»¥ä½¿ç”¨è‡ªå¸¦çš„å‡½æ•°æ±‚è§£å¾ˆå¤šé—®é¢˜ï¼Œå¦‚ï¼šæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘ã€æœ€çŸ­è·¯å¾„ã€æœ€çŸ­è·ç¦»ç­‰ã€‚æœ¬æ–‡ä»¥è®¡ç®—æœ€çŸ­è·¯å¾„å’Œæœ€çŸ­è·¯é•¿ä¸ºä¾‹ä»‹ç»ä¸€ä¸‹è®¡ç®—æœ€çŸ­è·¯å¾„çš„æµç¨‹åŠè¸©è¿‡çš„å‘"},{header:"è®¡ç®—æœ€çŸ­è·¯å¾„å’Œæœ€çŸ­è·¯é•¿",slug:"è®¡ç®—æœ€çŸ­è·¯å¾„å’Œæœ€çŸ­è·¯é•¿",content:"è¦è®¡ç®—æœ€çŸ­è·¯å¾„ï¼Œé¦–å…ˆå¿…é¡»è¦æ¸…æ¥šè®¡ç®—ç½‘ç»œä¸­å“ªä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚è¿™é‡Œä»¥startIDå’ŒendIDåˆ†åˆ«è¡¨ç¤ºèµ·ç‚¹å’Œç»ˆç‚¹ã€‚æœ¬æ–‡å‡è®¾ä½ å·²ç»åˆ›å»ºäº†ç½‘ç»œå¯¹è±¡ï¼Œå¹¶å­˜å…¥åä¸ºNetworkçš„å˜é‡ä¸­ã€‚å¦‚æœä½ ä¸çŸ¥é“è¯¥å¦‚ä½•åˆ›å»ºä¸€ä¸ªç½‘ç»œå›¾ï¼Œå¯ä»¥å‚è€ƒä¸Šæ–¹ä»‹ç»çš„ ç½‘ç»œæ‹“è¡¥åŒ– æµç¨‹ã€‚"},{header:"åˆ›å»ºæœ€å°ç”Ÿæˆæ ‘",slug:"åˆ›å»ºæœ€å°ç”Ÿæˆæ ‘",content:`ç¬¬ä¸€æ­¥ï¼Œå…ˆè¦ä»¥startIDä¸ºå¼€å§‹ç‚¹åˆ›å»ºæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘ã€‚ç†è®ºä¸Šä»¥å§‹ç‚¹åˆ›å»ºæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘åï¼Œå°±å¯ä»¥è·å–å§‹ç‚¹åˆ°ç½‘ç»œä¸Šä»»æ„ä¸€ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚åˆ›å»ºæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘å¯ä»¥è°ƒç”¨GenSTPTree()å‡½æ•°å®ç°ã€‚
GenSTPTree(Network, startID [, endID])
æ­¤å¤„çš„endIDä¸æ˜¯å¿…é¡»çš„ï¼Œå¦‚æœæœ‰å¯ä»¥æä¾›ç»™å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‚¨å…±æœ‰ä¸¤ç§åšæ³•å®ç°è¿™ä¸€æ­¥ï¼š
GenSTPTree(Network, startID) --æ–¹æ³•1
GenSTPTree(Network, startID , endID) --æ–¹æ³•2ï¼ˆå»ºè®®ï¼‰
ä¸€èˆ¬è®¤ä¸ºæä¾›çš„ä¿¡æ¯è¶Šå®Œå¤‡ï¼Œæ‰§è¡Œçš„æ•ˆæœè¶Šå¥½ã€‚ç”±äºåœ¨è®¡ç®—æœ€çŸ­è·¯å¾„ä¹‹å‰å°±çŸ¥é“endIDï¼Œå› æ­¤å»ºè®®å°†å…¶æä¾›ç»™å‡½æ•°ã€‚ æ­¤å¤„å·²ç»å¯¹å‡½æ•°çš„è¿™ç§ä¸­æ‹¬å·å†™æ³•è¿›è¡Œäº†è§£é‡Šï¼Œåæ–‡ä¸­å°†ä¼šç›´æ¥ä½¿ç”¨è¿™ç§å†™æ³•ã€‚ ç¬¬äºŒæ­¥ï¼Œè·å–æœ€çŸ­è·¯å¾„å¯¹åº”çš„ä¿¡æ¯ã€‚å‰é¢æåˆ°ï¼Œç¡®å®šèµ·ç‚¹å’Œç»ˆç‚¹åæ‰èƒ½ç¡®å®šä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­çº¿è·¯ã€‚ç”±äºå‰é¢ä½¿ç”¨å§‹ç‚¹startIDåˆ›å»ºäº†æœ€å°ç”Ÿæˆæ ‘ï¼Œå› æ­¤ç°åœ¨åªéœ€è¦æä¾›ç»ˆç‚¹endIDå°±èƒ½è·å–åˆ°æœ€çŸ­è·¯å¾„å’Œæœ€çŸ­è·¯é•¿ã€‚ä¸‹é¢ä»‹ç»äº†ä½¿ç”¨ç½‘ç»œå¯¹è±¡Networkè·å–æœ€çŸ­è·¯é•¿å’Œæœ€çŸ­è·¯å¾„çš„æ–¹æ³•ã€‚`},{header:"è·å–æœ€çŸ­è·¯é•¿",slug:"è·å–æœ€çŸ­è·¯é•¿",content:`MicroCityçš„æ–‡æ¡£ä¸­æä¾›äº†3ç§è·å–æœ€çŸ­è·¯å¾„çš„æ–¹å¼ã€‚
ç¬¬ä¸€ç§ï¼Œç”±äºå‰é¢è®¡ç®—äº†æœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘ï¼Œå·²ç»è¾“å…¥äº†èµ·å§‹ç‚¹çš„ä¿¡æ¯ã€‚å› æ­¤ç°åœ¨åªéœ€è¦æä¾›ç»ˆç‚¹ä¿¡æ¯å³å¯ã€‚ï¼ˆå³ä½¿åˆšåˆšå¯èƒ½å·²ç»æä¾›äº†ç»ˆç‚¹ä¿¡æ¯ï¼‰å‡½æ•°éœ€è¦ç½‘ç»œå¯¹è±¡Networkå’Œç»ˆç‚¹endIDç”¨æ³•å¦‚ä¸‹ã€‚
local len = GetSTPLen(Network, endID)
ç¬¬äºŒç§ï¼Œé€šè¿‡æä¾›å§‹ç‚¹startIDå’Œç»ˆç‚¹endIDè®¡ç®—ä¸¤ä¸ªç‚¹åœ¨ç½‘ç»œä¸Šçš„æœ€çŸ­è·¯é•¿ã€‚è¿™ç§ç”¨æ³•ä¸è¦æ±‚åœ¨è®¡ç®—æœ€çŸ­è·¯å¾„å‰å…ˆç”Ÿæˆæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚Networkä¸ºç½‘ç»œå¯¹è±¡ï¼Œç”¨æ³•å¦‚ä¸‹ï¼š
local len = GetSTPLen(Network, startID, endID)
ç¬¬ä¸‰ç§ï¼Œé€šè¿‡æä¾›å§‹ç‚¹å’Œç»ˆç‚¹çš„xyåæ ‡è®¡ç®—ä¸¤ä¸ªç‚¹åœ¨ç½‘ç»œä¸Šçš„æœ€çŸ­è·¯é•¿ã€‚è¿™ç§ç”¨æ³•ä¹Ÿä¸éœ€è¦åœ¨è®¡ç®—æœ€çŸ­è·¯å¾„å‰å…ˆç”Ÿæˆæœ€çŸ­è·¯å¾„ç”Ÿæˆæ ‘ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚èµ·ç‚¹çš„åæ ‡è®¾ä¸ºx1ï¼Œy1ï¼›ç»ˆç‚¹çš„åæ ‡è®¾ä¸ºx2ï¼Œy2ï¼ŒNetworkä¸ºç½‘ç»œå¯¹è±¡ï¼Œç”¨æ³•å¦‚ä¸‹ï¼š
local len = GetSTPLen(Network, x1, y1, x2, y2)`},{header:"è·å–æœ€çŸ­è·¯å¾„",slug:"è·å–æœ€çŸ­è·¯å¾„",content:`MicroCityçš„æ–‡æ¡£ä¸­æä¾›äº†3ç§ä¿¡æ¯å¯ä¾›è·å–ï¼Œåˆ†åˆ«ä¸ºï¼š ç‚¹æˆ–çº¿çš„IDåºåˆ—
ç‚¹æˆ–çº¿çš„ç´¢å¼•(index)åºåˆ—
ç‚¹æˆ–çº¿çš„å½¢çŠ¶(Shape)åºåˆ—ã€‚ å‡½æ•°çš„è¯¦ç»†ç”¨æ³•è¯·å‚é˜… 4.6 ç½‘ç»œ - ç®—æ³•ï¼Œæ­¤å¤„ä»…ä»¥ç¬¬2ç§ï¼šç‚¹æˆ–çº¿çš„ç´¢å¼•åºåˆ—ä½œä¸ºç¤ºä¾‹ã€‚
è¿”å›ç‚¹çš„åºåˆ—ï¼š
GetSTPPath (Network, endID, "iNodeShp")
è¿”å›çº¿çš„åºåˆ—ï¼š
GetSTPPath (Network, endID, "iLinkShp")
è¿™æ ·å°±èƒ½è¿”å›æ‰€æœ‰ç‚¹æˆ–çº¿çš„ç´¢å¼•åºåˆ—äº†ã€‚`},{header:"è¸©å‘ç»éªŒï¼šåºåˆ—",slug:"è¸©å‘ç»éªŒ-åºåˆ—",content:`åœ¨Luaè¯­è¨€å¿«é€Ÿä¸Šæ‰‹ä¸­ä»‹ç»è¿‡Luaä¸­çš„é›†åˆï¼Œå®ƒæä¾›äº†ä¸°å¯Œçš„ç‰¹æ€§å¸®åŠ©ç¼–å†™ä»£ç ã€‚ä½†æ˜¯æ²¡æœ‰å¬è¯´è¿‡åºåˆ—ã€‚åºåˆ—æ˜¯ä¸‹é¢è¿™ä¸ªä¸œè¥¿ï¼š
local x, y = GetCenterXY(Shapes) --å€Ÿç”¨ä¸€ä¸‹è¿™ä¸ªå‡½æ•°
é‡Œé¢çš„x,yå°±æ˜¯ä¸€ä¸ªåºåˆ—ã€‚è¿˜æœ‰è¿™ç§æƒ…å†µï¼š
GetDistance (x1, y1, x2, y2 [, x3, y3, ...]) --å†æ¬¡å€Ÿç”¨ä¸€ä¸ªå‡½æ•°
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¾“å…¥çš„ç‚¹è¶Šå¤šï¼Œè¿”å›å€¼ä¹Ÿè¶Šå¤šã€‚å¦‚æœè¾“å…¥4ä¸ªç‚¹ï¼Œå¯ä»¥è¿™æ ·å¤„ç†ï¼š
-- æ­£å¸¸æƒ…å†µ
d1, d2, d3, d4 = GetDistance(x1, y1, x2, y2, x3, y3, x4, y4) -- ä¹Ÿå¯ä»¥ä»…å–å‰ä¸¤ä¸ªè¿”å›å€¼
d1, d2 = GetDistance(x1, y1, x2, y2, x3, y3, x4, y4) -- å½“ç„¶ï¼Œåªå–ä¸€ä¸ªè¿”å›å€¼ä¹Ÿå¯ä»¥
d1 = GetDistance(x1, y1, x2, y2, x3, y3, x4, y4)
ä¸Šé¢çš„å‡½æ•°è¾“å…¥å‚æ•°æ•°é‡å’Œè¾“å‡ºå‚æ•°æ•°é‡æ˜¯æœ‰å…³ç³»çš„ã€‚å¦‚æœè¾“å…¥äº†nä¸ªç‚¹çš„å‚æ•°ï¼Œå°±ä¼šè¿”å›nä¸ªç‚¹çš„è·ç¦»ã€‚ä½†æ˜¯å¯¹äºç½‘ç»œæ‹“è¡¥æ¥è¯´ï¼Œåœ¨è¿”å›æœ€çŸ­è·¯å¾„çš„æ—¶å€™è¿”å›çš„éƒ½æ˜¯å‚æ•°åºåˆ—ï¼Œè€Œæˆ‘å¹¶ä¸çŸ¥é“å‡½æ•°ä¼šç»™æˆ‘ä¼ å‡ºå¤šå°‘ä¸ªå‚æ•°ï¼›è€Œä¸”å½“è¾“å‡ºå‚æ•°çš„ä¸ªæ•°å¤ªå¤šçš„æ—¶å€™ï¼Œä¹Ÿä¸å¤ªå¯èƒ½æ‰‹åŠ¨åˆ›å»ºå¾ˆå¤šä¸ªå˜é‡å­˜æ”¾è¿™äº›å‚æ•°ã€‚
-- é”™è¯¯åšæ³•ï¼š
local indexList = GetSTPPath(Network, endID, "iLinkShp")
-- GetSTPPath()å‡½æ•°ä¸ä¼šè¿”å›ä¸€ä¸ªtable
-- è¿™é‡Œè·å–åˆ°çš„indexListåªæ˜¯ç¬¬ä¸€ä¸ªLinkçš„indexï¼Œæ˜¯ä¸€ä¸ªæ•°å€¼ã€‚
æ—¢ç„¶ç­‰å·å·¦è¾¹æ²¡æœ‰åŠæ³•æ”¹å˜ï¼Œå°±ä»ç­‰å·å³è¾¹åšå‡ºæ”¹å˜ã€‚è¿˜è®°å¾—æ€ä¹ˆå®šä¹‰ä¸€ä¸ªæœ€ç®€å•çš„tableå—ï¼Ÿ
local list = {1, 2, 3, 4, 5}
å³è¾¹çš„1, 2, 3, 4, 5å…¶å®å¯ä»¥çœ‹åšä¸€ä¸ªåºåˆ—ã€‚æ‰€ä»¥ï¼Œåªè¦ç»™å‡½æ•°çš„è¿”å›å€¼åŠ ä¸Šæ‹¬å·å°±èƒ½æŠŠä»–ä»¬å…¨éƒ¨æèµ·æ¥ ( â€¢Ì€ Ï‰ â€¢Ì )âœ§
local indexList = { GetSTPPath(Network, endID, "iLinkShp") }
ä¸Šé¢çš„è¿™ç§åšæ³•å¾—åˆ°çš„indexListå°±æ˜¯ä¸€ä¸ªtableç±»å‹çš„å˜é‡äº†ã€‚ç„¶åå°±å¯ä»¥å¼€å§‹æ‰§è¡Œé›†åˆçš„å„ç§æ“ä½œäº†æğŸ˜‹`}]},{path:"/notes/oop.html",title:"é¢å‘å¯¹è±¡ç¼–ç¨‹",pathLocale:"/",contents:[{header:"é¢å‘å¯¹è±¡ç¼–ç¨‹",slug:"é¢å‘å¯¹è±¡ç¼–ç¨‹",content:`é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆObject Oriented Programmingï¼‰æ˜¯ä¸€ç§ç¼–ç¨‹æ€æƒ³ï¼Œå®ƒå°†çœŸå®ä¸–ç•Œä¸­çš„äº‹ç‰©æŠ½è±¡æˆç¨‹åºä¸–ç•Œä¸­çš„å¯¹è±¡ï¼Œå¯¹è±¡ä¹‹é—´é€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œé€šä¿¡ï¼Œä»è€Œæ„æˆç¨‹åºçš„åŠŸèƒ½ã€‚ ç½‘ä¸Šè¯´çš„é¢å‘å¯¹è±¡ç¼–ç¨‹å…·æœ‰ä¸‰å¤§ç‰¹å¾ï¼Œå³å°è£…ã€ç»§æ‰¿å’Œå¤šæ€ã€‚ä½†æ˜¯æˆ‘è®¤ä¸ºåœ¨è¿™ä¸ªä»¿çœŸä¸­ç”¨å¾—æœ€å¤šçš„å°±æ˜¯å°è£…ï¼Œç»§æ‰¿å’Œå¤šæ€ç”¨çš„æœºä¼šå¾ˆå°‘ã€‚æ­¤å¤–ï¼Œæˆ‘æš‚æ—¶è¿˜æ²¡æœ‰åœ¨MicroCityä¸­å®ç°è¿‡å¯¹è±¡çš„æ¶ˆæ¯ä¼ é€’ï¼Œå¦‚æœå®ç°äº†ä¼šç»§ç»­æ›´æ–°æœ¬æ–‡ã€‚å› æ­¤ä¸‹é¢ä¸»è¦ä»‹ç»ä¸€ä¸‹å¦‚ä½•åœ¨é€‚ç”¨äºMicroCityçš„luaä»£ç ä¸­ä½¿ç”¨å°è£…ã€‚ æç¤º
æœ¬æ–‡ä¸­çš„ä»£ç ç¤ºä¾‹é€‚ç”¨äºMicroCityWebï¼Œå¯¹äºæ¡Œé¢ç‰ˆçš„MicroCityä¸ä¸€å®šé€‚ç”¨ã€‚æ­¤å¤–ï¼Œæœ¬æ–‡å‡ä¸ºä¸ªäººæ„Ÿæ‚Ÿï¼Œä¸ä¿è¯æ¦‚å¿µç»å¯¹çš„æ­£ç¡®æ€§ã€‚`},{header:"é¢å‘å¯¹è±¡ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µ",slug:"é¢å‘å¯¹è±¡ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µ",content:""},{header:"ç±»å’Œå¯¹è±¡",slug:"ç±»å’Œå¯¹è±¡",content:`é€šä¿—æ¥è¯´ï¼Œç±»æ˜¯å¯¹è±¡çš„æ¨¡æ¿ï¼Œå¯¹è±¡æ˜¯ç±»çš„å®ä¾‹ï¼ˆå®ä½“ï¼‰ã€‚
ç±»æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹çš„åŸºæœ¬æ¦‚å¿µï¼Œå®ƒæ˜¯å¯¹ä¸€ç±»äº‹ç‰©çš„æŠ½è±¡ã€‚ç±»çš„æ¦‚å¿µå¯ä»¥ç†è§£ä¸ºä¸€ç±»å¯¹è±¡ï¼Œæ¯”å¦‚AGVã€è´§æ¶ã€åœºæ¡¥ç­‰ã€‚ä½ å¯ä»¥æŠŠç±»ç†è§£ä¸ºä¸€ç±»äº‹ç‰©çš„æ¨¡æ¿ï¼Œè€Œå¯¹è±¡åˆ™æ˜¯æ ¹æ®è¿™ä¸ªæ¨¡æ¿åˆ›å»ºå‡ºæ¥çš„å…·ä½“çš„äº‹ç‰©ã€‚
ä¸€ä¸ªæ¯”è¾ƒå¥½çš„ä¾‹å­æ˜¯ä¸Šé¢æåˆ°çš„è´§æ¶ã€‚è´§æ¶æ˜¯ä¸€ä¸ªç±»ï¼Œé‚£ä¹ˆå…·ä½“çš„è´§æ¶å°±æ˜¯ä¸€ä¸ªå¯¹è±¡ã€‚è´§æ¶ç±»ä¸­åŒ…å«äº†è´§æ¶çš„å„ç§å±æ€§ï¼Œæ¯”å¦‚è´§æ¶çš„ä½ç½®ï¼Œè£…è½½çš„è´§ç‰©ç­‰ã€‚é€šè¿‡è´§æ¶ç±»åˆ›å»ºå‡ºæ¥çš„ä¸åŒçš„è´§æ¶å¯¹è±¡éƒ½å±äºè´§æ¶ç±»ï¼Œæ¯”å¦‚è´§æ¶1ã€è´§æ¶2ç­‰ï¼Œå°½ç®¡å®ƒä»¬çš„å±æ€§å¯èƒ½ä¸åŒï¼Œä½†æ˜¯å®ƒä»¬éƒ½æ˜¯è´§æ¶ç±»çš„å¯¹è±¡ã€‚`},{header:"ç±»çš„å±æ€§å’Œæ–¹æ³•",slug:"ç±»çš„å±æ€§å’Œæ–¹æ³•",content:"åœ¨MicroCityçš„ä»¿çœŸä¸­ï¼Œå°±æˆ‘ä¸ªäººé‡åˆ°çš„æƒ…å†µè€Œè¨€ï¼Œç±»ä¸€èˆ¬ä¼šæœ‰å±æ€§ï¼Œä½†æ˜¯ä¸ä¸€å®šä¼šæœ‰æ–¹æ³•ã€‚å»¶ç»­ä¸Šé¢ä¸¾çš„è´§æ¶çš„ä¾‹å­æ¥è¯´ï¼Œå±æ€§æ˜¯ç±»çš„ç‰¹å¾ï¼Œæ¯”å¦‚è´§æ¶çš„ä½ç½®ã€è´§æ¶ä¸Šçš„è´§ç‰©ç­‰ã€‚æ–¹æ³•æ˜¯ç±»çš„è¡Œä¸ºï¼Œé€šå¸¸ä½¿ç”¨å‡½æ•°ä½“ç°ï¼Œæ¯”å¦‚AGVå°†è´§æ¶æŠ¬èµ·ã€æ”¾ä¸‹ã€AGVç§»åŠ¨æˆ–è€…å¸¦åŠ¨è´§æ¶ç§»åŠ¨ã€‚"},{header:"ä»¿çœŸä¸­ä½¿ç”¨é¢å‘å¯¹è±¡çš„ä¼˜ç‚¹å’Œç¼ºç‚¹",slug:"ä»¿çœŸä¸­ä½¿ç”¨é¢å‘å¯¹è±¡çš„ä¼˜ç‚¹å’Œç¼ºç‚¹",content:""},{header:"ä¼˜ç‚¹",slug:"ä¼˜ç‚¹",content:`åœ¨MicroCityä¸­ï¼Œå°±æ¶‰åŠåˆ°å¤šä¸ªåŒç±»ç‰©ä½“ç§»åŠ¨ã€æ’­æ”¾ç‰©ä½“ç§»åŠ¨åŠ¨ç”»ç­‰åœºæ™¯è€Œè¨€ï¼ˆå¦‚AGVã€è´§æ¶ã€åœºæ¡¥ç§»åŠ¨ç­‰ï¼‰ï¼Œéœ€è¦è¿›è¡Œæ¯”è¾ƒå¤§é‡çš„åæ ‡è®¡ç®—å’Œä½ç½®è®¾ç½®ã€‚å¦‚æœå¯¹æ¯ä¸ªå¯¹è±¡éƒ½å®ç°ä¸€æ¬¡ï¼Œé‚£ä¹ˆä¿®æ”¹å„ä¸ªå¯¹è±¡åæ ‡çš„ä»£ç å°†ä¼šéå¸¸å†—é•¿ï¼Œè€Œä¸”ä¸æ˜“äºç»´æŠ¤ã€‚å¦‚æœä½¿ç”¨é¢å‘å¯¹è±¡çš„ç¼–ç¨‹æ€æƒ³ï¼Œå¯ä»¥å°†æ•°æ®å¤„ç†çš„ä»£ç å°è£…æˆä¸€ä¸ªä¸ªçš„å¯¹è±¡ï¼Œä¹Ÿèƒ½ä½¿ä»£ç æ›´åŠ æ›´å…·æœ‰å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
æ­¤å¤–ï¼Œå¦‚æœåœ¨åœºæ™¯ä¸­åˆ›å»ºå¤šä¸ªåŒç±»å¯¹è±¡ï¼Œå„ä¸ªå¯¹è±¡çš„å‚æ•°ä¹Ÿå¯èƒ½å„ä¸ç›¸åŒã€‚å¦‚æœä½¿ç”¨é¢å‘å¯¹è±¡çš„æ–¹æ³•å°è£…ï¼Œå¯ä»¥å°†å„ä¸ªå¯¹è±¡çš„å‚æ•°å°è£…åœ¨å„ä¸ªå¯¹è±¡è‡ªèº«ä¸­ã€‚å½“ä»¿çœŸæµç¨‹æˆ–è€…è§„æ¨¡å˜å¾—å¤æ‚æ—¶ï¼Œèƒ½å¤Ÿå¢åŠ ä»£ç çš„å¤ç”¨æ€§ã€‚
å¯¹äºä»¿çœŸæ¥è¯´ï¼Œæœ€é‡è¦çš„æ˜¯ææ¸…æ¥šä»¿çœŸçš„ä¸šåŠ¡æµç¨‹å’Œä¸šåŠ¡é€»è¾‘ã€‚ä½¿ç”¨é¢å‘å¯¹è±¡ç¼–ç¨‹å¯ä»¥ä½¿ä»¿çœŸçš„ä¸šåŠ¡æµç¨‹å’Œä¸šåŠ¡é€»è¾‘ä½“ç°å¾—æ›´æ¸…æ™°ï¼Œä½¿ä»£ç çš„å¯è¯»æ€§æé«˜ï¼Œæ›´å…·æœ‰å¯ç»´æŠ¤æ€§ã€‚ æ­¤å¤–ï¼Œå½“éœ€è¦ä¿®æ”¹ä¸€ç±»å¯¹è±¡çš„ä¸šåŠ¡é€»è¾‘æ—¶ï¼Œåªéœ€è¦è¿›å…¥ç±»ä¸­ä¿®æ”¹å³å¯ã€‚æ¯”å¦‚ä¿®æ”¹ä¸€ä¸ªæ¸¯å£ä¸­æ‰€æœ‰åœºæ¡¥çš„è°ƒåº¦ç®—æ³•ï¼Œç”±äºæ‰€æœ‰åœºæ¡¥å…±ç”¨ä¸€å¥—è°ƒåº¦ç®—æ³•ï¼Œå› æ­¤åªéœ€è¦ä¿®æ”¹ä¸€æ¬¡å³å¯ã€‚
å°±æˆ‘ä¸ªäººçš„æƒ…å†µè€Œè¨€ï¼Œé‡‡ç”¨é¢å‘å¯¹è±¡çš„æ–¹æ³•å°è£…å¯¹è±¡æ—¶å¤§å¤šæ˜¯å¸Œæœ›åˆ›å»ºä¸€ä¸ªé€šç”¨çš„å¯¹è±¡ï¼Œç„¶ååœ¨åç»­çš„ä»¿çœŸä¸­é€šè¿‡è‡ªåŠ¨æˆ–æ‰‹åŠ¨çš„æ–¹å¼åˆ›å»ºå¤šä¸ªåŒç±»å¯¹è±¡ï¼Œè€Œå„ä¸ªå¯¹è±¡çš„å‚æ•°å„ä¸ç›¸åŒã€‚è¿™ä¹ˆåšä¼šä½¿å¾—ä»£ç é€šç”¨æ€§å¢åŠ ï¼Œè€Œä¸”ä¹Ÿèƒ½å¤Ÿä½¿å¾—ä»£ç æ›´åŠ æ˜“æ‡‚ï¼Œä¸ºåç»­çš„ç»´æŠ¤å’Œä¿®æ”¹æä¾›ä¾¿åˆ©ï¼Œä¸ºå¤§è§„æ¨¡çš„ä»¿çœŸæ‰“ä¸‹åŸºç¡€ã€‚`},{header:"ç¼ºç‚¹",slug:"ç¼ºç‚¹",content:"å¦‚æœä»¿çœŸè§„æ¨¡å¾ˆå°ï¼Œä»£ç é‡ä¸å¤§çš„ç®€å•çš„æ“ä½œï¼Œä¸å»ºè®®ä½¿ç”¨é¢å‘å¯¹è±¡çš„æ–¹æ³•å°è£…ä»£ç ã€‚ ä½¿ç”¨é¢å‘å¯¹è±¡çš„æ–¹æ³•ä¼šå¢åŠ ä»£ç è¡Œæ•°ï¼Œç”šè‡³ä¼šä½¿ä»£ç çœ‹èµ·æ¥æ˜¾å¾—æ¯”åŸé—®é¢˜æ›´åŠ å¤æ‚ã€‚ï¼ˆå½“ç„¶ä½ è¦ç”¨ä¹Ÿä¸ä¼šæœ‰ä»€ä¹ˆåæœï¼Œåªæ˜¯çœ‹èµ·æ¥ä¼šæ¯”è¾ƒå¥‡æ€ªè€Œå·²ï¼‰å…·ä½“å¯ä»¥å‚è€ƒä¸‹æ–‡æä¾›çš„ä»£ç ç¤ºä¾‹ï¼Œä¸éš¾å‘ç°ï¼Œä»£ç ä¸»è¦ç¯‡å¹…ç”¨åœ¨æè¿°ç±»åŠå…¶ä¸šåŠ¡é€»è¾‘ä¸Šï¼Œè€Œä¸šåŠ¡æµç¨‹çš„ä»£ç å¾ˆç®€å•ï¼Œä¸”å æ¯”å¾ˆå°ã€‚"},{header:"é¢å‘å¯¹è±¡åœ¨Luaä¸­çš„å®ç°",slug:"é¢å‘å¯¹è±¡åœ¨luaä¸­çš„å®ç°",content:"åœ¨Luaä¸­ï¼Œé¢å‘å¯¹è±¡çš„æ¦‚å¿µé€šå¸¸ä½¿ç”¨tableå®ç°ã€‚tableæ˜¯Luaä¸­çš„ä¸€ç§æ•°æ®ç»“æ„ï¼Œå®ƒå¯ä»¥ç”¨æ¥è¡¨ç¤ºæ•°ç»„ã€å­—å…¸ã€å¯¹è±¡ç­‰ã€‚åœ¨é¢å‘å¯¹è±¡çš„ç¼–ç¨‹ä¸­ï¼Œtableä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºå¯¹è±¡ã€‚"},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹",content:`ç”±äºMicroCityä¸­åˆ›å»ºçš„å¯¹è±¡éƒ½æ˜¯tableï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨åˆ›å»ºå¯¹è±¡æ—¶ï¼Œå°†å¯¹è±¡çš„å±æ€§ç›´æ¥å°è£…åœ¨tableä¸­ï¼Œç„¶åè¿”å›è¿™ä¸ªtableã€‚
ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š
-- å‡½æ•°å°†è¿”å›ä¸€ä¸ªAGVå¯¹è±¡
function AGV() -- åœ¨MicroCityä¸­åˆ›å»ºä¸€ä¸ªAGVçš„3då¯¹è±¡ local agv = scene.addobj('/res/agv.glb') -- è®¾ç½®å¯¹è±¡çš„å±æ€§ agv.position = {0, 0, 0} -- è®¾ç½®å¯¹è±¡çš„ä½ç½® agv.speed = 1 -- è®¾ç½®å¯¹è±¡çš„é€Ÿåº¦ function agv:move(dx, dy, dz) agv.position = {agv.position[1] + dx, agv.position[2] + dy, agv.position[3] + dz} -- ä¿®æ”¹å¯¹è±¡åæ ‡ agv:setpos(agv.position[1], agv.position[2], agv.position[3]) -- è®¾ç½®å¯¹è±¡ä½ç½® scene.render() -- æ¸²æŸ“åœºæ™¯ï¼Œä¸å»ºè®®åœ¨è¿™é‡Œè°ƒç”¨ï¼Œè¿™é‡Œåªæ˜¯ä¸ºäº†æ¼”ç¤º end return agv -- è¿”å›å¯¹è±¡
end -- å¯¹è±¡çš„ä½¿ç”¨
local obj = AGV() --åˆ›å»ºå¯¹è±¡
obj:move(1, 0, 0) --å¯¹è±¡å‘xæ–¹å‘ç§»åŠ¨1ä¸ªå•ä½
æˆ–è€…ä½ ä¹Ÿå¯ä»¥é€‰æ‹©åœ¨åˆ›å»ºå¯¹è±¡åï¼Œå°†å¯¹è±¡çš„å°è£…åœ¨ä¸€ä¸ªtableä¸­ï¼Œç„¶åè¿”å›è¿™ä¸ªtableã€‚
-- å‡½æ•°å°†è¿”å›ä¸€ä¸ªAGVå¯¹è±¡
function AGV() -- ç›´æ¥åœ¨è¦è¿”å›çš„tableä¸­è®¾ç½®å¯¹è±¡å±æ€§ local agv = { object = scene.addobj('/res/agv.glb'), position = {0, 0, 0}, speed = 1 } function agv:move(dx, dy, dz) agv.position = {agv.position[1] + dx, agv.position[2] + dy, agv.position[3] + dz} -- ä¿®æ”¹å¯¹è±¡åæ ‡ agv.object:setpos(agv.position[1], agv.position[2], agv.position[3]) -- è®¾ç½®å¯¹è±¡ä½ç½® scene.render() -- æ¸²æŸ“åœºæ™¯ï¼Œä¸å»ºè®®åœ¨è¿™é‡Œè°ƒç”¨ï¼Œè¿™é‡Œåªæ˜¯ä¸ºäº†æ¼”ç¤º end return agv -- è¿”å›å¯¹è±¡
end -- å¯¹è±¡çš„ä½¿ç”¨
local agv = AGV() --åˆ›å»ºå¯¹è±¡
agv:move(1, 0, 0) --å¯¹è±¡å‘xæ–¹å‘ç§»åŠ¨1ä¸ªå•ä½
è¿˜æœ‰ä¸€ç§åˆ›å»ºå¯¹è±¡çš„æ–¹æ³•æ˜¯ä½¿ç”¨setmetatableï¼Œè¿™å±äºé«˜çº§ç”¨æ³•ï¼Œä½†æ˜¯æ„Ÿè§‰ç”¨åˆ°çš„åœºæ™¯ä¸å¤šåæ¥æˆ‘ä¹Ÿç”¨å¾—æ¯”è¾ƒå°‘äº†ã€‚ä½†æ˜¯ä½¿ç”¨è¿™ç§æ–¹æ³•å¥½åƒå¯ä»¥å®ç°ç±»çš„ç»§æ‰¿ï¼Œå¦‚æœä½ æ„Ÿå…´è¶£å¯ä»¥è‡ªè¡Œæœç´¢ã€‚è¿™é‡Œæä¾›æˆ‘æ—©æœŸä½œä¸šä¸­åˆ›å»ºè´§æ¶ç±»çš„ä»£ç å®ç°ä¾›å‚è€ƒã€‚ï¼ˆç°åœ¨æ„Ÿè§‰è¿™ä¸ªç±»å†™å¾—ä¸ç®—å¾ˆå¥½ğŸ˜‚ï¼Œæ¯”å¦‚ x,y å¯ä»¥ç”¨ pos = {x, y} ä»£æ›¿ï¼Œx_origin å’Œ y_origin å¯ä»¥ä½¿ç”¨ origin = {x, y} ä»£æ›¿ï¼‰
-- è´§æ¶
Shelf = { x = 1, y = 1, cargo = {"box"}, -- è´§ç‰© x_origin = 1, -- è´§æ¶åŸå§‹xåæ ‡ y_origin = 1 -- è´§æ¶åŸå§‹yåæ ‡
} function Shelf:New(x, y) local self = {} setmetatable(self, { __index = Shelf }) self.__index = self self.x = x self.y = y -- è®¾ç½®åŸå§‹åæ ‡ self.x_origin = x self.y_origin = y return self
end`},{header:"ç±»çš„ç±»å‹",slug:"ç±»çš„ç±»å‹",content:`æˆ‘åœ¨è¿™é‡Œè¿˜æƒ³æ€»ç»“ä¸€ä¸‹æˆ‘åˆ›å»ºè¿‡çš„ç±»ä¸»è¦æœ‰ä»€ä¹ˆç±»å‹ã€‚ 3Då®ä½“ç±»ã€‚ ä¸»è¦æ§åˆ¶3Då®ä½“çš„è¿åŠ¨ï¼Œå¦‚AGVã€åœºæ¡¥ç­‰ï¼Œå®ƒä»¬å¤§å¤šå…·æœ‰å®ä½“ä¸”éœ€è¦ç§»åŠ¨ã€‚æœ‰çš„ç”šè‡³è¿˜åŒ…å«å­å¯¹è±¡ï¼Œæ¯”å¦‚åœºæ¡¥å¯¹è±¡å…·æœ‰åŠå…·ã€ç»³ç´¢ã€åŠè½¦ç­‰å­å¯¹è±¡ã€‚
æ•°æ®æ¨¡å‹ã€‚ æ¯”å¦‚å †åœºï¼Œè´§æ¶ã€è´§ç‰©ã€‚å…·ä½“æ¥è¯´æ¯”å¦‚å †åœºç±»ä¸­åŒ…å«å †åœºçš„é•¿å®½ã€å †åœºä¸­çš„è´§ç‰©ã€å †åœºä¸­çš„é›†è£…ç®±ç­‰æ•°æ®ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘è®¤ä¸ºè¿™äº›ç±»å‹ä¹Ÿä¸æ˜¯ä¸¥æ ¼åŒºåˆ†çš„ï¼ŒæŸäº›ç±»ç”šè‡³å…±åŒå…·æœ‰è¿™äº›ç±»çš„ç‰¹æ€§ï¼Œä¸¥æ ¼åŒºåˆ†è¿™ä¸ªç±»å±äºå“ªç§ç±»å‹ä¹Ÿæ²¡æœ‰å¤ªå¤§æ„ä¹‰ã€‚æ¯”å¦‚AGVç±»ä¸­ä¹ŸåŒ…å«äº†AGVçš„ä½ç½®ã€é€Ÿåº¦ç­‰æ•°æ®ï¼Œè€Œè´§æ¶ç±»åªæ˜¯å­˜å‚¨äº†è´§æ¶æ¨¡å‹ï¼Œè´§æ¶æ¨¡å‹çš„ç§»åŠ¨è¿˜æ˜¯äº¤ç”±AGVæ§åˆ¶ï¼Œè€Œå…¶æ›´é‡è¦çš„åŠŸèƒ½æ˜¯è®°å½•è´§æ¶ä¸Šè´§ç‰©çš„ä¿¡æ¯ã€‚å› æ­¤ï¼Œæˆ‘è®¤ä¸ºè¿™äº›ç±»å‹åªæ˜¯ä¸€ç§å¤§è‡´çš„åˆ’åˆ†ï¼Œå…·ä½“çš„å®ç°è¿˜æ˜¯è¦æ ¹æ®å®é™…ä¸šåŠ¡æµç¨‹å’Œéœ€æ±‚æƒ…å†µæ¥ã€‚`}]},{path:"/notes/plots.html",title:"é€šç”¨ç»˜å›¾ä»£ç ",pathLocale:"/",contents:[{header:"é€šç”¨ç»˜å›¾ä»£ç ",slug:"é€šç”¨ç»˜å›¾ä»£ç ",content:`æœ¬èŠ‚æä¾›äº†ä¸€äº›å†™å¥½çš„ç»˜å›¾å¯¹è±¡ï¼Œæ–¹ä¾¿éœ€è¦æ•°æ®å¯è§†åŒ–ç»˜å›¾æ—¶ç›´æ¥ä½¿ç”¨ã€‚ ç›¸å…³ä¿¡æ¯
æœ¬é¡µæ‰€æœ‰å¼€æ”¾æºä»£ç éµå¾ªMITåè®®ï¼Œå¯ä»¥éšæ„ä½¿ç”¨ï¼Œä½†å…¬å¼€å‘å¸ƒæ—¶è¯·ä¿ç•™ç‰ˆæƒä¿¡æ¯ã€‚`},{header:"å¯¼å…¥åº“æ–‡ä»¶",slug:"å¯¼å…¥åº“æ–‡ä»¶",content:"é¦–å…ˆä»‹ç»åº“æ–‡ä»¶çš„ä½¿ç”¨æ–¹å¼ã€‚â€œåº“æ–‡ä»¶â€æŒ‡æå‰åŒ…è£…å¥½çš„ç»˜å›¾å‡½æ•°ï¼Œæœ‰ä»¥ä¸‹3ç§æ–¹æ³•å°†æ–‡ä»¶å¯¼å…¥åˆ° MicroCity Web ä¸­ä½¿ç”¨ã€‚"},{header:"æ–¹æ³•ä¸€ï¼šä½¿ç”¨ä»£ç åœ¨çº¿å¯¼å…¥",slug:"æ–¹æ³•ä¸€-ä½¿ç”¨ä»£ç åœ¨çº¿å¯¼å…¥",content:`ğŸ‘ æ¨èä½¿ç”¨æœ¬æ–¹æ³•ä½¿ç”¨åº“æ–‡ä»¶ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ä½¿ç”¨çš„æ˜¯æœ€æ–°ç‰ˆæœ¬çš„åº“æ–‡ä»¶ã€‚
ä»¥å¯¼å…¥ Histogram å’Œ Subplot ä¸ºä¾‹ï¼Œå¯¼å…¥åº“æ–‡ä»¶ä»£ç å¦‚ä¸‹ï¼š
print('æ­£åœ¨ä¸‹è½½ä¾èµ–åº“åˆ°è™šæ‹Ÿç£ç›˜...')
-- ä¸‹è½½ç›´æ–¹å›¾ä»£ç åˆ°è™šæ‹Ÿç£ç›˜
os.upload('https://www.zhhuu.top/ModelResource/libs/Histogram.lua')
-- ä¸‹è½½å­å›¾ä»£ç åˆ°è™šæ‹Ÿç£ç›˜
os.upload('https://www.zhhuu.top/ModelResource/libs/Subplot.lua')
print('ä¸‹è½½å®Œæˆ')`},{header:"æ–¹æ³•äºŒï¼šä¸‹è½½ä»£ç æ–‡ä»¶å¹¶å¯¼å…¥",slug:"æ–¹æ³•äºŒ-ä¸‹è½½ä»£ç æ–‡ä»¶å¹¶å¯¼å…¥",content:`è½¬åˆ° ä»£ç æ–‡ä»¶ä¸‹è½½ å¤„ä¸‹è½½æ‰€éœ€åº“æ–‡ä»¶ï¼Œç„¶ååœ¨ MicroCity Web ä¸­å¯¼å…¥è¯¥æ–‡ä»¶ï¼Œæœ€åå¼•ç”¨è¯¥æ–‡ä»¶åå³å¯ä½¿ç”¨ã€‚
ä»¥å¼•ç”¨ç›´æ–¹å›¾ä¸ºä¾‹ï¼Œå¼•ç”¨çš„ä»£ç å¦‚ä¸‹:
require("Histogram") --å¼•ç”¨ç›´æ–¹å›¾`},{header:"æ–¹æ³•ä¸‰ï¼šå¤åˆ¶ä»£ç ",slug:"æ–¹æ³•ä¸‰-å¤åˆ¶ä»£ç ",content:"é™¤ééœ€è¦ä¿®æ”¹å‡½æ•°åŠŸèƒ½æˆ–é€»è¾‘ï¼Œå¦åˆ™ä¸å»ºè®®è¿™ä¹ˆåšã€‚å„ä¸ªå‡½æ•°çš„ä»£ç è§ä»£ç éƒ¨åˆ†ã€‚"},{header:"ç›´æ–¹å›¾",slug:"ç›´æ–¹å›¾",content:`ç›´æ–¹å›¾(Histogram)ä¸€èˆ¬ç”¨äºæ˜¾ç¤ºæ•°æ®é›†ä¸­å„æ•°æ®å€¼çš„é¢‘æ•°æˆ–é¢‘ç‡åˆ†å¸ƒæƒ…å†µã€‚
å®ƒå°†æ•°æ®æŒ‰ç…§ä¸€å®šçš„é—´éš”åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªåŒºé—´ï¼ˆæˆ–ç§°ä¸ºâ€œç®±å­â€ï¼‰ï¼Œç„¶åç»˜åˆ¶å‡ºæ¯ä¸ªåŒºé—´çš„é¢‘æ•°ï¼ˆæˆ–é¢‘ç‡ï¼‰åœ¨çºµè½´ä¸Šçš„æŸ±çŠ¶å›¾ï¼Œä»¥æ­¤åæ˜ æ•°æ®çš„åˆ†å¸ƒæƒ…å†µã€‚
ä»¥ä¸‹æ˜¯ç”¨ç›´æ–¹å›¾å¯¹è±¡ï¼ˆå‡½æ•°ï¼‰ç»˜åˆ¶çš„ç›´æ–¹å›¾çš„ç¤ºä¾‹`},{header:"å¯¼å…¥ç›´æ–¹å›¾",slug:"å¯¼å…¥ç›´æ–¹å›¾",content:`é¦–å…ˆå¯¼å…¥ç›´æ–¹å›¾çš„ä»£ç ï¼Œå…·ä½“å¯¼å…¥æ–¹å¼è§å¯¼å…¥åº“æ–‡ä»¶ã€‚
ç›´æ–¹å›¾çš„æ–‡ä»¶åä¸º Histogram.luaï¼Œå¼•ç”¨ç›´æ–¹å›¾ï¼š
require("Histogram") --å¼•ç”¨ç›´æ–¹å›¾`},{header:"åˆ›å»ºç›´æ–¹å›¾å¯¹è±¡",slug:"åˆ›å»ºç›´æ–¹å›¾å¯¹è±¡",content:`åˆ›å»ºä¸€ä¸ªç›´æ–¹å›¾å¯¹è±¡
local plot = Histogram(list) -- listä¸ºæ•°æ®é›†
è¿˜å¯ä»¥åœ¨åˆ›å»ºå¯¹è±¡æ—¶å¯¹å›¾çš„å±æ€§è¿›è¡Œè®¾ç½®ã€‚
local plot = Histogram(list, {range={40,90,0,100}, scale={10, 50}, fdisp=function(x) return (x/n*100).."%" end})
å±æ€§çš„è®¾ç½®ä¸æ˜¯å¿…é¡»çš„ï¼Œå¯ä»¥ä»…æ ¹æ®éœ€è¦è®¾ç½®ã€‚æ­¤å¤„å°±åªè®¾ç½®äº†rangeã€scaleã€fdispå±æ€§ã€‚`},{header:"ç›´æ–¹å›¾å±æ€§è®¾ç½®",slug:"ç›´æ–¹å›¾å±æ€§è®¾ç½®",content:`ä¸Šé¢æä¾›äº†ç›´æ–¹å›¾å±æ€§è®¾ç½®çš„ç®€å•ä¾‹å­ã€‚æ ¹æ®ä»£ç ï¼Œè¿˜å¯ä»¥è®¾ç½®æ›´å¤šçš„å±æ€§ã€‚å…·ä½“è§ä¸‹è¡¨ï¼š å±æ€§å€¼
ä½œç”¨
ç¤ºä¾‹ origin
è®¾ç½®å›¾åŸç‚¹ï¼ˆå·¦ä¸‹è§’ç‚¹ï¼‰
origin = {-50, -50}ï¼Œå°†å›¾çš„åŸç‚¹è®¾ç½®åœ¨(-50,-50)çš„ä½ç½® size
è®¾ç½®å›¾æ¨ªçºµè½´é•¿åº¦ï¼Œå¯ä»¥ç†è§£ä¸ºå›¾çš„å¤§å°
size = {100, 100}ï¼Œå°†å›¾çš„xè½´å’Œyè½´é•¿åº¦åˆ†åˆ«è®¾ç½®ä¸º100ã€100 scale
è®¾ç½®æ¨ªçºµåæ ‡è½´çš„åˆ†åº¦å€¼
scale = {3, 2}ï¼Œå°†å›¾çš„xè½´å’Œyè½´åˆ†åº¦å€¼åˆ†åˆ«è®¾ç½®ä¸º3å’Œ2 axislabel
è®¾ç½®æ¨ªçºµè½´æ ‡é¢˜
axislabel = {"x", "y"}ï¼Œå°†å›¾çš„xè½´å’Œyè½´æ ‡é¢˜åˆ†åˆ«è®¾ç½®ä¸º"x"å’Œ"y" range
è®¾ç½®æ¨ªçºµåæ ‡è½´çš„æ˜¾ç¤ºèŒƒå›´
range = {0, 10, 0, 20}ï¼Œå°†å›¾çš„xè½´èŒƒå›´è®¾ç½®ä¸º[0,10]ï¼Œyè½´èŒƒå›´è®¾ç½®ä¸º[0,20] filled
è®¾ç½®æ˜¯å¦å¡«å……æŸ±çŠ¶å›¾
filled = falseï¼Œå°†æŸ±çŠ¶å›¾è®¾ç½®ä¸ºç©ºå¿ƒã€‚é»˜è®¤æ ·å¼ä¸ºå¡«å…… fdisp
æ•°æ®æ ‡ç­¾çš„æ˜¾ç¤ºå‡½æ•°ï¼Œé»˜è®¤è¿”å›æ•°é‡ã€‚è®¾ç½®æ•°æ®æ ‡ç­¾æ˜¾ç¤ºå‡½æ•°æ—¶ä¹Ÿä¼šå½±å“yè½´åˆ»åº¦çš„æ˜¾ç¤ºã€‚
fdisp = function(v) return (v/n*100).."%" endï¼Œå°†æ•°æ®æ ‡ç­¾æ”¹ä¸ºæŒ‰ç…§æ¯”ä¾‹æ˜¾ç¤ºï¼ˆå‡è®¾nä¸ºæ ·æœ¬æ•°ï¼‰`},{header:"ç›´æ–¹å›¾é«˜çº§ç”¨æ³•",slug:"ç›´æ–¹å›¾é«˜çº§ç”¨æ³•",content:"ğŸ“ˆ åŠ¨æ€åˆ·æ–°æ•°æ®å›¾ ä¿®æ”¹å›¾ä¸­çš„æ•°æ®ã€‚æ­¤å¤„ä»¥å‘å›¾ä¸­æ·»åŠ æ•°æ®ä¸ºä¾‹ã€‚å…¶ä¸­å‡è®¾rndä¸ºæ·»åŠ çš„æ•°æ®ã€‚ä¹Ÿå¯ä»¥ç›´æ¥ä¿®æ”¹plot.dataçš„å€¼ã€‚ table.insert(plot.data, rnd) åˆ·æ–°å›¾ plot:refresh()"},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹",content:""},{header:"åŸºæœ¬ç”¨æ³•ç¤ºä¾‹ï¼šç»˜åˆ¶æ³Šæ¾åˆ†å¸ƒ",slug:"åŸºæœ¬ç”¨æ³•ç¤ºä¾‹-ç»˜åˆ¶æ³Šæ¾åˆ†å¸ƒ",content:`require("Histogram") --å¼•ç”¨ç›´æ–¹å›¾ local seed = math.randomseed(1, { distribution = "poisson", mu = "3"
})
local list = {seed:random()} --é™æ€ç»˜åˆ¶
for i = #list, 400 do table.insert(list, seed:random())
end local histplot = Histogram(list, { range = {0, 10, 0, 50}, scale = {1, 5}
})
scene.render()`},{header:"é«˜çº§ç”¨æ³•ç¤ºä¾‹ï¼šåŠ¨æ€åˆ·æ–°ç»˜åˆ¶æ³Šæ¾åˆ†å¸ƒ",slug:"é«˜çº§ç”¨æ³•ç¤ºä¾‹-åŠ¨æ€åˆ·æ–°ç»˜åˆ¶æ³Šæ¾åˆ†å¸ƒ",content:`è¿™æ˜¯ä¸€ä¸ªç»˜åˆ¶æ³Šæ¾åˆ†å¸ƒå¹¶åŠ¨æ€åˆ·æ–°æ•°æ®å›¾çš„ç¤ºä¾‹ã€‚å‡è®¾å·²ç»å¯¼å…¥äº†Histogramå¯¹è±¡ï¼Œå¹¶å°†åœºæ™¯è®¾ä¸ºäºŒç»´æ˜¾ç¤ºã€‚
require("Histogram") --å¼•ç”¨ç›´æ–¹å›¾ local seed = math.randomseed(1, { distribution = "poisson", mu = "3"
})
local list = {seed:random()} local histplot = Histogram(list, { range = {0, 10, 0, 50}, scale = {1, 8}
})
scene.render() -- åŠ¨æ€ç»˜åˆ¶
local count = 1
while count < 1000 and scene.render() do local rnd = seed:random() table.insert(histplot.data, rnd) histplot:refresh() count = count + 1
end
scene.render()`},{header:"å­å›¾",slug:"å­å›¾",content:"å­å›¾(Subplot)æ˜¯ä¸ºäº†è§£å†³åŒæ—¶åœ¨ç•Œé¢ä¸­æ”¾ç½®å¤šä¸ªå›¾çš„å›¾å®šä½å’Œå°ºå¯¸é—®é¢˜ã€‚åç§°å€Ÿé‰´è‡ªMATLABã€‚"},{header:"å¯¼å…¥å­å›¾",slug:"å¯¼å…¥å­å›¾",content:`é¦–å…ˆå¯¼å…¥å­å›¾çš„ä»£ç ï¼Œå…·ä½“å¯¼å…¥æ–¹å¼è§å¯¼å…¥åº“æ–‡ä»¶ã€‚
å­å›¾çš„æ–‡ä»¶åä¸º Subplot.luaï¼Œå¼•ç”¨å­å›¾ï¼š
require("Subplot") --å¼•ç”¨å­å›¾`},{header:"å­å›¾å±æ€§è®¾ç½®",slug:"å­å›¾å±æ€§è®¾ç½®",content:`æ­¤å¤„å°†å¯¹å­å›¾çš„å±æ€§è¿›è¡Œè¯¦ç»†è¯´æ˜ã€‚å±æ€§çš„è®¾ç½®ä¸æ˜¯å¿…é¡»çš„ï¼Œå¯ä»¥ä»…æ ¹æ®éœ€è¦è®¾ç½®ã€‚ å±æ€§
ä½œç”¨
ç¤ºä¾‹ span
è®¾ç½®å­å›¾ä¹‹é—´çš„é—´éš”
span=10ï¼Œè®¾ç½®å­å›¾ä¸Šä¸‹å·¦å³ä¹‹é—´çš„é—´éš”ä¸º10 diag
é€šè¿‡è¾“å…¥å¯¹è§’çº¿ä¸¤ä¸ªç‚¹çš„åæ ‡è®¾ç½®å­å›¾ä½ç½®å’Œå¤§å°
diag = {-80, -70, 80, 70}ï¼Œè®¾ç½®å­å›¾çš„å¯¹è§’çº¿èŒƒå›´ä»åæ ‡ (âˆ’80,âˆ’70)(-80,-70)(âˆ’80,âˆ’70) åˆ°åæ ‡ (80,70)(80,70)(80,70)`},{header:"å­å›¾å€¼è¯»å–",slug:"å­å›¾å€¼è¯»å–",content:`é€šè¿‡å±æ€§åˆ›å»ºå­å›¾åï¼Œæˆ–è€…ä¿®æ”¹å­å›¾å±æ€§å¹¶åˆ·æ–°åï¼Œå¯ä»¥å¯¹å­å›¾çš„è®¡ç®—å€¼è¿›è¡Œè¯»å–ï¼Œè·å–Subplotä¸­å„ä¸ªå­å›¾çš„åŸç‚¹ä½ç½®å’Œå°ºå¯¸ã€‚ä¸»è¦é€šè¿‡ä»¥ä¸‹å‡ ä¸ªå±æ€§å€¼è¿›è¡Œè¯»å–ã€‚ æ³¨
æ­¤å¤„å‡è®¾å­å›¾å¯¹è±¡åˆ›å»ºåå­˜æ”¾äº subplot å˜é‡ä¸­ã€‚ è®¡ç®—å±æ€§
å«ä¹‰
ç¤ºä¾‹ originpt
Subplotå¯¹è±¡ä¸­å„ä¸ªå­å›¾çš„åŸç‚¹ä½ç½®
é€šè¿‡subplot.originpt[i][j][1]å’Œsubplot.originpt[i][j][2]èƒ½å¤Ÿè·å–åˆ°ç¬¬iè¡Œjåˆ—çš„å­å›¾å¯¹åº”çš„åŸç‚¹ä½ç½® psize
Subplotå¯¹è±¡ä¸­å„ä¸ªå­å›¾çš„å°ºå¯¸
é€šè¿‡subplot.psize[1]å’Œsubplot.psize[2]èƒ½å¤Ÿè·å–åˆ°subplotä¸­å­å›¾å¯¹åº”çš„å®½åº¦å’Œé«˜åº¦ã€‚(å‡è®¾å­å›¾ä¸­æ‰€æœ‰å›¾æ‰€éœ€å°ºå¯¸ç›¸åŒ)`},{header:"ç¤ºä¾‹",slug:"ç¤ºä¾‹-1",content:`è¿™æ˜¯ä¸€ä¸ªç»˜åˆ¶å­å›¾èŒƒå›´çš„ç¤ºä¾‹ã€‚å‡è®¾å·²ç»å¯¼å…¥äº†Subplotå¯¹è±¡ï¼Œå¹¶å°†åœºæ™¯è®¾ä¸ºäºŒç»´æ˜¾ç¤ºã€‚
æ­¤å¤„å°†ä¸€ä¸ª2è¡Œ3åˆ—å­å›¾ä¸­å„ä¸ªå­å›¾çš„æ˜¾ç¤ºèŒƒå›´ç»˜åˆ¶ä¸ºä¸€ä¸ªçŸ©å½¢ã€‚å…¶ä¸­å­å›¾èŒƒå›´ç”¨å››ä¸ªç°è‰²ç‚¹è¡¨ç¤ºï¼Œå­å›¾ä½ç½®ç”¨è“è‰²çŸ©å½¢è¡¨ç¤ºã€‚
require("Subplot") --å¼•å…¥å­å›¾ä»£ç  local subplot = Subplot(2, 3, {span = 10}) -- ç»˜åˆ¶Subplotå¯¹è±¡è¾¹ç•Œç‚¹
local lb = scene.addobj("points",{size = 10, vertices={subplot.diag[1],subplot.diag[2],0}})
local lt = scene.addobj("points",{size = 10, vertices={subplot.diag[1],subplot.diag[4],0}})
local rb = scene.addobj("points",{size = 10, vertices={subplot.diag[3],subplot.diag[4],0}})
local rt = scene.addobj("points",{size = 10, vertices={subplot.diag[3],subplot.diag[2],0}}) -- ç»˜åˆ¶èŒƒå›´
for i = 1, subplot.row do for j = 1, subplot.col do scene.addobj("polyline", {size = 8, color = "blue", vertices={ subplot.originpt[i][j][1]+subplot.psize[1], subplot.originpt[i][j][2], 0, subplot.originpt[i][j][1], subplot.originpt[i][j][2], 0, subplot.originpt[i][j][1], subplot.originpt[i][j][2]+subplot.psize[2], 0, subplot.originpt[i][j][1]+subplot.psize[1], subplot.originpt[i][j][2]+subplot.psize[2], 0, subplot.originpt[i][j][1]+subplot.psize[1], subplot.originpt[i][j][2], 0, } }) end
end
scene.render()`},{header:"ä»£ç ",slug:"ä»£ç ",content:"å¯ä»¥æ ¹æ®ä»£ç çš„ç»„åˆæƒ…å†µåˆ å»å¼€å¤´çš„ scene.setenv ä»£ç ã€‚ä»£ç ä¸­çš„ scene.render() æ˜¯ä¸ºäº†åœ¨åŠ¨æ€ç»˜åˆ¶æ—¶åˆ·æ–°å›¾åƒã€‚"},{header:"ä»£ç æ–‡ä»¶ä¸‹è½½",slug:"ä»£ç æ–‡ä»¶ä¸‹è½½",content:`ä»£ç æ–‡ä»¶åˆ—è¡¨è§ ModelResource/libs åç§°
é“¾æ¥ ç›´æ–¹å›¾
ModelResource/libs/Histogram.lua å­å›¾
ModelResource/libs/Subplot.lua ğŸ”—ä¸Šæ–¹è¡¨æ ¼é“¾æ¥æŒ‡å‘GitHubä»“åº“ã€‚æ‚¨å¯ä»¥åœ¨GitHubç›´æ¥æŸ¥çœ‹ä»£ç ï¼Œä¹Ÿå¯ä»¥å°†æ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°ä½¿ç”¨ã€‚`}]},{path:"/notes/timelapse.html",title:"ä»¿çœŸæ—¶é—´æ¨è¿›",pathLocale:"/",contents:[{header:"ä»¿çœŸæ—¶é—´æ¨è¿›",slug:"ä»¿çœŸæ—¶é—´æ¨è¿›",content:"ä»¿çœŸä¸­çš„æ—¶é—´æ¨è¿›æ˜¯æŒ‡åœ¨ä»¿çœŸè¿‡ç¨‹ä¸­ï¼Œé€šè¿‡ä»€ä¹ˆæ–¹æ³•æ¨è¿›ä»¿çœŸæ—¶é—´ã€‚"},{header:"æ—¶é—´æ¨è¿›æ³•çš„åˆ†ç±»",slug:"æ—¶é—´æ¨è¿›æ³•çš„åˆ†ç±»",content:`å¸¸è§çš„ä»¿çœŸæ—¶é—´æ¨è¿›æ–¹æ³•æœ‰ä¸‰å¤§ç±»ï¼š äº‹ä»¶è°ƒåº¦æ³•ï¼šäº‹ä»¶è°ƒåº¦æ³•æ˜¯ä¸€ç§åŸºäºäº‹ä»¶çš„ä»¿çœŸæ–¹æ³•ï¼Œå®ƒé€šè¿‡å¯¹ä»¿çœŸç³»ç»Ÿä¸­å„ä¸ªäº‹ä»¶è¿›è¡Œæ’åºï¼ŒæŒ‰ç…§äº‹ä»¶å‘ç”Ÿçš„å…ˆåé¡ºåºä¾æ¬¡æ¨è¿›æ—¶é—´æ‰§è¡Œæ´»åŠ¨ï¼Œè¿›è€Œå®ç°ä»¿çœŸã€‚
å›ºå®šå¢é‡æ¨è¿›æ³•ï¼šå›ºå®šå¢é‡æ¨è¿›æ³•æ˜¯æŒ‡åœ¨ä»¿çœŸè¿‡ç¨‹ä¸­ï¼Œå›ºå®šä¸€ä¸ªæ—¶é—´å¢é‡ã€‚åœ¨è®¾å®šèµ·å§‹æ—¶é—´åï¼Œåœ¨èµ·å§‹æ—¶é—´çš„åŸºç¡€ä¸Šæ ¹æ®æ—¶é—´çš„å¢é‡æ¥å¯¹æ—¶é—´è¿›è¡Œæ¨è¿›ä»¿çœŸã€‚
æ´»åŠ¨äº‹ä»¶æ‰«ææ³•ï¼šé’ˆå¯¹ä¸ç¡®å®šæ€§è¾ƒå¼ºçš„ç³»ç»Ÿï¼Œé€šè¿‡æ‰«æç³»ç»Ÿä¸­å‘ç”Ÿçš„äº‹ä»¶å¹¶æ‰§è¡Œç›¸åº”çš„æ´»åŠ¨å®ç°æ—¶é—´æ¨è¿›ã€‚æ„Ÿè§‰å®ç°èµ·æ¥æ¯”è¾ƒéš¾ï¼ˆå®¹æ˜“å‡ºç°æ—¶é—´æ¨è¿›ä¸å‡†ï¼ˆæœ‰è¯¯å·®ï¼‰çš„é—®é¢˜ï¼Œå¯èƒ½æ˜¯æˆ‘çš„æ°´å¹³ä¸å¤ŸğŸ˜¥ï¼‰`},{header:"å®ä¾‹",slug:"å®ä¾‹",content:""},{header:"äº‹ä»¶è°ƒåº¦æ³•",slug:"äº‹ä»¶è°ƒåº¦æ³•",content:`äº‹ä»¶è°ƒåº¦æ³•æ˜¯ä¸€ç§åŸºäºäº‹ä»¶çš„ä»¿çœŸæ–¹æ³•ï¼Œå®ƒé€šè¿‡å¯¹ä»¿çœŸç³»ç»Ÿä¸­å„ä¸ªäº‹ä»¶è¿›è¡Œæ’åºï¼ŒæŒ‰ç…§äº‹ä»¶å‘ç”Ÿçš„å…ˆåé¡ºåºæ¥è¿›è¡Œä»¿çœŸã€‚åœ¨ä»¿çœŸè¿‡ç¨‹ä¸­ï¼Œä»¿çœŸç³»ç»Ÿæ ¹æ®å½“å‰ä»¿çœŸæ—¶é—´å’Œå‰©ä½™äº‹ä»¶ï¼Œå°†æ—¶é—´æ¨è¿›åˆ°ä¸‹ä¸€ä¸ªäº‹ä»¶ï¼Œæ‰§è¡Œç›¸åº”çš„æ´»åŠ¨ã€‚
äº‹ä»¶è°ƒåº¦æ³•ä¸»è¦åˆ†ä¸ºä»¥ä¸‹3ä¸ªä¸»è¦æ­¥éª¤ï¼Œè¿™3ä¸ªæ­¥éª¤ä¹Ÿæ˜¯æ§åˆ¶äº‹ä»¶è°ƒåº¦æ³•çš„ä¸»æ§ç¨‹åºçš„ä¸»è¦æ­¥éª¤ï¼š æ—¶é—´æ‰«æï¼šç¡®å®šä¸‹ä¸€äº‹ä»¶å‘ç”Ÿæ—¶é—´å¹¶å°†ä»¿çœŸæ—¶é’Ÿæ¨è¿›åˆ°è¯¥æ—¶åˆ»
äº‹ä»¶è¾¨è¯†ï¼šæ­£ç¡®åœ°è¾¨è¯†å½“å‰è¦å‘ç”Ÿçš„äº‹ä»¶
äº‹ä»¶æ‰§è¡Œï¼šæ­£ç¡®åœ°æ‰§è¡Œå½“å‰å‘ç”Ÿçš„äº‹ä»¶ äº‹ä»¶è°ƒåº¦æ³•åŸºæœ¬åŸç†æµç¨‹å›¾å¦‚ä¸‹ï¼š
äº‹ä»¶è°ƒåº¦æ³•åœ¨MicroCityWebä¸­çš„å…·ä½“å®ç°å‚è§ ç¦»æ•£äº‹ä»¶ä»¿çœŸå’Œç¨‹åºæ§åˆ¶ - åç¨‹`},{header:"å›ºå®šå¢é‡æ¨è¿›æ³•",slug:"å›ºå®šå¢é‡æ¨è¿›æ³•",content:"å›ºå®šå¢é‡æ¨è¿›æ³•æ˜¯æŒ‡åœ¨ä»¿çœŸè¿‡ç¨‹ä¸­ï¼Œä»èµ·å§‹æ—¶é—´å¼€å§‹ï¼Œæ¯æ¬¡æ¨è¿›ä¸€ä¸ªå›ºå®šæ­¥é•¿çš„æ—¶é—´ã€‚åœ¨æ¯ä¸ªæ­¥é•¿å†…ï¼Œè‹¥æ— äº‹ä»¶å‘ç”Ÿï¼Œåˆ™ä»¿çœŸé’Ÿå†æ¨è¿›ä¸€ä¸ªå•ä½æ—¶é—´Tï¼›è‹¥åœ¨è¯¥æ­¥å†…æœ‰è‹¥å¹²ä¸ªäº‹ä»¶å‘ç”Ÿï¼Œåˆ™ä¾æ¬¡æ‰§è¡Œï¼Œä¸”è®¤ä¸ºè¿™äº›äº‹ä»¶å‡å‘ç”Ÿåœ¨è¯¥æ­¥çš„ç»“æŸæ—¶åˆ»ã€‚ ä¾‹é¢˜"},{header:"ä»£ç æµç¨‹ç¤ºä¾‹",slug:"ä»£ç æµç¨‹ç¤ºä¾‹",content:`while scene.render() do t = t + dt if t % cycle ~= work_time then d = d + v * dt print("å‡ºå‘å", t, "å°æ—¶") else print("å‡ºå‘å", t, "å°æ—¶,ä¼‘æ¯") end car:setpos(CastToLine(d)) --ç›´çº¿è½¨è¿¹ os.sleep(200)
end æ­¤ä¸ºä»£ç ä¸»è¦æµç¨‹ï¼Œæ— æ³•ç›´æ¥ä½¿ç”¨ è‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸæ€è·¯çš„æœ€åä¸€éƒ¨åˆ†æåˆ°äº†æ”¹è¿›ç©ºé—´ï¼Œå®ç°äº†å…¨å±€çš„ä»¿çœŸé’Ÿï¼Œæœ€ç»ˆå®ç°äº†æ—¶é—´æ¨è¿›æ³•ã€‚æœ€ç»ˆè¿˜å®ç°äº†éå›ºå®šå¢é‡æ¨è¿›ï¼Œè¯¦ç»†è§ä¸‹æ–‡ä»‹ç»ã€‚`},{header:"è‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸå‘ä¸»å¯¼æ—¶é’Ÿæ¨è¿›æ³•çš„æ”¹å˜",slug:"è‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸå‘ä¸»å¯¼æ—¶é’Ÿæ¨è¿›æ³•çš„æ”¹å˜",content:`å…·ä½“æ¥è¯´ï¼Œåªåœ¨åŸæ¥çš„åŸºç¡€ä¸Šåšäº†å¦‚ä¸‹æ”¹åŠ¨ï¼š åˆ é™¤å¤§éƒ¨åˆ†ä¸äº‹ä»¶è°ƒåº¦æ³•æœ‰å…³çš„ os.sleep()ã€‚ç”±äºä»¿çœŸæµç¨‹æ¯”è¾ƒç®€å•ï¼Œä¿ç•™äº†ä¸è£…å¸è´§æœ‰å…³çš„äº‹ä»¶è°ƒåº¦æ³•ï¼Œä¼˜åŒ–èµ„æºå ç”¨ã€‚
è®¾ç½®å…¨å±€ä»¿çœŸæ—¶é’Ÿï¼Œå°† Agv:Move() å‡½æ•°çš„æ€è·¯ä»â€œå›ºå®šæ­¥é•¿æ‰§è¡Œä»»åŠ¡å¹¶åˆ·æ–°åœºæ™¯â€çš„æ”¹ä¸ºâ€œç›‘æµ‹ä»¿çœŸæ—¶é’Ÿæ—¶é•¿å˜åŒ–ï¼Œæ ¹æ®æ—¶é•¿å˜åŒ–æ‰§è¡Œä»»åŠ¡å¹¶åˆ·æ–°åœºæ™¯â€
æ–°å¢ä»¿çœŸé€Ÿåº¦è°ƒæ•´ã€‚ ä»ä»¥ä¸Šçš„æ”¹åŠ¨å¯ä»¥çœ‹å‡ºï¼Œä»¿çœŸçš„æ ¸å¿ƒä»äº‹ä»¶ä»»åŠ¡è½¬å‘äº†ä»¿çœŸæ—¶é’Ÿã€‚å…¶ä¸­ï¼Œåœºæ™¯åˆ·æ–°çš„éƒ¨åˆ†ä½¿ç”¨äº† os.clock() å®ç°ã€‚`},{header:"éå›ºå®šå¢é‡æ¨è¿›æ³•",slug:"éå›ºå®šå¢é‡æ¨è¿›æ³•",content:`ä¸‹é¢æ˜¯ä¸€ä¸ªæœ‰å…³äºæ—¶é—´æ¨è¿›æ³•å’Œ os.clock() å‡½æ•°çš„ç®€å•çš„ç¤ºä¾‹ï¼Œä¿®æ”¹è‡ªMicroCityWebä¸­å†…ç½®çš„æ–¹å—æ—‹è½¬æ¡ˆä¾‹ã€‚å…¶ä¸­ï¼Œos.clock() ç”¨äºè®¡ç®—CPUè¿è¡Œæ—¶é—´ï¼Œä»¥æ­¤å®ç°ä»¿çœŸæ—¶é—´ä¸çœŸå®ä¸–ç•Œæ—¶é—´æˆä¸€å®šæ¯”ä¾‹ã€‚è€Œå…·ä½“çš„æ¯”ä¾‹å¯ä»¥é€šè¿‡ simspeed ï¼ˆä»¿çœŸé€Ÿåº¦ï¼‰è¿›è¡Œè°ƒæ•´ã€‚
local obj = scene.addobj('box') -- åˆå§‹ä½ç½®
local x = 1
local y = 1
local z = 0 local rx, ry = 0.1, 0.1 -- xæ–¹å‘å’Œyæ–¹å‘çš„æ—‹è½¬é€Ÿåº¦
local simspeed = 10 -- ä»¿çœŸé€Ÿåº¦ local t = 0 -- å…¨å±€ä»¿çœŸæ—¶é’Ÿ
local t0 = os.clock() -- è®°å½•ä»¿çœŸå¼€å§‹çš„æ—¶é—´
while scene.render() do local dt = os.clock() - t0 -- è®¡ç®—è‡ªä¸Šæ¬¡è®°å½•æ—¶é—´ä»¥æ¥çš„æ—¶é—´å·® t = t + dt -- ä»¿çœŸæ—¶é’Ÿèµ°è¿‡ç›¸åº”æ—¶é—´å·®é•¿åº¦çš„æ—¶é—´ -- è®¾ç½®æ–¹å—æ­¤åˆ»çš„æ—‹è½¬ä½ç½® x = x + rx * dt * simspeed y = y + ry * dt * simspeed obj:setrot(x, y, z) t0 = os.clock() -- è®°å½•ä»¿çœŸæ—¶é—´
end
ç›¸å…³è¯´æ˜ å½“ä»¿çœŸé€Ÿåº¦ simspeed ä¸º1æ—¶ï¼Œè¡¨ç¤ºä»¿çœŸæ—¶é’Ÿä¸çœŸå®ä¸–ç•Œæ—¶é’Ÿçš„é€Ÿåº¦ç›¸åŒã€‚simspeed å¯ä»¥è§†ä½œåŠ é€Ÿå€ç‡ã€‚
dt è¡¨ç¤ºä¸¤æ¬¡è®°å½•æ—¶é—´ä¹‹é—´çš„æ—¶é—´å·®ï¼Œä»¿çœŸä¸­çš„æ—¶é—´æ­¥è¿›æ ¹æ® dt*simspeed è®¡ç®—å¾—åˆ°ã€‚
ç›¸å…³ä¿¡æ¯
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ—¶é—´å¢é‡ dt çš„æ•°å€¼åœ¨æ¯ä¸ªå¾ªç¯å‘¨æœŸä¸€èˆ¬éƒ½ä¸ç›¸åŒï¼Œdt çš„å…·ä½“å¤§å°ä¸€èˆ¬å–å†³äºç”µè„‘çš„è¿ç®—èƒ½åŠ› æç¤º
æœ‰æ—¶ä¸¤æ¬¡è®°å½•æ—¶é—´ä¹‹é—´æ²¡æœ‰å¤ªå¤šè€—æ—¶çš„æ“ä½œï¼Œè®¡ç®—å¾—åˆ°çš„ dt å¯èƒ½ä¸º0ã€‚ä¸€èˆ¬ä¸¤æ¬¡æ—¶é—´è®°å½•ä¹‹é—´å­˜åœ¨ä¸€ä¸ª scene.render()ï¼Œè¿™æ ·ä¸€èˆ¬èƒ½å¤Ÿä¿è¯ä¸¤æ¬¡é‡‡æ ·çš„æ—¶é—´ä¹‹é—´èƒ½å¤Ÿè®¡ç®—å¾—åˆ°ä¸€ä¸ªä¸ä¸º0çš„æ—¶é—´å·®å€¼ã€‚`}]},{path:"/notes/tools.html",title:"æœ‰å…³å·¥å…·",pathLocale:"/",contents:[{header:"æœ‰å…³å·¥å…·",slug:"æœ‰å…³å·¥å…·",content:"å¯èƒ½èƒ½å¤Ÿç”¨åˆ°çš„å·¥å…·"},{header:"ç¬¬ä¸‰æ–¹å·¥å…·",slug:"ç¬¬ä¸‰æ–¹å·¥å…·",content:`åŒ…æ‹¬è½¯ä»¶ã€ç½‘ç«™ç­‰ MapShaper åœ°å›¾ç¼–è¾‘å™¨ã€‚å¯ä»¥ç¼–è¾‘.geojsonæ–‡ä»¶å¹¶å¯¼å‡ºä¸º.shpæ–‡ä»¶
Three.js Editor Three.jsçš„åœ¨çº¿3Då¯¹è±¡ç¼–è¾‘å™¨ã€‚`},{header:"å¤–éƒ¨å‡½æ•°",slug:"å¤–éƒ¨å‡½æ•°",content:"é€‚ç”¨äº MicroCity Web çš„ä¸€äº›å¤–éƒ¨å‡½æ•°"},{header:"ä½¿ç”¨æ–¹æ³•",slug:"ä½¿ç”¨æ–¹æ³•",content:`æ¨èåœ¨çº¿å¯¼å…¥å‡½æ•°ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ä½¿ç”¨çš„æ˜¯æœ€æ–°ç‰ˆæœ¬çš„å‡½æ•°ã€‚ä¹Ÿå¯ä»¥é€‰æ‹©ä¸‹è½½åˆ°æœ¬åœ°å†ä¸Šä¼ ä½¿ç”¨ã€‚
åœ¨çº¿å¯¼å…¥ç¤ºä¾‹
print('æ­£åœ¨ä¸‹è½½ä¾èµ–åº“åˆ°è™šæ‹Ÿç£ç›˜...')
os.upload('https://www.zhhuu.top/ModelResource/libs/æ–‡ä»¶å.lua')
print('ä¸‹è½½å®Œæˆ')`},{header:"å¯¼å…¥å‡½æ•°",slug:"å¯¼å…¥å‡½æ•°",content:`å¦‚æœå‡½æ•°æ–‡ä»¶åä¸º abc.luaï¼Œå¼•ç”¨å‡½æ•°åå³å®Œæˆå¯¼å…¥ã€‚
require("abc")`},{header:"å‡½æ•°åˆ—è¡¨",slug:"å‡½æ•°åˆ—è¡¨",content:`åŸºæœ¬ä¸Šéƒ½æ˜¯ä¸€äº›è‡ªåˆ¶çš„å‡½æ•°ã€‚
ç”±äºæ–‡ä»¶éƒ½æ”¾åœ¨ GitHub Page ä¸Šï¼Œåœ¨çº¿å¯¼å…¥å¯èƒ½é€Ÿåº¦è¾ƒæ…¢ã€‚å¯ä»¥é€‰æ‹©ä¸‹è½½åˆ°æœ¬åœ°å†ä¸Šä¼ ä½¿ç”¨ã€‚
æœ¬ç«™æä¾›çš„ä»£ç æ–‡ä»¶åˆ—è¡¨è§ ModelResource/libsï¼Œä¸‹æ–¹åˆ—è¡¨éƒ½ä¸º ModelResource ä»“åº“ä¸­çš„æ–‡ä»¶ã€‚ åç§°
è¯´æ˜
é“¾æ¥ Histogram
ç”¨äºç»˜åˆ¶ç›´æ–¹å›¾
ModelResource/libs/Histogram.lua Subplot
ç»˜åˆ¶å¤šå„å›¾çš„æƒ…å†µä¸‹ç»˜åˆ¶å­å›¾
ModelResource/libs/Subplot.lua tablestr
å°†tableè½¬ä¸ºå­—ç¬¦ä¸²
ModelResource/libs/tablestr.lua setpoint
åœ¨æŒ‡å®šåæ ‡è®¾ç½®æ˜¾ç¤ºç‚¹
ModelResource/libs/setpoint.lua ğŸ”¨ æŒç»­æ›´æ–°...`}]},{path:"/notes/versions.html",title:"MicroCityçš„ç‰ˆæœ¬",pathLocale:"/",contents:[{header:"MicroCityçš„ç‰ˆæœ¬",slug:"microcityçš„ç‰ˆæœ¬",content:"MicroCityæ˜¯ä¸€æ¬¾ç®€å•å¿«é€Ÿçš„ç©ºé—´è§„åˆ’å’Œå»ºæ¨¡è½¯ä»¶ï¼Œå¯ç”¨äºæ•°å­¦æ¨¡å‹æ„å»ºæ±‚è§£å’Œä»¿çœŸå®éªŒï¼Œå°¤å…¶é€‚ç”¨äºç‰©æµæ•°å­—åŒ–å»ºæ¨¡é¢†åŸŸã€‚MicroCity æœ€åˆåªæœ‰åªèƒ½åœ¨ Windows æ“ä½œç³»ç»Ÿä¸Šè¿è¡Œçš„ Desktop ç‰ˆæœ¬ï¼Œåæ¥å‡ºç°äº†è·¨å¹³å°ä½¿ç”¨çš„éœ€æ±‚ï¼Œå› æ­¤æ¨å‡ºäº† MicroCity Web ç‰ˆæœ¬ï¼Œå®ƒå¯ä»¥å¾ˆå¥½åœ°è¿è¡Œåœ¨æ­è½½ Chromium å†…æ ¸çš„æµè§ˆå™¨ä¸Šã€‚"},{header:"MicroCity",slug:"microcity",content:""},{header:"MicroCityWeb",slug:"microcityweb",content:`ğŸ¯è®¿é—®MicroCity Web ğŸ“(ç¦»çº¿ç‰ˆ)ä¸‹è½½
MicroCity Web ä¸éœ€è¦ä»»ä½•å®‰è£…ï¼Œåªéœ€è¦ä½¿ç”¨ç°ä»£æµè§ˆå™¨ï¼ˆå¦‚Google Chromeã€Microsoft Edgeï¼‰è®¿é—®å®ƒçš„ç½‘ç«™å³å¯ã€‚è™½ç„¶ç›¸æ¯”äºæ¡Œé¢ç‰ˆï¼Œè¿è¡Œåœ¨æµè§ˆå™¨ä¸Šå¯èƒ½ä¼šé€ æˆä¸€å®šçš„æ€§èƒ½æŸå¤±ï¼Œä½†æ˜¯è¿™ä½¿å¾—ç”¨æˆ·å¯ä»¥åœ¨å‡ ä¹ä»»ä½•æ“ä½œç³»ç»Ÿä¸Šä½¿ç”¨è¯¥è½¯ä»¶ï¼Œæ¯”å¦‚ç”µè„‘ç³»ç»ŸWindowsã€MacOSã€Linuxå’Œæ‰‹æœº/å¹³æ¿ç³»ç»ŸAndroidç­‰ã€‚
å°½ç®¡æ¨å‡ºäº† MicroCity Webï¼Œæ‚¨ä»ç„¶å¯ä»¥ç»§ç»­ä½¿ç”¨ä»¥å‰å¼€å‘çš„æ¡Œé¢ç‰ˆMicroCityã€‚ç„¶è€Œï¼Œæ¡Œé¢ç‰ˆæœ¬å°†ä¸å†æ›´æ–°æ–°åŠŸèƒ½ï¼Œæ‰€æœ‰æ–°çš„åŠŸèƒ½å’Œæ”¹è¿›éƒ½å°†é€šè¿‡æŒç»­äº¤ä»˜åˆ° MicroCity Web ä¸­ï¼Œä½¿ä¹‹èƒ½å¤Ÿæä¾›æœ€å¥½çš„ä½“éªŒï¼ŒåŒæ—¶é¿å…äº†ç‰ˆæœ¬æ§åˆ¶é—®é¢˜ã€‚å¦‚æœå¸Œæœ›ä½“éªŒæœ€æ–°çš„åŠŸèƒ½å’Œæ”¹è¿›ï¼Œåˆ™éœ€è¦æ”¹ç”¨ MicroCity Webã€‚
MicroCity Web ç‰ˆä¹Ÿæä¾›ä½¿ç”¨æµè§ˆå™¨æ‰“åŒ…å¯¼å‡ºçš„ç¦»çº¿ç‰ˆæœ¬ï¼ˆè§ä¸Šæ–¹ ğŸ”—é“¾æ¥ï¼‰ã€‚ æ³¨æ„
ä½†æ˜¯ç”±äº Chromium æµè§ˆå™¨å†…æ ¸çš„æ›´æ–°ï¼ŒæŸäº›è€æ—§çš„ç³»ç»Ÿç‰ˆæœ¬å¯èƒ½ä¸å—æ”¯æŒï¼ˆå¦‚ Windows 8.1 åŠä»¥ä¸‹çš„ Windows ç‰ˆæœ¬ã€32 ä½çš„ Windows æ“ä½œç³»ç»Ÿç­‰ï¼‰`},{header:"å…¼å®¹æ€§",slug:"å…¼å®¹æ€§",content:`MicroCity Web ç‰ˆä½¿ç”¨ Lua 5.4 ä½œä¸ºè„šæœ¬è¯­è¨€ç¼–å†™è„šæœ¬ã€‚æ‚¨å¯ä»¥åœ¨ MicroCity Web è¿è¡Œç¯å¢ƒæˆ–ç¼–è¾‘å™¨ä¸­è¾“å…¥ print(_VERSION) æŒ‡ä»¤æŸ¥çœ‹ä½¿ç”¨çš„ Lua ç‰ˆæœ¬ã€‚
ç”±äºä½¿ç”¨äº†å®éªŒæ€§çš„ JavaScriptå‡½æ•°ï¼ŒMicroCity Web å¯èƒ½åœ¨ä»¥ä¸‹æµè§ˆå™¨å†…æ ¸ä¸­è¿è¡Œå­˜åœ¨å…¼å®¹æ€§é—®é¢˜ï¼š Safariå†…æ ¸çš„æµè§ˆå™¨ï¼Œå¦‚iOSã€iPad OSä¸Šçš„å¤§å¤šæ•°æµè§ˆå™¨ï¼ˆç”±äºAppleå¼ºåˆ¶ä½¿ç”¨Safariçš„æµè§ˆå™¨å†…æ ¸ï¼‰ï¼ŒMacOSä¸Šçš„Safariæµè§ˆå™¨
FireFoxæµè§ˆå™¨ 2023/9/29æµ‹è¯•é‡åˆ°çš„å…¼å®¹æ€§é—®é¢˜åŠéƒ¨åˆ†æŠ€æœ¯ç»†èŠ‚ iOS å’Œ iPad OSï¼š æ— æ³•æ‰“å¼€æœ¬åœ°æ–‡ä»¶ï¼ˆç”±äºä½¿ç”¨äº† showOpenFilePicker() æ–¹æ³•ï¼‰ FireFoxï¼š æ— æ³•æ‰“å¼€æœ¬åœ°æ–‡ä»¶ï¼ˆç”±äºä½¿ç”¨äº† showOpenFilePicker() æ–¹æ³•ï¼‰ å…³äº showOpenFilePicker() æ–¹æ³•çš„å½±å“å‚è§ MDN Web Docs | showOpenFilePicker()`},{header:"å…¶ä»–ä¿¡æ¯",slug:"å…¶ä»–ä¿¡æ¯",content:`æœ¬æ–‡ä½œè€…åœ¨å†™è¿™ç¯‡ç¬”è®°çš„æ—¶å€™ MicroCity Web æ­£åœ¨è¢«ç¬¬ä¸€æ¬¡ç”¨äºæ•™å­¦ç¯å¢ƒä¸­ï¼Œå·²ç»åŸºæœ¬èƒ½å¤Ÿæ­£å¸¸è¿è¡Œå¹¶å®ç°ä¸€å®šçš„ä»¿çœŸåŠŸèƒ½ã€‚æœ¬æ–‡ä½œè€…çš„ç›¸å…³å­¦ä¹ ç»å†å¦‚ä¸‹ï¼š MicroCity Desktopï¼šç‰©æµä¿¡æ¯ç®¡ç†
MicroCity Web ï¼šç‰©æµç³»ç»Ÿä»¿çœŸ æœ¬ç«™ç¬”è®°å†…å®¹ä»…ä¾›å‚è€ƒã€‚å¦‚æœæœ¬æ–‡å†…å®¹ç”±äºæ—¶é—´çš„å› ç´ å‡ºç°åå·®ï¼Œä¹Ÿæ¬¢è¿å„ä½åœ¨ Github ä¸Šé€šè¿‡ Pull Request çš„æ–¹å¼å¯¹æœ¬ç«™å†…å®¹è¿›è¡Œä¿®æ­£ğŸ¥³`}]},{path:"/notes/visualization.html",title:"ç»“æœå¯è§†åŒ–",pathLocale:"/",contents:[{header:"ç»“æœå¯è§†åŒ–",slug:"ç»“æœå¯è§†åŒ–",content:"æœ¬æ–‡ä»‹ç»äº†å¤šç§å°†è®¡ç®—ç»“æœå¯è§†åŒ–çš„æ–¹æ³•ã€‚åŒ…æ‹¬æ”¹å˜å†…å®¹çš„é¢œè‰²ï¼Œæ”¹å˜å½¢çŠ¶å¤§å°ï¼Œæ”¹å˜å…ƒç´ æ˜¾ç¤ºçš„å±æ€§æ ‡ç­¾ç­‰ã€‚"},{header:"æ”¹å˜å½¢çŠ¶é¢œè‰²",slug:"æ”¹å˜å½¢çŠ¶é¢œè‰²",content:`åœ¨ç¨‹åºç•Œé¢å·¦ä¸‹è§’çš„å›¾å½¢å±æ€§æ¡†å†…å¯ä»¥é€šè¿‡æ”¹å˜Colorsæ ç›®ä¸‹çš„Typeå±æ€§æ”¹å˜æ˜¾ç¤ºé¢œè‰²çš„ç§ç±»ã€‚å…±æœ‰3ç§é€‰é¡¹ï¼š Unique Symbolï¼šä¸ºåŒä¸€ä¸ªå›¾å±‚çš„æ‰€æœ‰å›¾å½¢æŒ‡å®šæŸç§é¢œè‰²ï¼Œæ­¤å¤„ä¸åšè¿‡å¤šä»‹ç»ã€‚
Lookup Tableï¼šé€šè¿‡æ•°å€¼æŸ¥è¯¢è¡¨æ ¼æ˜¾ç¤ºå¯¹åº”çš„é¢œè‰²ã€‚
Graduated Colorï¼šæ ¹æ®è¡¨ä¸­æ•°å€¼å¤§å°è®¾ç½®æ¸å˜è‰²ã€‚`},{header:"Lookup Table é€šè¿‡è¡¨ä¸­å€¼æ”¹å˜é¢œè‰²",slug:"lookup-table-é€šè¿‡è¡¨ä¸­å€¼æ”¹å˜é¢œè‰²",content:"å°†Typeçš„å±æ€§å€¼æ”¹ä¸ºLookup Tableï¼Œæ ¹æ®è¡¨æ ¼ä¸­çš„æ•°å€¼æ”¹å˜å›¾å½¢çš„é¢œè‰²ï¼Œè¾¾åˆ°é€‰ä¸­æŒ‡å®šå›¾å½¢çš„æ•ˆæœã€‚ æ­¤å¤„ç¤ºä¾‹å°†Lookup Tableä¸­çš„Attributeæ”¹ä¸ºè¡¨æ ¼ä¸­çš„SELECTï¼Œé€šè¿‡è¡¨ä¸­çš„SELECTåˆ—å€¼æ§åˆ¶çº¿çš„é¢œè‰²ï¼ˆå±æ€§è®¾ç½®è§ä¸Šå›¾ï¼‰ã€‚å½“å€¼ä¸º0æ—¶æ˜¾ç¤ºé»‘è‰²ï¼Œå€¼ä¸º1æ—¶æ˜¾ç¤ºçº¢è‰²ã€‚è¡¨æ ¼ä¸­SELECTåˆ—çš„å€¼å’ŒLookup Tableä¸­çš„å…·ä½“è®¾ç½®å¦‚ä¸‹å›¾ã€‚ æœ€ç»ˆå®ç°çš„æ•ˆæœ"},{header:"Graduated Color æ ¹æ®å€¼çš„å¤§å°æ˜¾ç¤ºæ¸å˜è‰²",slug:"graduated-color-æ ¹æ®å€¼çš„å¤§å°æ˜¾ç¤ºæ¸å˜è‰²",content:"å°†Typeçš„å±æ€§å€¼æ”¹ä¸ºGraduated Colorï¼Œæ ¹æ®è¡¨æ ¼ä¸­ä¸åŒæ•°å€¼çš„å¤§å°æ˜¾ç¤ºä¸åŒçš„é¢œè‰²ï¼Œè¾¾åˆ°æ˜¾ç¤ºæ¸å˜è‰²çš„æ•ˆæœã€‚ æ­¤å¤„ç¤ºä¾‹æ ¹æ®æ¯ä¸ªå›½å®¶çš„äººå£æ•°é‡æ˜¾ç¤ºæ¸å˜è‰²ã€‚å¯ä»¥çœ‹åˆ°ä¸­å›½äººå£æ•°é‡å¤§ï¼Œå› æ­¤æ˜¾ç¤ºçº¢è‰²ï¼Œå°åº¦äººå£æ•°é‡ä¹Ÿè¾ƒå¤§ï¼Œå› æ­¤æ˜¾ç¤ºæ©™è‰²ã€‚å…¶ä»–åœ°åŒºäººå£æ•°é‡è¾ƒä½ï¼Œä½†ä¹Ÿèƒ½é€šè¿‡é¢œè‰²çœ‹å‡ºä¸€äº›å·®åˆ«ã€‚ Graduated Colorä¸‹çš„Colorså±æ€§ä¸­è¿˜å¯ä»¥è°ƒæ•´å…¶ä»–é…è‰²æ–¹æ¡ˆã€‚è®¾ç½®ç•Œé¢å¦‚ä¸‹å›¾ï¼Œæ­¤å¤„å°±ä¸ä¸ä¸€ä¸€åˆ—ä¸¾äº†ã€‚ å¦‚æœæ„Ÿå…´è¶£å¯ä»¥å‚è€ƒæ–‡æ¡£2.1 å±•ç¤ºä¸–ç•Œåœ°å›¾ä¸­çš„ç¤ºä¾‹æ‰‹åŠ¨å°è¯•æ›´æ”¹æ­¤å±æ€§ã€‚"},{header:"æ›´æ”¹å›¾å½¢å’Œæ ‡ç­¾çš„æ˜¾ç¤ºå¤§å°",slug:"æ›´æ”¹å›¾å½¢å’Œæ ‡ç­¾çš„æ˜¾ç¤ºå¤§å°",content:""},{header:"å‚è€ƒç³»çš„é€‰æ‹©",slug:"å‚è€ƒç³»çš„é€‰æ‹©",content:`æ˜¾ç¤ºå†…å®¹å°ºå¯¸çš„å‚è€ƒç³»æœ‰2ä¸ªï¼Œä¸€ä¸ªæ˜¯ä»¥åœ°å›¾ä¸ºå‚è€ƒç³»ï¼Œä¸€ä¸ªæ˜¯ä»¥å±å¹•ä¸ºå‚è€ƒç³»ã€‚æ­¤å¤„å°†å›¾å½¢å’Œæ ‡ç­¾çš„æ˜¾ç¤ºå°ºå¯¸éƒ½è®¾ç½®ä¸ºç›¸åŒçš„å‚è€ƒç³»ã€‚
å†…å®¹ä»¥åœ°å›¾ä¸ºå‚è€ƒç³»æ—¶ï¼Œæ˜¾ç¤ºå†…å®¹çš„å¤§å°ä¼šæ ¹æ®åœ°å›¾å¤§å°åŒæ­¥ç¼©æ”¾ï¼Œå¦‚ä¸‹å›¾ï¼š (ä»¥åœ°å›¾ä¸ºå‚è€ƒç³»æ”¾å¤§) (ä»¥åœ°å›¾ä¸ºå‚è€ƒç³»ç¼©å°) å†…å®¹ä»¥å±å¹•ä¸ºå‚è€ƒç³»æ—¶ï¼Œæ— è®ºåœ°å›¾æ€ä¹ˆç¼©æ”¾å†…å®¹çš„å¤§å°éƒ½å·®ä¸å¤šï¼Œå¦‚ä¸‹å›¾ï¼š (ä»¥å±å¹•ä¸ºå‚è€ƒç³»æ”¾å¤§) (ä»¥å±å¹•ä¸ºå‚è€ƒç³»ç¼©å°) å› æ­¤ï¼Œç»˜å›¾çš„æ—¶å€™è¦æ ¹æ®ç»˜å›¾çš„ç›®çš„é€‰å®šå‚è€ƒç³»ã€‚ å¦‚æœéœ€è¦åœ¨åœ°å›¾ä¸Šç»˜åˆ¶ç¡®å®šå°ºå¯¸çš„å½¢çŠ¶æˆ–è€…æ ‡æ˜ç¡®å®šå°ºå¯¸çš„æ ‡ç­¾ï¼Œå¦‚ç»˜åˆ¶ä¸€ä¸ªåŠå¾„ä¸º10kmçš„åœ†ï¼Œæ­¤æ—¶åº”é€‰ç”¨ä»¥åœ°å›¾ä¸ºå‚è€ƒç³»ã€‚
å¦‚æœä»…éœ€è¦åœ¨ä»»ä½•å°ºå¯¸ä¸‹éƒ½èƒ½æ¸…æ™°æ˜¾ç¤ºæ ‡ç­¾å’Œå›¾å½¢ï¼Œæ­¤æ—¶å¯ä»¥é€‰æ‹©ä»¥å±å¹•ä¸ºå‚è€ƒç³»ã€‚`},{header:"å‚è€ƒç³»åº”ç”¨å®ä¾‹",slug:"å‚è€ƒç³»åº”ç”¨å®ä¾‹",content:"åœ¨å›¾ä¸­ç»˜åˆ¶åœ†ç‚¹ï¼Œå°†åœ†çš„åŠå¾„è®¾ç½®ä¸ºåœ†çš„å¤§å°ï¼Œå¹¶å°†åœ†çš„ä¸­å¿ƒè®¾ç½®åœ¨æ¯ä¸ªç»¿ç‚¹çš„ä¸­å¿ƒä¸Šï¼Œç°è‰²åœ†çš„å¤§å°è¡¨ç¤ºæ¯ä¸ªç»¿ç‚¹çš„è¦†ç›–èŒƒå›´å¤§å°ã€‚ å›¾ä¸­ä»¥åœ°å›¾ä¸ºå‚è€ƒç³»(Map Units)ï¼Œä»¥16ä¸ºåŠå¾„ä¸ºæ¯ä¸ªç»¿ç‚¹éƒ½ç»˜åˆ¶äº†ä¸€ä¸ªç°è‰²çš„åœ†ï¼Œè¡¨ç¤ºæ¯ä¸ªç»¿ç‚¹çš„è¦†ç›–èŒƒå›´ã€‚è¿™äº›ç°è‰²çš„åœ†å­˜æ”¾åœ¨åä¸ºRange.shpçš„å›¾å±‚å†…ï¼Œå›¾å±‚ç±»å‹ä¸ºPointsã€‚"},{header:"å‚è€ƒç³»çš„è®¾å®š",slug:"å‚è€ƒç³»çš„è®¾å®š",content:`åœ¨ç¨‹åºç•Œé¢å·¦ä¸‹è§’çš„å›¾å½¢å±æ€§æ¡†å†…å¯ä»¥è®¾ç½®å›¾å½¢åŠå…¶æ ‡ç­¾çš„å°ºå¯¸å‚è€ƒç³»ã€‚ å¦‚å›¾æ ‡è®°çš„ä¸¤ä¸ªä½ç½®å¯ä»¥åˆ†åˆ«è°ƒæ•´å›¾å½¢å°ºå¯¸çš„å‚è€ƒç³»å’Œæ ‡ç­¾å°ºå¯¸çš„å‚è€ƒç³»ã€‚ å›¾å½¢å°ºå¯¸å‚è€ƒç³»è®¾ç½®ï¼šSizeæ ç›®ä¸‹çš„Size relates to...è°ƒæ•´å›¾å½¢å°ºå¯¸çš„å‚è€ƒç³»ï¼ŒDefault Sizeè°ƒæ•´å›¾å½¢çš„ç›¸å¯¹äºåæ ‡ç³»çš„å°ºå¯¸ã€‚
æ ‡ç­¾å°ºå¯¸å‚è€ƒç³»è®¾ç½®ï¼šLabelsæ ç›®ä¸‹çš„Size relates to...è°ƒæ•´æ ‡ç­¾å°ºå¯¸çš„å‚è€ƒç³»ï¼ŒDefault Sizeè°ƒæ•´çš„æ˜¯æ ‡ç­¾(Labels)ç›¸å¯¹äºåæ ‡ç³»çš„å°ºå¯¸ã€‚`},{header:"æ›´æ”¹æ˜¾ç¤ºçš„æ ‡ç­¾",slug:"æ›´æ”¹æ˜¾ç¤ºçš„æ ‡ç­¾",content:""},{header:"æ‰‹åŠ¨æ›´æ”¹æ˜¾ç¤ºçš„æ ‡ç­¾",slug:"æ‰‹åŠ¨æ›´æ”¹æ˜¾ç¤ºçš„æ ‡ç­¾",content:`åœ¨ç¨‹åºç•Œé¢å·¦ä¸‹è§’çš„å›¾å½¢å±æ€§æ¡†å†…å¯ä»¥è®¾ç½®å›¾å½¢åŠå…¶æ ‡ç­¾çš„å°ºå¯¸å‚è€ƒç³»ã€‚ä¸Šå›¾ä¸­æ˜¾ç¤ºçš„æ ‡ç­¾ä¸ºIDï¼Œå¦‚æœéœ€è¦æ”¹ä¸ºè¡¨æ ¼ä¸­çš„å…¶ä»–åˆ—ï¼Œå¯ä»¥æ›´æ”¹Lablesæ ç›®ä¸‹çš„Attributeå±æ€§å®ç°ã€‚
éœ€è¦æ›´æ”¹çš„å±æ€§ä½ç½®å¦‚å›¾ï¼Œå›¾ä¸­éœ€è¦æ˜¾ç¤ºè¡¨ä¸­å¯¹åº”MSGåˆ—çš„å€¼ï¼Œåªéœ€è¦å°†Labelsæ ç›®ä¸‹çš„Attributeå±æ€§å€¼æ”¹ä¸ºMSGå³å¯ã€‚ ä½†æ˜¯æ¯æ¬¡æ›´æ”¹å›¾å½¢å¹¶æ‰§è¡ŒUpdate()å‡½æ•°åæ ‡ç­¾ï¼ˆLabelï¼‰ä¼šå–æ¶ˆæ˜¾ç¤ºã€‚å¦‚æœéœ€è¦æ‰§è¡Œçš„è„šæœ¬ä¸­å«æœ‰æ­¤å¯¹äºæ­¤å›¾å±‚çš„Update()å‡½æ•°ï¼Œä¸å¿…åœ¨æ¯æ¬¡æ‰§è¡Œå®Œè„šæœ¬åæ‰‹åŠ¨é‡æ–°è®¾ç½®æ˜¾ç¤ºçš„æ ‡ç­¾ï¼Œå¯ä»¥é€šè¿‡è„šæœ¬è‡ªåŠ¨é€‰æ‹©æ˜¾ç¤ºçš„æ ‡ç­¾ã€‚`},{header:"è‡ªåŠ¨æ›´æ”¹æ˜¾ç¤ºçš„æ ‡ç­¾",slug:"è‡ªåŠ¨æ›´æ”¹æ˜¾ç¤ºçš„æ ‡ç­¾",content:`é€šè¿‡SetParameter()å‡½æ•°å¯ä»¥æ›´æ”¹å±æ€§å€¼ã€‚ä»¥ä¸Šå›¾Labelsæ ç›®ä¸‹çš„Attributeå±æ€§ä¸ºä¾‹ï¼Œé€‰ä¸­è¿™æ¡å±æ€§åå¯ä»¥çœ‹åˆ°åº•æ æ˜¾ç¤ºå…¶IDä¸ºLABEL_ATTRIBï¼Œå…¶ç±»å‹ä¸ºChoiceã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“ç±»å‹ä¸ºChoiceæ—¶ï¼Œå‚æ•°å€¼ä»1å¼€å§‹ç¼–å·ï¼Œç¼–å·é¡ºæ¬¡å¯¹åº”ä¸‹æ‹‰èœå•çš„å†…å®¹ã€‚ ç‚¹å¼€è¿™æ¡å±æ€§ä»¥åï¼Œå¯ä»¥çœ‹åˆ°MSGåœ¨ç¬¬äºŒä¸ªã€‚ ç”±äºLuaä¸­ç¼–å·ä¸€èˆ¬ç”±1å¼€å§‹ï¼Œå› æ­¤æ­¤å¤„IDçš„ç¼–å·å¯¹åº”1ï¼ŒMSGçš„ç¼–å·å¯¹åº”2ã€‚éœ€è¦æ“ä½œå¯¹è±¡ä¸ºMSGï¼Œæ‰€ä»¥å‡½æ•°ä¸­éœ€è¦å¡«å…¥Choiceç±»å‹çš„å‚æ•°å€¼ä¸º2ã€‚
æ­¤æ—¶å·²ç»å¾—åˆ°äº†æ‰€æœ‰éœ€è¦çš„å‚æ•°ï¼Œå¯ä»¥ä½¿ç”¨SetParameter()å‡½æ•°å¯¹æ˜¾ç¤ºçš„æ ‡ç­¾è¿›è¡Œæ›´æ”¹ã€‚
-- transportsä¸ºå›¾å½¢å›¾å±‚
SetParameter(transports, "LABEL_ATTRIB", 2) SetParameter()å‡½æ•°éœ€è¦åœ¨Update()å‡½æ•°æ‰§è¡Œåå†æ‰§è¡Œï¼Œå¦åˆ™æ•ˆæœä¼šè¢«Update()å‡½æ•°è¦†ç›–ã€‚ ç°åœ¨å›è¿‡å¤´æ¥å†çœ‹çœ‹SetParameter()å‡½æ•°çš„å…·ä½“ç”¨æ³•ï¼š
SetParameter (Shapes|Table|Grid|Scene|Module, "id", Number|"String"|Object) å‚æ•°
å«ä¹‰ å‚æ•°1
è¾“å…¥çš„å¯¹è±¡ï¼Œå¯ä»¥æ˜¯Shapesã€Tableã€Gridã€Sceneã€Module å‚æ•°2
å…¶ä¸­çš„idä¸ºå±æ€§å¯¹åº”çš„IDã€‚å¦‚æœæ˜¯ä¸Šæ–‡çš„æƒ…å†µï¼Œå°±æ˜¯LABEL_ATTRIB å‚æ•°3
å¦‚æœéœ€è¦æ›´æ”¹å±æ€§å€¼ï¼Œåªæ¥å—æ•°å€¼(Number)ã€å­—ç¬¦ä¸²(String)ã€å¯¹è±¡(Object)ä¸‰ç§ç±»å‹ SetParameter()å‡½æ•°çš„ä»‹ç»å‡ºç°åœ¨æ–‡æ¡£ 4.2 æ§åˆ¶ç”¨æˆ·ç•Œé¢ ä¸­ï¼Œè¯·å‚é˜…ã€‚`},{header:"å€ŸåŠ©æ …æ ¼å›¾",slug:"å€ŸåŠ©æ …æ ¼å›¾",content:`æ …æ ¼å›¾ä¹Ÿå¯ä»¥ç”¨äºå¯è§†åŒ–ï¼Œæˆ‘è®¤ä¸ºæ …æ ¼å›¾æœ€å¸¸ç”¨çš„åœºæ™¯å°±æ˜¯ç»˜åˆ¶çƒ­åŠ›å›¾ã€‚çƒ­åŠ›å›¾çš„ç»˜åˆ¶ä¸»è¦é€šè¿‡ä¿®æ”¹æ …æ ¼å›¾ä¸Šæ¯ä¸ªæ ¼å­çš„å€¼å®ç°ã€‚å¦‚æœä¸æ¸…æ¥šæ …æ ¼å›¾çš„å…·ä½“ç»“æ„ï¼Œå¯ä»¥å…ˆå‚è€ƒæ–‡æ¡£ 3.3 æ …æ ¼å›¾ã€‚å…³äºä½¿ç”¨è„šæœ¬æ§åˆ¶æ …æ ¼å›¾ï¼Œå¯ä»¥å‚è€ƒæ–‡æ¡£ 4.4 æ …æ ¼å›¾å½¢ã€‚
ä¸€ç§ä½¿ç”¨æ …æ ¼å›¾ç»˜åˆ¶çƒ­åŠ›å›¾çš„åœºæ™¯å°±æ˜¯ç»˜åˆ¶åœ°ä»·å›¾ã€‚åœ¨ç»˜åˆ¶åœ°ä»·å›¾æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥éå†æ …æ ¼å›¾ä¸Šçš„æ¯ä¸ªæ ¼ç‚¹ï¼Œè®¡ç®—è¯¥æ ¼ç‚¹åˆ°æ¯ä¸ªä»“åº“çš„è·ç¦»ä¹‹å’Œã€‚ç„¶åå°†è¯¥æ ¼ç‚¹çš„å€¼è®¾ç½®ä¸ºè¿™ä¸ªå€¼ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸€å¼ çƒ­åŠ›å›¾ã€‚è¿™ç§æ–¹æ³•å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¯è§†åŒ–åœ°ä»·çš„åˆ†å¸ƒæƒ…å†µï¼Œå¹¶ä¸”å¯ä»¥ç”¨æ¥å‘ç°åœ°ä»·çš„è¶‹åŠ¿å’Œè§„å¾‹ã€‚`}]},{path:"/notes/warehouse-simulation.html",title:"è‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸæ€è·¯",pathLocale:"/",contents:[{header:"è‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸæ€è·¯",slug:"è‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸæ€è·¯",content:"æœ¬æ–‡æ€è·¯ä»…ä¾›å‚è€ƒï¼Œå»ºè®®åšå‡ºé€‚å½“æ”¹è¿›ã€‚"},{header:"å…·ä½“é—®é¢˜ï¼šåŸºäºå…ƒèƒè‡ªåŠ¨æœºçš„ä»“åº“ä»¿çœŸ",slug:"å…·ä½“é—®é¢˜-åŸºäºå…ƒèƒè‡ªåŠ¨æœºçš„ä»“åº“ä»¿çœŸ",content:`å…¶ä¸­ï¼Œå‡ºå…¥åº“ä½ç½®å¯ä»¥æ›´æ”¹ï¼Œå‰è½¦ä¸ºAGVã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™å…¶å®æ˜¯ä¸€ä¸ªç§»åŠ¨è´§æ¶ä»“åº“çš„å…ƒèƒè‡ªåŠ¨æœºä»¿çœŸã€‚AGVå¯ä»¥ä»è´§æ¶åº•éƒ¨ç©¿è¿‡ï¼Œå¯ä»¥ç§»åŠ¨åˆ°è´§æ¶åº•éƒ¨ï¼ŒæŠŠè´§æ¶æŠ¬èµ·å¹¶è¿é€åˆ°å‡ºå…¥åº“ç‚¹ã€‚`},{header:"åŸºæœ¬å‡è®¾",slug:"åŸºæœ¬å‡è®¾",content:`æ‰€æœ‰è´§æ¶ä¸Šçš„è´§ç‰©ç›¸åŒ
ä¸€ä¸ªè´§æ¶åªæ”¾ä¸€ä¸ªè´§ç‰© å› æ­¤ï¼Œå‡ºåº“å’Œå…¥åº“å¯ä»¥çœ‹åšå®Œå…¨ç›¸åçš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æ­¤å¤„åªéœ€è¦è¯¦ç»†è®¨è®ºå‡ºåº“çš„æƒ…å†µã€‚å³é»˜è®¤è´§æ¶ä¸Šæœ¬èº«å°±æœ‰è´§ç‰©ã€‚`},{header:"æ€»ä½“å®ç°æ€è·¯",slug:"æ€»ä½“å®ç°æ€è·¯",content:`å°†æ•´ä¸ª 3Ã—33\\times33Ã—3 çš„ä»“åº“ä¸­æ¯ä¸ªå…ƒèƒçš„ä½ç½®èµ‹äºˆ (x,y)(x,y)(x,y) åæ ‡ï¼Œæ–¹ä¾¿åç»­çš„ç§»åŠ¨æ“ä½œã€‚
ä»¥AGVä¸ºæ ¸å¿ƒï¼Œå¯¹è´§æ¶è¿›è¡Œæ“ä½œã€‚AGVå¤„äºå‡èµ·çŠ¶æ€ç§»åŠ¨è´§æ¶æ—¶ï¼Œåªéœ€è¦å°†è´§æ¶çš„åæ ‡ä½ç½®åŒæ­¥è®¾ä¸ºAGVçš„ä½ç½®å³å¯è¾¾åˆ°AGVç§»åŠ¨è´§æ¶çš„æ•ˆæœã€‚`},{header:"ä¸šåŠ¡æµç¨‹",slug:"ä¸šåŠ¡æµç¨‹",content:"å…ˆæŒ‰ç…§éœ€æ±‚æ•°é‡ä¹±åºç”Ÿæˆè®¢å•åˆ—è¡¨ï¼ŒAGVæ ¹æ®è®¢å•é¡ºåºä¾æ¬¡å°†è´§æ¶ç§»åŠ¨åˆ°å‡ºåº“ç‚¹è¿›è¡Œå‡ºåº“æ“ä½œã€‚"},{header:"ä¸šåŠ¡é€»è¾‘",slug:"ä¸šåŠ¡é€»è¾‘",content:`å½“æ‰§è¡Œå‡ºåº“æ—¶ï¼ŒAGVå…ˆæ‰¾åˆ°æœ€è¿‘çš„è´§æ¶å¹¶ç§»åŠ¨åˆ°é‚£ä¸ªè´§æ¶çš„ä½ç½®ï¼ŒæŠ¬èµ·è´§æ¶ã€‚ä¸ºè´§æ¶ï¼ˆAGVï¼‰è®¾å®šç§»åŠ¨çš„ç»ˆç‚¹ï¼Œè®¡ç®—æ›¼å“ˆé¡¿è·ç¦»å·®å€¼ã€‚ æ¯æ¬¡ç§»åŠ¨å‰éƒ½é€šè¿‡æ˜¯å¦æœ‰éšœç¢ç‰©åˆ¤æ–­è´§æ¶ç§»åŠ¨çš„æ–¹å‘ï¼ˆxxx æ–¹å‘æˆ– yyy æ–¹å‘ï¼‰ã€‚
å¦‚æœä¸¤ä¸ªæ–¹å‘éƒ½è¢«å µå¡ï¼Œåˆ™ä¼˜å…ˆé€‰æ‹© yyy æ–¹å‘ï¼ˆäººä¸ºè§„å®šï¼‰ï¼Œå°†è¿™ä¸ªæ–¹å‘çš„éšœç¢ç‰©é€’å½’ç§»èµ°ï¼Œä¸ºè´§æ¶ç§»åŠ¨è…¾å‡ºç©ºé—´ã€‚å¦‚æœ yyy æ–¹å‘æ²¡æœ‰ç©ºé—´æ‰é€‰æ‹©ç§»åŠ¨ xxx æ–¹å‘ã€‚`},{header:"è¿‡ç¨‹ä¼˜åŒ–ï¼šå…³äºæ—§æ–¹æ³•å’Œæ–°æ–¹æ³•",slug:"è¿‡ç¨‹ä¼˜åŒ–-å…³äºæ—§æ–¹æ³•å’Œæ–°æ–¹æ³•",content:`è¿™ä¸¤ç§æ–¹æ³•éƒ½æ˜¯å¯ç”¨çš„æ–¹æ³•ï¼Œä½†æ˜¯ æ–°æ–¹æ³•å¯¹ç‰¹å®šåœºæ™¯è¿›è¡Œäº†ä¼˜åŒ–ï¼Œé€šè¿‡å¯¹éšœç¢è¿›è¡Œé¢„åˆ¤å‡å°‘äº†æ“ä½œæ­¥éª¤ã€‚ é—®é¢˜è§ä¸‹å›¾
æ—§æ–¹æ³•ï¼šæ— éšœç¢é¢„åˆ¤ï¼ˆè¿›å‡ºè´§ç‚¹åœ¨ x=3,y=3x=3,y=3x=3,y=3 çš„ä½ç½®ï¼‰ ğŸ‘‰ AGVå®Œæˆç¬¬ä¸€ä¸ªè´§æ¶çš„å‡ºåº“åï¼Œå‘ç¬¬äºŒä¸ªè´§æ¶ç§»åŠ¨ï¼Œä½†æ˜¯å‘ç°ç¬¬ä¸€ä¸ªè´§æ¶æŒ¡ä½äº†å»è·¯ï¼Œå› æ­¤åˆå›åˆ°ç¬¬ä¸€ä¸ªè´§æ¶çš„ä½ç½®å°†å…¶ç§»å¼€ï¼Œå†å›åˆ°ç¬¬äºŒä¸ªè´§æ¶è¿›è¡Œå‡ºåº“æ“ä½œã€‚
æ–°æ–¹æ³•ï¼šé¢„åˆ¤éšœç¢ï¼ˆè¿›å‡ºè´§ç‚¹åœ¨ x=3,y=3x=3,y=3x=3,y=3 çš„ä½ç½®ï¼‰ ğŸ‘‰ AGVå®Œæˆç¬¬ä¸€ä¸ªè´§æ¶çš„å‡ºåº“æ“ä½œååˆ¤æ–­åä¸€ä¸ªè´§æ¶æ˜¯å¦éœ€è¦ç§»åŠ¨å…¶ä»–ä½ç½®çš„è´§æ¶æ‰èƒ½åˆ°è¾¾å‡ºå…¥åº“ç‚¹ã€‚å¦‚æœéœ€è¦ï¼Œåˆ™ç§»åŠ¨éšœç¢è´§æ¶åæ‰å‰å¾€åä¸€ä¸ªè´§æ¶è¿›è¡Œå‡ºåº“ã€‚ ç›¸å…³ä¿¡æ¯
æœ¬ç€å°½é‡å°‘å ç”¨å‡ºå…¥åº“ç‚¹çš„åŸåˆ™ï¼Œå½“æœ‰ç©ºä½æ—¶AGVå°†æŠŠåœ¨å‡ºå…¥å£çš„è´§æ¶ç§»èµ°ã€‚å› æ­¤æŸäº›çœ‹èµ·æ¥å†—ä½™çš„æ“ä½œå¹¶éæ²¡æœ‰è€ƒè™‘å…¨é¢ã€‚ ä¸åŒæ•°é‡è´§æ¶å¯¹åº”çš„æœ€ä¼˜å¸ƒå±€æ–¹æ¡ˆï¼ˆåŠ¨å›¾ï¼‰
8ä¸ªè´§æ¶çš„æƒ…å†µï¼Œä¸Šé¢å·²ç»è¿›è¡Œäº†å±•ç¤ºã€‚ä¸‹é¢ä»…å±•ç¤ºè¡¨ä¸­è´§æ¶æ•°ä¸º5å’Œ7çš„æƒ…å†µã€‚å…¶ä»–æƒ…å†µè¯¦è§é™„ä»¶ã€‚`},{header:"ä»¿çœŸæ•°æ®æ”¶é›†åˆ†æ",slug:"ä»¿çœŸæ•°æ®æ”¶é›†åˆ†æ",content:""},{header:"å‡ºå…¥åº“æ•ˆç‡æœ€é«˜",slug:"å‡ºå…¥åº“æ•ˆç‡æœ€é«˜",content:`ä»¿çœŸç»“æœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè¡¨ç¤ºç›¸åŒè´§æ¶æ•°é‡ä¸‹å¾—åˆ°çš„æ•ˆç‡æœ€ä½³è´§æ¶çš„è´§æ¶å¸ƒå±€ æœ€ä½³è´§æ¶å¸ƒå±€ï¼šç›¸åŒè´§æ¶æ•°é‡ä¸‹ï¼Œå–å‡ºæ‰€æœ‰è´§ç‰©æ“ä½œæ¬¡æ•°ï¼ˆticksï¼‰æœ€å° å¸ƒå±€å›¾è¯´æ˜ ç™½è‰²ï¼šæ²¡æœ‰æ”¾ç½®è´§æ¶
æµ…ç°è‰²ï¼šè´§æ¶ï¼Œä½†æ˜¯AGVä¸€å¼€å§‹ä½äºè¿™ä¸ªè´§æ¶ä¸‹æ–¹
ç°è‰²ï¼šè´§æ¶ã€‚ è¡¨æ ¼è¯´æ˜ è´§æ¶æ•°é‡ï¼šå­˜åœ¨äºå¸ƒå±€å›¾ä¸­çš„è´§æ¶æ•°é‡
æ—§ticksï¼šä½¿ç”¨æ—§æ–¹æ³•ï¼ˆæ— é¢„åˆ¤éšœç¢ï¼‰å®ç°å–è´§çš„æ“ä½œæ¬¡æ•°ã€‚
æ–°ticksï¼šä½¿ç”¨æ–°æ–¹æ³•ï¼ˆé¢„åˆ¤éšœç¢ï¼‰å®ç°å–è´§çš„æ“ä½œæ¬¡æ•°ã€‚åé¢å°†å¯¹æ–°æ–¹æ³•è¿›è¡Œè¯´æ˜ã€‚
é»„è‰²é«˜äº®ï¼šç›¸åŒå¸ƒå±€ä¸‹æ“ä½œæ¬¡æ•°æœ€å°‘ï¼ˆticksæœ€å°ï¼‰çš„æ–¹æ¡ˆ`},{header:"ç©ºé—´åˆ©ç”¨ç‡æœ€å¤§",slug:"ç©ºé—´åˆ©ç”¨ç‡æœ€å¤§",content:`å¦‚æœæ‰€æœ‰ä½ç½®éƒ½æ”¾ç½®è´§æ¶ï¼Œåˆ™æ— æ³•è®¿é—®åˆ°æ‰€æœ‰è´§æ¶ã€‚å› æ­¤ï¼Œç©ºé—´åˆ©ç”¨ç‡æœ€å¤§çš„æ–¹æ³•æ˜¯æ”¾ç½®8ä¸ªè´§æ¶ã€‚
é¢œè‰²è¯´æ˜ ç»¿è‰²ï¼šæœ‰è´§ç‰©çš„è´§æ¶
ç´«è‰²ï¼šæ²¡æœ‰è´§ç‰©çš„è´§æ¶
æµ…ç´«è‰²ï¼šAGVæŠ¬èµ·çš„è´§æ¶
æ·±ç´«è‰²ï¼šAGVåœ¨è¿™ä¸ªè´§æ¶ä¸‹é¢ï¼Œä½†æ˜¯æ²¡æœ‰æŠ¬èµ·è´§æ¶
æ·±ç°è‰²ï¼šè¿›å‡ºè´§ç‚¹ æœ‰æ—¶å€™åˆ·æ–°å¤ªå¿«å¯èƒ½çœ‹ä¸å‡ºAGVæŠ¬èµ· è¿›å‡ºè´§ç‚¹åœ¨x=2ï¼Œy=3çš„ä½ç½®`},{header:"åˆ›æ–°ç‚¹",slug:"åˆ›æ–°ç‚¹",content:`é¢å¤–è€ƒè™‘è´§ç‰©ç§ç±»ä¸åŒçš„æƒ…å†µã€‚
æ¯æ¬¡ä»¿çœŸä¼šæ ¹æ®è´§æ¶ä¸Šçš„è´§ç‰©ä¹±åºç”Ÿæˆéœ€æ±‚ã€‚
é¢å‘å¯¹è±¡ç¼–ç¨‹ã€‚ä½¿ç”¨é¢å‘å¯¹è±¡çš„æ€æƒ³ç¼–ç¨‹æœ‰åŠ©äºå°†é—®é¢˜æŠ½è±¡åŒ–ã€æœ‰åŠ©äºæµç¨‹ç»†èŠ‚çš„æ”¹è¿›ï¼›å†åŠ ä¸Šå¥½çš„å‘½åæ–¹å¼ä¼šè®©æ•´ä¸ªç¨‹åºçš„æµç¨‹å’Œé€»è¾‘æ¸…æ™°å¾ˆå¤šï¼Œä¸è‡³äºç¡ä¸€è§‰èµ·æ¥å°±å¿˜äº†ğŸ˜‚ ä¸åŒçš„è´§ç‰©ç±»å‹ç”¨ä¸åŒçš„é¢œè‰²è¡¨ç¤ºã€‚AGVçŠ¶æ€é¢œè‰²ã€ç©ºè´§æ¶çš„é¢œè‰²ã€è¿›å‡ºåº“ç‚¹çš„é¢œè‰²å«ä¹‰ä¸ä¹‹å‰ç›¸åŒã€‚ ç´«è‰²ï¼šæ²¡æœ‰è´§ç‰©çš„è´§æ¶
æµ…ç´«è‰²ï¼šAGVæŠ¬èµ·çš„è´§æ¶
æ·±ç´«è‰²ï¼šAGVåœ¨è¿™ä¸ªè´§æ¶ä¸‹é¢ï¼Œä½†æ˜¯æ²¡æœ‰æŠ¬èµ·è´§æ¶
æ·±ç°è‰²ï¼šè¿›å‡ºè´§ç‚¹ 5ä¸ªè´§æ¶çš„æƒ…å†µç¤ºä¾‹ 8ä¸ªè´§æ¶çš„æƒ…å†µç¤ºä¾‹`},{header:"ä»¿çœŸæ”¹è¿›ï¼šä¸‰ç»´åŒ–è‡ªåŠ¨ä»“åº“ä»¿çœŸ",slug:"ä»¿çœŸæ”¹è¿›-ä¸‰ç»´åŒ–è‡ªåŠ¨ä»“åº“ä»¿çœŸ",content:"åœ¨è¿™ä¸€éƒ¨åˆ†é¢˜ç›®ä¹Ÿç¨å¾®æœ‰æ‰€å˜åŒ–ï¼Œè¦æ±‚å°†å…ƒèƒè‡ªåŠ¨æœºä»¿çœŸä»“åº“æ¡ˆä¾‹ä¸‰ç»´åŒ–ï¼Œè¿›è¡Œè‡ªåŠ¨åŒ–ä»“åº“ä»¿çœŸã€‚å…·ä½“è¦æ±‚å¦‚ä¸Šå›¾ã€‚"},{header:"æ€»ä½“æ€è·¯",slug:"æ€»ä½“æ€è·¯",content:""},{header:"ä¸‰ç»´åŒ–",slug:"ä¸‰ç»´åŒ–",content:`ä»¥åŸºäºå…ƒèƒè‡ªåŠ¨æœºçš„ä»“åº“ä»¿çœŸä¸ºæ ¸å¿ƒï¼Œå°†å…¶ä¸­å…ƒèƒè‡ªåŠ¨æœºä»¿çœŸçš„éƒ¨åˆ†æ”¹å†™ä¸ºå†…éƒ¨æ•°æ®è¡¨ï¼Œä½œä¸ºå†…éƒ¨æ•°æ®æ¨¡å‹ï¼Œå¯¹æ•´ä¸ªä»¿çœŸè¿‡ç¨‹çš„çŠ¶æ€è¿›è¡Œç›‘è§†å’Œæ§åˆ¶ã€‚
ç”±äºåŸºäºå…ƒèƒè‡ªåŠ¨æœºçš„ä»“åº“ä»¿çœŸä½¿ç”¨äº†é¢å‘å¯¹è±¡çš„æ–¹æ³•å°è£…å¯¹è±¡ï¼Œä¸šåŠ¡é€»è¾‘å’Œæµç¨‹çš„æ„å»ºä¸­å¤§é¢ç§¯ä½¿ç”¨äº†å¯¹è±¡æ–¹æ³•ï¼Œå› æ­¤æ­¤å¤„åªéœ€è¦æ”¹å†™å¯¹è±¡æ–¹æ³•ï¼ˆå¦‚ Agv:Move(dx, dy) ç­‰ï¼‰å³å¯å®ç°ç”±å…ƒèƒè‡ªåŠ¨æœºä»¿çœŸåˆ°ä¸‰ç»´åŒ–è‡ªåŠ¨ä»“åº“çš„ä»¿çœŸã€‚ å¦‚æœç¨‹åºæ•´ä½“ç»“æ„è®¾è®¡ä¼˜è‰¯ï¼Œåº”ç”¨â€œé¢å‘å¯¹è±¡â€å°†ä¼šå¤§å¹…æå‡ç¨‹åºçš„å¯ç»´æŠ¤æ€§ï¼Œé™ä½ç§»æ¤éš¾åº¦ã€‚ å¯¹äºAGVã€è´§æ¶ç›´æ¥å¥—ç”¨ç°æˆæ¨¡å‹ï¼›å¯¹äºè´§ç‰©ï¼Œåªéœ€è¦è®¾ç½®å…¶è·ç¦»è´§æ¶çš„ç›¸å¯¹é«˜åº¦åˆ—è¡¨å³å¯å®ç°è´§ç‰©è‡ªåŠ¨å­˜æ”¾äºæŒ‡å®šé«˜åº¦ã€‚ æç¤º
å¦‚æœéœ€è¦å¥—ç”¨ç°æˆæ¨¡å‹ï¼Œæˆ–è€…ç”³è¯·ä¸Šä¼ æ¨¡å‹åˆ°æœ¬æ–‡ä½œè€…ç»´æŠ¤çš„ä»“åº“ï¼Œè¯·å‚è€ƒæ–‡æ¡£ 3Då¯¹è±¡-å¤–éƒ¨æ¨¡å‹`},{header:"å‡ºå…¥åº“éœ€æ±‚æ³¢åŠ¨æå¤§",slug:"å‡ºå…¥åº“éœ€æ±‚æ³¢åŠ¨æå¤§",content:`æ ¹æ®é¢˜ç›®è¦æ±‚ï¼ŒåŸºæœ¬ä¸Šåªå­˜åœ¨æœ‰é™çš„2ç§æƒ…å†µï¼š3ä¸ªè´§æ¶ã€6ä¸ªè´§æ¶ã€‚
ç”±äºè´§æ¶æ•°é‡æƒ…å†µæœ‰é™ï¼Œè€ŒåŸºäºå…ƒèƒè‡ªåŠ¨æœºçš„ä»“åº“ä»¿çœŸä¸­å¾—åˆ°äº†æ€§èƒ½æœ€ä½³çš„ä»“åº“å¸ƒå±€ï¼Œå› æ­¤å¯ä»¥ç›´æ¥å¥—ç”¨å¯¹åº”è´§æ¶æ•°é‡çš„æœ€ä½³å¸ƒå±€ï¼Œæœ¬é—®é¢˜ä¸­åªéœ€è¦è€ƒè™‘å›ºå®šè´§æ¶å¸ƒå±€ä¸‹è´§ç‰©çš„ä½ç½®æ‘†æ”¾é—®é¢˜ã€‚
å¯¹äº3ä¸ªè´§æ¶çš„æƒ…å†µï¼Œå…¶æœ€ä½³å¸ƒå±€å±äºé«˜åº¦å¯¹ç§°çš„å½¢æ€ï¼Œè·ç¦»å‡ºå…¥åº“ç‚¹çš„è·ç¦»éƒ½ä¸º1ï¼Œå› æ­¤è¿™ç§æƒ…å†µä¸‹åªéœ€è¦å¯¹1ç§æƒ…å†µè¿›è¡Œä»¿çœŸã€æ”¶é›†å…¶æ•°æ®ã€‚
å¯¹äº6ä¸ªè´§æ¶çš„æƒ…å†µï¼Œé€‰å–äº†3ç§æƒ…å†µè¿›è¡Œå¤šæ¬¡ä»¿çœŸï¼Œå¾—åˆ°æ¯ç§æƒ…å†µå‡ºå…¥åº“è€—è´¹Ticksçš„å¹³å‡å€¼ã€æœ€å¤§å€¼ã€æœ€å°å€¼ã€‚ å½“å‰Ticksæ˜¯AGVç§»åŠ¨çš„æ¬¡æ•°ï¼Œç›¸å½“äºå•ä½æ“ä½œæ—¶é—´ã€‚åæ–‡æ”¹è¿›ç©ºé—´ä¸­æåˆ°äº†å¯ä»¥è¿›è¡Œçš„æ”¹è¿› ç»è¿‡ä»¥ä¸Šåˆ†æå¯ä»¥çœ‹å‡ºæƒ…å†µæœ‰é™ï¼Œå› æ­¤å¯ä»¥é€šè¿‡æ§åˆ¶è´§ç‰©éœ€æ±‚æ€»æ•°ä¸å˜ï¼Œæ¯æ¬¡éšæœºç”Ÿæˆéœ€æ±‚è´§ç‰©ç§ç±»çš„æ–¹å¼å¯¹å„ç§è´§ç‰©æ‘†æ”¾ä½ç½®è¿›è¡Œä»¿çœŸã€å¯¹å¾—åˆ°æ•°æ®è¿›è¡Œåˆ†æï¼Œæœ€ç»ˆç¡®å®šæœ€ä½³çš„è´§ç‰©å¸ƒå±€æ–¹æ¡ˆã€‚`},{header:"æ”¹è¿›",slug:"æ”¹è¿›",content:`åœ¨æµ‹è¯•çš„è¿‡ç¨‹ä¸­å‘ç°åŸæœ‰ç§»åŠ¨è´§æ¶çš„ç­–ç•¥ä¸åˆç†ï¼Œæ”¹è¿›äº†ç§»åŠ¨è´§æ¶çš„ç­–ç•¥ã€‚
æ—§ç­–ç•¥ï¼š æ‰¾åˆ°ç¦»AGVæœ€è¿‘çš„è£…æœ‰éœ€æ±‚è´§ç‰©çš„è´§æ¶ï¼Œå°†å…¶ç§»åŠ¨åˆ°å‡ºå…¥åº“ç‚¹ã€‚ å¯ä»¥çœ‹åˆ°AGVå·²ç»å°†éœ€è¦å‡ºåº“çš„åŒç§è´§ç‰©ï¼ˆé’è‰²æ–¹å—ï¼‰ç§»åŠ¨åˆ°äº†å‡ºå…¥åº“ç‚¹ï¼Œä½†æ˜¯ç”±äºAGVç§»åŠ¨çš„è´§æ¶å¯¹è±¡æ˜¯æ—è¾¹çš„è´§æ¶ï¼Œå› æ­¤æ²¡æœ‰å¯¹å·²ç»åœ¨å‡ºå…¥åº“ç‚¹çš„è´§ç‰©è¿›è¡Œå‡ºåº“ã€‚
æ–°ç­–ç•¥ï¼š æ‰¾åˆ°ç¦»å‡ºå…¥åº“ç‚¹æœ€è¿‘çš„è£…æœ‰éœ€æ±‚è´§ç‰©çš„è´§æ¶ï¼Œå°†å…¶ç§»åŠ¨åˆ°å‡ºå…¥åº“ç‚¹ã€‚æ”¹å˜ç­–ç•¥åï¼Œæ²¡æœ‰å‘ç°ä»¥ä¸Šæåˆ°çš„ä¸åˆç†æƒ…å†µå‡ºç°ã€‚`},{header:"åˆ›æ–°",slug:"åˆ›æ–°",content:`ç”±äºæµ‹è¯•çš„æ¬¡æ•°è¾ƒå¤šï¼Œå› æ­¤å°†ä¸»ä½“æµç¨‹å†™å…¥å‡½æ•°å¹¶è¿›è¡Œé€‚åº”æ€§æ”¹è¿›ï¼Œå®ç°è‡ªåŠ¨å¯¹æ‰€æœ‰æƒ…å†µè¿›è¡Œä»¿çœŸæµ‹è¯•å¹¶å°†æ•°æ®è¾“å‡ºã€‚ä¸‹å›¾ä¸ºè‡ªåŠ¨ä»¿çœŸæµ‹è¯•è¿è¡Œä¸ºç¤ºä¾‹ã€‚ è‡ªåŠ¨ä»¿çœŸæµ‹è¯•æµç¨‹ä»£ç ï¼Œä»…ä¾›å‚è€ƒ
-- æ‰¹é‡æµ‹è¯•
local cargo_ubs = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} -- æµ‹è¯•éœ€æ±‚(ä¸Šé™)åºåˆ— local output_string_list = {} -- æµ‹è¯•ç»“æœåˆ—è¡¨å­—ç¬¦ä¸²
for k, v in ipairs(cargo_ubs) do local test_result = {} -- æœ¬éœ€æ±‚ä¸Šé™æµ‹è¯•ç»“æœåºåˆ— cargo_ub = v -- è®¾ç½®éœ€æ±‚æ•°é‡ä¸Šé™ for j = 1, test_count do scene.setenv({ grid = 'plane', clear = true }) -- æ¸…ç©ºåœºæ™¯å†…å®¹ print("æµ‹è¯•(", j, "/", test_count, ")ï¼šéœ€æ±‚æ•°é‡ä¸º", cargo_ub) local tick = ModelRun() -- è¿è¡Œä»¿çœŸæ¨¡å‹è¿”å›æµ‹è¯•ç»“æœ table.insert(test_result, tick) -- å°†æµ‹è¯•ç»“æœæ’å…¥æµ‹è¯•ç»“æœåºåˆ— end local output_string = "" print("éœ€æ±‚æ•°é‡ä¸º", cargo_ub, "çš„æµ‹è¯•ç»“æœåºåˆ—:") for i = 1, #test_result do -- è¾“å‡ºæµ‹è¯•ç»“æœåºåˆ—åˆ°åˆ—è¡¨å­—ç¬¦ä¸² output_string = output_string .. test_result[i] .. "\\t" end print(output_string) table.insert(output_string_list, output_string)
end -- è¾“å‡ºæµ‹è¯•æµ‹è¯•ç»“æœåˆ—è¡¨
for i, str in ipairs(output_string_list) do print("éœ€æ±‚æ•°é‡ä¸º", cargo_ubs[i], "çš„æµ‹è¯•ç»“æœåºåˆ—:", str)
end
åœ¨è‡ªåŠ¨ä»¿çœŸæµ‹è¯•çš„è¿‡ç¨‹ä¸­å‘ç°äº†BUGï¼Œè¯¦è§ä¸‹æ–‡è¯´æ˜ã€‚`},{header:"è´§æ¶å¸ƒå±€æ–¹æ¡ˆ",slug:"è´§æ¶å¸ƒå±€æ–¹æ¡ˆ",content:`é¢œè‰²è¯´æ˜ æµ…è“è‰²ï¼šå‡ºå…¥åº“ç‚¹
ç™½è‰²ï¼šç©ºæ ¼
æ·±è“ã€çº¢ã€é»„ï¼š3ç§è´§ç‰©å¯¹åº”çš„é¢œè‰² æ¡ä»¶å‡è®¾ æ¯ä¸ªè´§æ¶ä¸Šéƒ½æ”¾æœ‰2ä¸ªåŒç±»è´§ç‰©
è´§ç‰©éœ€æ±‚éšæœºï¼Œæ²¡æœ‰ç§ç±»åå¥½
æ¯æ¬¡åªå–å‡ºä¸€ä¸ªè´§ç‰©`},{header:"ä»¿çœŸç»“æœåŠåˆ†æ",slug:"ä»¿çœŸç»“æœåŠåˆ†æ",content:"å¯¹æ¯ä¸ªè´§ç‰©å¸ƒå±€æ–¹æ¡ˆä¸­æ¯ç§éœ€æ±‚æ•°é‡çš„æƒ…å†µä»¿çœŸæµ‹è¯•30æ¬¡ï¼Œæ±‚å•æ–¹æ¡ˆç»“æœä¸­çš„æœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ã€‚æœ€ç»ˆå¾—åˆ°ç»“è®ºä¸ºåœ¨6ä¸ªè´§æ¶çš„æƒ…å†µä¸­ï¼Œæ–¹æ¡ˆ2çš„å¸ƒå±€è¡¨ç°æœ€ä¼˜ã€‚"},{header:"æ–¹æ¡ˆ3ï¼š3ä¸ªè´§æ¶",slug:"æ–¹æ¡ˆ3-3ä¸ªè´§æ¶",content:""},{header:"æ–¹æ¡ˆ6",slug:"æ–¹æ¡ˆ6",content:"æ–¹æ¡ˆ6å¹³å‡Ticksæ€»è¶‹åŠ¿å›¾ æ–¹æ¡ˆ6æœ€ä¼˜å¸ƒå±€æ–¹æ¡ˆï¼šæ–¹æ¡ˆ2 è¿˜åº”ç»˜åˆ¶åˆ†æ–¹æ¡ˆçš„â€œéœ€æ±‚é‡-æœ€çŸ­å¹³å‡æœåŠ¡æ—¶é—´â€å•ä½è¶‹åŠ¿å›¾ã€‚ä»¥ä¸‹ä»¥æ–¹æ¡ˆ6-1ä¸ºä¾‹ï¼Œæ¨ªåæ ‡ä¸ºè´§ç‰©éœ€æ±‚æ•°é‡ï¼Œçºµè½´ä¸ºæœ€çŸ­å¹³å‡æœåŠ¡æ—¶é—´ï¼ˆTicksï¼‰ã€‚"},{header:"æ”¹è¿›ç©ºé—´",slug:"æ”¹è¿›ç©ºé—´",content:`ç”±äºé¢˜ç›®æ²¡æœ‰ç»™å®šå…·ä½“äº‹ä»¶çš„æ‰§è¡Œæ—¶é—´ï¼Œä¹Ÿæ²¡æœ‰æŒ‡å®šæ—¶é—´å•ä½ï¼Œå› æ­¤æ­¤å¤„åªè®¡é‡è´§æ¶çš„æ“ä½œæ¬¡æ•°ä½œä¸ºè€—è´¹çš„æ—¶é—´ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ—¶é—´æ˜¯åè®¡ç®—çš„ï¼Œæˆ‘æƒ³å¤§éƒ¨åˆ†åŒå­¦åšåˆ°è¿™é‡Œå¯èƒ½éƒ½æ˜¯è¿™æ ·çš„æ€è·¯ã€‚è™½ç„¶æœ€ç»ˆå¾—å‡ºçš„ç»“æœæ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯æ€è·¯è¿˜å¯ä»¥è½¬å˜ä¸€ä¸‹ï¼Œé€‚åº”äºåé¢çš„å­¦ä¹ ã€‚
å½“å‰æ€è·¯æ˜¯ä»¥ä»»åŠ¡é©±åŠ¨çš„ã€‚è™½ç„¶èƒ½å¤Ÿå¾—åˆ°ä¸€ä¸ªæ­£ç¡®çš„ç»“æœï¼Œä½†æ˜¯æ²¡æœ‰åˆ©ç”¨ä»¿çœŸæ—¶é—´ï¼Œè¿™ç§åšæ³•åœ¨åªæ§åˆ¶ä¸€ä¸ªå®ä½“çš„æ—¶å€™ä¸ä¼šå‡ºç°é—®é¢˜ã€‚å½“è¦åŒæ—¶å¤„ç†å¤šä¸ªå®ä½“çš„æ—¶å€™ï¼Œå½“å‰æ€è·¯å°±æ— æ³•åšåˆ°åŒæ—¶æ“ä½œå¤šä¸ªå®ä½“å®Œæˆä»»åŠ¡ï¼Œåªèƒ½å®ç°å¤šä¸ªå®ä½“ä¾æ¬¡å®Œæˆä»»åŠ¡çš„æƒ…å†µã€‚å½“å‰æ€è·¯çš„å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š
ç”±äºåº”ç”¨çš„æ˜¯æ—¶é—´æ¨è¿›æ³•ï¼Œå› æ­¤ä»¿çœŸä¸–ç•Œä¸­æœ‰å±äºå®ƒè‡ªå·±çš„æ—¶é—´ã€‚å¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä»¿çœŸæ—¶é—´ä¸Šä¹˜ä¸€ä¸ªå€ç‡å®ç°æ§åˆ¶ä»¿çœŸé€Ÿåº¦ï¼Œè¿™ä¸ªå€ç‡å°±æ˜¯ä»¿çœŸé€Ÿåº¦ã€‚æ­¤å¤–ï¼Œè¿™ç§åšæ³•æ›´åŠ å®¹æ˜“æ”¯æŒè€ƒè™‘å¤šå¯¹è±¡çš„æƒ…å†µã€‚å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š
è¿™æ ·å°±æ”¹ä¸ºäº†ä»¥æ—¶é—´ä¸ºæ ¸å¿ƒçš„ä»¿çœŸï¼Œåœ¨åˆ·æ–°ä»»åŠ¡æ‰§è¡Œè¿›åº¦çš„æ—¶å€™å°±å¯ä»¥ç›´æ¥åˆ·æ–°åœºæ™¯ä¸­çš„æ‰€æœ‰å®ä½“ã€‚ç”±äºä»¿çœŸä»¥æ—¶é—´ä¸ºæ ¸å¿ƒï¼Œå› æ­¤å°±éœ€è¦è®¾å®šå„ç§æ“ä½œçš„é€Ÿç‡/æ—¶é—´ï¼Œä¿è¯æ—¶é—´è®¡ç®—çš„å‡†ç¡®æ€§ã€‚åœ¨MicroCityWebä¸­ï¼Œæœ‰ä¸€äº›æŠ€å·§å¯ä»¥ç”¨äºæ—¶é—´æ¨è¿›æ³•çš„ä»¿çœŸã€‚`},{header:"ä½¿ç”¨ç³»ç»Ÿæ—¶é—´æ›´æ–°ä»¿çœŸæ—¶é—´",slug:"ä½¿ç”¨ç³»ç»Ÿæ—¶é—´æ›´æ–°ä»¿çœŸæ—¶é—´",content:`os.clock()å‡½æ•°å¯ä»¥è·å–ç³»ç»Ÿå½“å‰çš„æ—¶é—´ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼Œä½†æ˜¯æ˜¯å°æ•°ï¼‰ã€‚æœ‰äº†è¿™ä¸ªå‡½æ•°å°±å¯ä»¥åšåˆ°ä»¿çœŸä¸ç°å®æ—¶é—´çš„åŒæ­¥ã€‚ç”¨æ³•ç¤ºä¾‹å¯ä»¥å‚è€ƒæ—¶é—´æ¨è¿›æ³•
ç”±äºæ•´ä¸ªä»¿çœŸçš„æ ¸å¿ƒä¸ºæ—¶é—´ï¼Œå› æ­¤éœ€è¦å¯¹ä¹‹å‰æ²¡æœ‰è§„å®šçš„æ“ä½œè§„å®šå…¶éœ€è¦èŠ±è´¹çš„æ—¶é—´é•¿åº¦ã€‚åœ¨æ”¹è¿›çš„éƒ¨åˆ†ä¸­ï¼Œåˆé¢å¤–è€ƒè™‘äº†ä»¥ä¸‹æ“ä½œæ‰€è¦èŠ±è´¹çš„æ—¶é—´ï¼š è´§ç‰©å‡ºå…¥åº“æ‰€è¦èŠ±è´¹çš„æ—¶é—´
AGVä¸¾èµ·å’Œé™è½è´§æ¶æ‰€è¦èŠ±è´¹çš„æ—¶é—´`}]},{path:"/notes/web-ui.html",title:"ç”¨æˆ·ç•Œé¢ç®€ä»‹",pathLocale:"/",contents:[{header:"ç”¨æˆ·ç•Œé¢ç®€ä»‹",slug:"ç”¨æˆ·ç•Œé¢ç®€ä»‹",content:"MicroCity Webçš„æ€»ä½“ç•Œé¢å¦‚ä¸‹å›¾ï¼Œæœ¬æ–‡å°†è¯¦ç»†ä»‹ç»MicroCity Webçš„ç”¨æˆ·ç•Œé¢ï¼ˆUIï¼‰æ“ä½œã€‚"},{header:"ç•Œé¢åˆ†åŒºæ¦‚è§ˆ",slug:"ç•Œé¢åˆ†åŒºæ¦‚è§ˆ",content:`æ•´ä½“æ¥çœ‹ï¼ŒMicroCity Webçš„ç•Œé¢å¤§è‡´å¯ä»¥åˆ’åˆ†ä¸º4ä¸ªåŒºåŸŸã€‚ é¡¶éƒ¨-è“è‰²åŒºåŸŸï¼šå¯¹ä»£ç ã€æ–‡ä»¶æ‰§è¡Œå„ç§æ“ä½œ
å·¦ä¾§-ç»¿è‰²åŒºåŸŸï¼šä»£ç ç¼–è¾‘å™¨
å³ä¾§-çº¢è‰²åŒºåŸŸï¼šè§†å›¾åŒºåŸŸ
åº•éƒ¨-é»„è‰²åŒºåŸŸï¼šè¾“å‡ºä¿¡æ¯ã€è¯†åˆ«ç¨‹åºè¿è¡ŒçŠ¶æ€ ä¸‹é¢å°†è¯¦ç»†ä»‹ç»è¿™å‡ ä¸ªåŒºåŸŸçš„ç”¨æ³•å’ŒåŠŸèƒ½ã€‚`},{header:"è“è‰²åŒºåŸŸï¼šå‘½ä»¤",slug:"è“è‰²åŒºåŸŸ-å‘½ä»¤",content:`æ­¤åŒºåŸŸçš„çš„å†…å®¹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå…±æœ‰9ä¸ªå¯ç”¨æŒ‰é’®ã€‚ å…·ä½“åŠŸèƒ½ä¸ºï¼š ç¨‹åºæ§åˆ¶ å¼€å§‹è¿è¡Œ/debug
æš‚åœè¿è¡Œ
åœæ­¢è¿è¡Œ/å¼ºåˆ¶åœæ­¢ ä»£ç ç¼–è¾‘ æ˜¾ç¤ºç¼–è¾‘å™¨/éšè—ç¼–è¾‘å™¨
æ‰“å¼€ç¤ºä¾‹ä»£ç 
æ‰“å¼€æœ¬åœ°ä»£ç æ–‡ä»¶/ä¸Šä¼ æ–‡ä»¶åˆ°è™šæ‹Ÿç£ç›˜
ä¿å­˜ä»£ç /ä¸‹è½½ å…¶ä»– å…±äº«
æŸ¥çœ‹å¸®åŠ©æ–‡æ¡£`},{header:"ç¨‹åºæ§åˆ¶",slug:"ç¨‹åºæ§åˆ¶",content:"å‰3ä¸ªæŒ‰é’®çš„åŠŸèƒ½å¤§è‡´éƒ½ç”¨äºæ§åˆ¶ç¨‹åºè¿è¡Œã€‚è¯¦ç»†ä½œç”¨åˆ†åˆ«å¦‚ä¸‹ï¼š å¼€å§‹è¿è¡Œ/debug: å·¦é”®ç‚¹å‡»åå°†è¿è¡Œç½‘é¡µå·¦ä¾§ä»£ç ç¼–è¾‘å™¨å†…çš„ä»£ç ï¼›å³é”®ç‚¹å‡»åè¿›è¡Œä»£ç è°ƒè¯•ï¼ˆdebugï¼‰ æš‚åœè¿è¡Œ: å¦‚æœç¨‹åºæ­£åœ¨è¿è¡Œï¼Œç‚¹å‡»åç¨‹åºå°†æš‚åœè¿è¡Œï¼ˆå¦‚æœç¨‹åºæ”¯æŒï¼‰ã€‚ åœæ­¢è¿è¡Œ/å¼ºè¡Œåœæ­¢: å¦‚æœç¨‹åºæ­£åœ¨è¿è¡Œï¼Œå·¦é”®ç‚¹å‡»åç¨‹åºå°†åœæ­¢è¿è¡Œã€‚æœ‰æ—¶å­˜åœ¨å·¦é”®ç‚¹å‡»æ— æ³•åœæ­¢è¿è¡Œè„šæœ¬çš„æƒ…å†µï¼Œå³é”®ç‚¹å‡»å¯ä»¥å¼ºè¡Œç»ˆæ­¢å…¶è¿è¡Œã€‚"},{header:"ä»£ç ç¼–è¾‘",slug:"ä»£ç ç¼–è¾‘",content:`ç¼–å·4~7çš„æŒ‰é’®ä¸»è¦ä¸ä»£ç ç¼–è¾‘æœ‰å…³ã€‚ æ˜¾ç¤ºç¼–è¾‘å™¨/éšè—ç¼–è¾‘å™¨ï¼š å¦‚æœå·¦ä¾§çš„ä»£ç ç¼–è¾‘å™¨ä¸ºå¼€å¯çŠ¶æ€ï¼Œç‚¹å‡»è¿™ä¸ªæŒ‰é’®åå°†å…³é—­ã€‚å¦‚æœä¸ºå…³é—­çŠ¶æ€ï¼Œç‚¹å‡»åä¼šé‡æ–°æ‰“å¼€ã€‚å¦‚æœä½¿ç”¨å³é”®ç‚¹å‡»ï¼Œç¼–è¾‘å™¨å¯ä»¥å±•å¼€åˆ°å…¨å±çŠ¶æ€ã€‚ æ‰“å¼€ç¤ºä¾‹ä»£ç  å¯ä»¥ç›´æ¥è½½å…¥å†…ç½®çš„ä»£ç ï¼ˆå¯¼å…¥å†…ç½®æ¨¡å‹ï¼‰ï¼Œå¦‚ç«‹æ–¹ä½“ã€å¡è½¦ã€åœ°çƒã€ä¸–ç•Œåœ°å›¾ç­‰ã€‚å…·ä½“çš„æ¨¡å‹å°†åœ¨ä»‹ç»ç”»å¸ƒåŒºåŸŸæ—¶è¯¦ç»†ä»‹ç»ã€‚ å†…ç½®ä»£ç åˆ—è¡¨ æ‰“å¼€æœ¬åœ°ä»£ç æ–‡ä»¶/ä¸Šä¼ æ–‡ä»¶åˆ°è™šæ‹Ÿç£ç›˜
å·¦é”®ç‚¹å‡»ï¼šå¼¹å‡ºæ‰“å¼€æ–‡ä»¶çš„å¯¹è¯æ¡†ï¼Œæ‚¨å¯ä»¥é€‰æ‹©æœ¬æœºä¸Šçš„æŸä¸ªä»£ç æ–‡ä»¶(.lua)ã€‚ç¡®å®šæ‰“å¼€æ–‡ä»¶åï¼Œä»£ç æ–‡ä»¶æ–‡æœ¬å°†è‡ªåŠ¨å¯¼å…¥åˆ°å·¦ä¾§ä»£ç ç¼–è¾‘å™¨ä¸­ã€‚
å³é”®ç‚¹å‡»ï¼šå¯ä»¥é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶ä¸Šä¼ åˆ°MicroCity Webä¸­ã€‚å³é”®â€œä¿å­˜â€æŒ‰é’®(â‘¦)å¯ä»¥æŸ¥çœ‹å·²ä¸Šä¼ çš„æ–‡ä»¶åˆ—è¡¨ã€‚ ä¿å­˜ä»£ç /ä¸‹è½½
å·¦é”®ç‚¹å‡»ï¼šå½“æ‚¨ç¬¬ä¸€æ¬¡ä¿å­˜æ–‡ä»¶æ—¶ï¼Œç‚¹å‡»ä¿å­˜æŒ‰é’®åä¼šå¼¹å‡ºä¿å­˜æ–‡ä»¶å¯¹è¯æ¡†ï¼Œæ‚¨å¯ä»¥é€‰æ‹©ä¿å­˜ä½ç½®å¹¶å¡«å†™æ–‡ä»¶åã€‚å¦‚æœæ‚¨ä¹‹å‰å·²ç»å°†è¯¥æ–‡ä»¶ä¿å­˜åˆ°æœ¬åœ°ï¼Œè€Œæ­¤æ—¶æ‚¨åˆå¯¹è¯¥æ–‡ä»¶è¿›è¡Œäº†ä¿®æ”¹å¹¶æƒ³è¦ä¿å­˜æ›´æ”¹ï¼Œç›´æ¥ç‚¹å‡»ä¿å­˜æŒ‰é’®å³å¯ç›´æ¥å°†æ›´æ”¹ä¿å­˜åˆ°ä¹‹å‰ä¿å­˜çš„æ–‡ä»¶ä¸­ã€‚ æç¤º
æ–°ç‰ˆæœ¬çš„ MicroCity Web ä¼šå°†ä»£ç å’Œä¸Šä¼ çš„æ–‡ä»¶æ‰“åŒ…ä¸º .mw æ–‡ä»¶ã€‚
è¯¦ç»†å†…å®¹å¯ä»¥å‚è€ƒ æ–‡ä»¶ä¿å­˜ | è°ƒè¯•ç›¸å…³ å³é”®ç‚¹å‡»ï¼šå¯ä»¥æŸ¥çœ‹å·²ä¸Šä¼ åˆ°è™šæ‹Ÿç£ç›˜çš„æ–‡ä»¶åˆ—è¡¨ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»åˆ—è¡¨ä¸­çš„æ–‡ä»¶å¹¶ä¸‹è½½åˆ°æœ¬åœ°ã€‚`},{header:"å…¶ä»–",slug:"å…¶ä»–",content:`å…±äº«ã€‚ ç‚¹å‡»æŒ‰é’®åï¼Œå°†ä¼šå¼¹å‡ºä¸€ä¸ªè¾“å…¥å¯†ç çš„å¯¹è¯æ¡†ã€‚éšåï¼Œæ‚¨å°†ä¼šå¾—åˆ°ä¸€ä¸ªé“¾æ¥ï¼Œä»»ä½•äººéƒ½å¯ä»¥é€šè¿‡è¿™ä¸ªé“¾æ¥æ‰“å¼€æ‚¨çš„å…±äº«ã€‚
å¦‚æœæ‚¨åœ¨å¼¹å‡ºçš„å¯¹è¯æ¡†ä¸­è¾“å…¥äº†å¯†ç ï¼Œé‚£ä¹ˆåœ¨å…¶ä»–äººæ‰“å¼€é“¾æ¥åï¼Œä»–ä»¬åªèƒ½è¿è¡Œæ‚¨çš„ç¨‹åºä»£ç å¹¶è§‚å¯Ÿè¿è¡Œç»“æœï¼Œè€Œæ— æ³•æŸ¥çœ‹æ‚¨çš„ä»£ç ï¼ˆé™¤éæ‚¨å‘ŠçŸ¥ä»–ä»¬å¯†ç ï¼‰ï¼›å¦‚æœæ‚¨æ²¡æœ‰è¾“å…¥å¯†ç ï¼Œåˆ™å…¶ä»–äººä¸ä»…å¯ä»¥è¿è¡Œæ‚¨çš„ä»£ç æŸ¥çœ‹è¿è¡Œç»“æœï¼Œè¿˜å¯ä»¥æŸ¥çœ‹æ‚¨ç¼–å†™çš„ä»£ç ã€‚ æŸ¥çœ‹å¸®åŠ©æ–‡æ¡£ã€‚`},{header:"ç»¿è‰²åŒºåŸŸï¼šä»£ç ç¼–è¾‘å™¨",slug:"ç»¿è‰²åŒºåŸŸ-ä»£ç ç¼–è¾‘å™¨",content:"MicroCity Webå·¦ä¾§æ•´åˆçš„ä»£ç ç¼–è¾‘å™¨æºäºAceEditorï¼Œå› æ­¤ä¹Ÿå…·æœ‰AceEditorçš„ä¸€äº›ç‰¹æ€§ã€‚"},{header:"å¿«æ·é”®",slug:"å¿«æ·é”®",content:`ä¸‹é¢å°†ä»‹ç»ä¸€äº›å¸¸ç”¨çš„å¿«æ·é”®ï¼Œå¸®åŠ©ä½ æ›´å¥½åœ°ç¼–è¾‘ä»£ç ã€‚
æœ€å¸¸ç”¨ Ctrl+Zï¼šæ’¤é”€ è¡Œæ“ä½œ Ctrl+Dï¼šåˆ é™¤ä¸€è¡Œ
Ctrl+Shift+Dï¼šå¤åˆ¶ä¸€è¡Œ
Alt+â†‘ï¼šè¡Œä»£ç ä¸Šç§»
Alt+â†“ï¼šè¡Œä»£ç ä¸‹ç§» æŸ¥æ‰¾å†…å®¹ Ctrl+Kï¼šåœ¨ä»£ç ä¸­æŸ¥æ‰¾ä¸‹ä¸€ä¸ªä¸é€‰ä¸­å†…å®¹ ä»£ç ç¼©è¿› Ctrl+[ï¼šå¢åŠ ä»£ç ç¼©è¿›
Ctrl+]ï¼šå‡å°‘ä»£ç ç¼©è¿› ä¿®æ”¹æ•°å€¼ Ctrl+Shift+â†‘ï¼šå…‰æ ‡å‰çš„æ•°å­—æ•°å€¼+1
Ctrl+Shift+â†“ï¼šå…‰æ ‡å‰çš„æ•°å­—æ•°å€¼-1`},{header:"çº¢è‰²åŒºåŸŸï¼šç”»å¸ƒ",slug:"çº¢è‰²åŒºåŸŸ-ç”»å¸ƒ",content:"å¯ä»¥ä»å†…ç½®ä»£ç å¯¼å…¥åœºæ™¯ï¼Œè¯¦è§ å‘½ä»¤åŒºåŸŸ - ä»£ç ç¼–è¾‘ å¯¼å…¥åœºæ™¯ä»£ç åè¦ç‚¹å‡»â€œè¿è¡Œâ€æŒ‰é’®æ‰ä¼šè½½å…¥åœºæ™¯ å†…ç½®æ±½è½¦æ¨¡å‹ å†…ç½®åœ°çƒæ¨¡å‹"},{header:"åœºæ™¯æ“ä½œ",slug:"åœºæ™¯æ“ä½œ",content:`å¯¹åœºæ™¯çš„æ“ä½œåŒ…æ‹¬è§†è§’ç§»åŠ¨ã€æ—‹è½¬éƒ½éœ€è¦åœ¨ç”»å¸ƒåŒºåŸŸè¿›è¡Œã€‚å› æ­¤ï¼Œä¸‹é¢å°†ä»‹ç»ç”»å¸ƒåŒºåŸŸçš„åŸºæœ¬æ“ä½œã€‚ åœºæ™¯çš„æ”¾å¤§ç¼©å°ï¼šé¼ æ ‡æ»šè½®å‘ä¸Šæ»šåŠ¨ä¸ºæ”¾å¤§ï¼Œå‘ä¸‹æ»šåŠ¨ä¸ºç¼©å°ã€‚
å¹³ç§»ï¼šæŒ‰ä½é¼ æ ‡å³é”®æ‹–åŠ¨ã€‚
æ—‹è½¬ åœºæ™¯æ—‹è½¬ï¼šæŒ‰ä½é¼ æ ‡å·¦é”®æ‹–åŠ¨ï¼Œä»¥ä½ çš„è§†è§’è¿›è¡Œæ—‹è½¬
å¯¹è±¡æ—‹è½¬ï¼šç‚¹å‡»å¯¹è±¡ï¼Œå¯¹è±¡é¢œè‰²æ”¹å˜åä»å¯¹è±¡ä¸ŠæŒ‰ä½é¼ æ ‡å·¦é”®æ‹–åŠ¨ï¼Œä»¥å¯¹è±¡ä¸ºä¸­å¿ƒæ—‹è½¬ã€‚ æ— è®ºæ˜¯äºŒç»´å¯¹è±¡è¿˜æ˜¯ä¸‰ç»´å¯¹è±¡éƒ½éµå¾ªä¸Šè¿°æ“ä½œé€»è¾‘ã€‚`},{header:"é»„è‰²åŒºåŸŸï¼šä»£ç è¾“å‡º",slug:"é»„è‰²åŒºåŸŸ-ä»£ç è¾“å‡º",content:`æ‰“å¼€MicroCity Webåï¼Œä»£ç è¾“å‡ºåŒºåŸŸå¦‚ä¸‹ã€‚ç‚¹å‡»ä»£ç è¾“å‡ºåŒºåŸŸåæ•´ä¸ªåŒºåŸŸä¼šä¸Šç§»ï¼Œèƒ½å¤Ÿçœ‹åˆ°æ›´å¤šçš„å†å²è¾“å‡ºä¿¡æ¯ã€‚ è¯´åˆ°è¿™ä¸ªåŒºåŸŸè¾“å‡ºçš„ä¿¡æ¯ï¼Œä»£ç è¾“å‡ºåŒºåŸŸä¼šè¾“å‡ºä»¥ä¸‹ä¿¡æ¯ï¼š è„šæœ¬è¾“å‡º: å·¦ä¾§æ˜¯è„šæœ¬çš„è¾“å‡ºï¼ŒåŒ…å«è¾“å‡ºæ—¶é—´ã€è„šæœ¬è¾“å‡ºå†…å®¹ã€‚
è„šæœ¬è¿è¡ŒçŠ¶æ€: å³è¾¹ç¬¬ä¸€è¡Œä¸ºè„šæœ¬è¿è¡ŒçŠ¶æ€ã€‚state:ready è¡¨ç¤ºè„šæœ¬å·²ç»å‡†å¤‡å¥½å¼€å§‹è¿è¡Œï¼ˆæœªè¿è¡Œï¼‰ï¼Œstate:running è¡¨ç¤ºè„šæœ¬æ­£åœ¨è¿è¡Œã€‚
MicroCityWebç‰ˆæœ¬å·: è¡¨ç¤ºå½“å‰ä½¿ç”¨çš„MicroCityWebç‰ˆæœ¬å·ã€‚å¦‚æœä¸å·²çŸ¥ç‰ˆæœ¬æœ‰å·®å¼‚ï¼Œå¯ä»¥é€šè¿‡å¼ºåˆ¶åˆ·æ–°åŠ è½½æœ€æ–°ç‰ˆæœ¬ã€‚`},{header:"æ³¨æ„äº‹é¡¹",slug:"æ³¨æ„äº‹é¡¹",content:"å…³é—­è‡ªåŠ¨ç¿»è¯‘ï¼š å¦‚æœä½ çš„æ“ä½œç³»ç»Ÿè¯­è¨€ä¸æ˜¯è‹±è¯­ä¸”æµè§ˆå™¨å¼€å¯äº†è‡ªåŠ¨ç¿»è¯‘ï¼Œéœ€è¦æ‰‹åŠ¨å…³é—­ï¼Œå¦åˆ™ä»£ç è¿è¡Œå°†å‡ºç°é”™è¯¯ã€‚"}]},{path:"/images/doc/",title:"",pathLocale:"/",contents:[{header:"",slug:"",content:"This folder contains images used by documentation pages."}]},{path:"/en/docs/1.1_what_microcity_can_do.html",title:"1.1 What MicroCity can Do",pathLocale:"/en/",contents:[{header:"1.1 What MicroCity can Do",slug:"_1-1-what-microcity-can-do",content:"MicroCity is designed to be a handy spatial planning tool, which is portable, compact and fast."},{header:"A Modeling Framework",slug:"a-modeling-framework",content:"Based on GIS, Networks and Mixed Integer Programming libraries, MicroCity can be used as a modeling framework to solve transporation problems, such as City Logistics and Shipping Planning:"},{header:"A Simulation Platform",slug:"a-simulation-platform",content:"Based on 3D CGI and Discrete Event Simulation Engine, MicroCity can be used as a simulation platform to evaluate logistic scenarios, such as Automated Warehouses and Container Terminals:"},{header:"Customized by Scriptable Modules",slug:"customized-by-scriptable-modules",content:"MicroCity can extend its functionality with modules which can be inherited from SAGA or scripted and debugged in Script Editor: Currently, MicroCity is mainly used in teaching and research. It can be freely distributed."}]},{path:"/en/docs/2.1_showing_a_world_map.html",title:"2.1 Showing a World Map",pathLocale:"/en/",contents:[{header:"2.1 Showing a World Map",slug:"_2-1-showing-a-world-map",content:"This tutorial will guide you in manipulating and visualizing GIS data in MicroCity."},{header:"Loading Data and Creating a Map",slug:"loading-data-and-creating-a-map",content:"Download the countries.shp (ArcGIS shapefile) and the countries.dbf (dBase file) in a same folder. Open MicroCity and load or drag the countries.shp into MicroCity and select Data Tab in Workspace panel. Double click Data->Shapes->Polygon->01. countries in Workspace panel."},{header:"Visualizing Coutries' Properties",slug:"visualizing-coutries-properties",content:"Right click 01. countries in the Workspace panel. Click Attributes->Table->Show in the popup menu. In the Settings Panel, find the Colors->Type option and select Graduated Color. In its sub-option Attribute, select POP_EST which is population property of countries. In the Setting Panel, find the Chart option and click the ... button. In the popup dialog, select pie in Chart Type option and select GDP_MD_EST in Attribute (Size) option and select EXPORT and IMPORT checkboxs in Fields option and click Okay button."},{header:"Editing Shapes",slug:"editing-shapes",content:"Select Action button at toolbar. Left click some country and right click it and select Edit Selected Shape in the popup menu. Then the shape will be in editing mode. You can change its polygon points and finish your editing by right click and select Edit Selected Shape again."}]},{path:"/en/docs/2.2_searching_for_countries.html",title:"2.2 Searching for Countries",pathLocale:"/en/",contents:[{header:"2.2 Searching for Countries",slug:"_2-2-searching-for-countries",content:"This tutorial will guide you in coding with MicroCity Script to manipulate GIS data. You have to complete 2.1 to proceed."},{header:"GIS Data Structure",slug:"gis-data-structure",content:"In MicroCity, GIS data consists of three types of Shapes: Point, Polyline and Polygon, each of which can be visualized as a Map Layer. In a layer, a Shape object consists of one or more Parts, and every Part consists of one or more Points. A Shape object is also associated to a record in the Attributes Table. You can also edit the shape or its attributes (see 3.2). If you want perform a complex editing or handle a batch of shapes, you can use MicroCity Script, in which many built-in functions can be used."},{header:"Making a Query",slug:"making-a-query",content:`Suppose we want to find countries, each of which has a population of more than 100 million and is entirely in the northern hemisphere. So we need to check every point's coordinate in each shape and the population attribute of the shape. Open ScriptEditor and type following codes:
local Countries = Open("countries.shp") --Try to open the shapes layer
for i = 1, GetRecCount(Countries) do --Loop all the shape objects in the layer local country = GetShape(Countries, i) --Get the shape object of a country local north = true --Assume the country is in the northern hemisphere for j = 1, GetPartCount(country) do --Loop all of the parts in the shape for k = 1, GetPointCount(country, j) do --Loop all of the points in the shape part local x, y = GetPointXY(country, k, j) --Get coordinate of the point j if y < 0 then --If the latitude is less than 0 north = false --The north assumption is false end end end local pop = GetValue(country, "POP_EST") --Get the population property local name = GetValue(country, "NAME") --Get the country name if pop > 100000000 and north then --Check the two conditions Print(name, ": ", pop/100000000) --Print out the result end
end`},{header:"Running the Script",slug:"running-the-script",content:"Save the script to query.mcs and open it with MicroCity or drag it to MicroCity. Then you will find a query item appears in Modules Tab in Workspace panel. Double click the sub-item main. If a dialog pops up, select 01. countries and click Okay. The results will be shown in Messages panel."}]},{path:"/en/docs/3.1_ui_overview.html",title:"3.1 UI Overview",pathLocale:"/en/",contents:[{header:"3.1 UI Overview",slug:"_3-1-ui-overview",content:"MicroCity provides a concise graphic windowed interface to facilitate the manipulation of data and modules."},{header:"The Main Window and Components",slug:"the-main-window-and-components",content:""},{header:"Supported Files",slug:"supported-files",content:"MicroCity can open ArcGIS shapefile (*.shp), Grids file (*.sgrd), dBase file (*.dbf), Tabular text file (*.csv, *.txt), Point clouds (*.spc), Image file (*.bmp, *.gif, *.jpg, *.png, *.tif, *.pcx) and MicroCity 3D Scene (*.m3d). These data files are maintained in the Data Tab of the Workspace Panel. Module libraries (*.dll, *.mcs) are maintained and executed through the Modules Tab of the Workspace Panel."},{header:"Project Management",slug:"project-management",content:"The information of opened data files, module libraries, settings and sub-windows can be saved or opened in a MicroCity Project (*.mprj) through the menu File->Project. The mprj file does not contain any file's data. For easy maintenance, files in a project should be put into the same folder or sub-folders of the mprj file."}]},{path:"/en/docs/3.2_vector_shapes.html",title:"3.2 Vector Shapes",pathLocale:"/en/",contents:[{header:"3.2 Vector Shapes",slug:"_3-2-vector-shapes",content:"MicroCity can open, create and edit ArcGIS shapefiles (*.shp) which are called Shapes and maintained in the Data Tab of the Workspace Panel. By using modules (see 3.7) other vector file formats, such like Scalable Vector Graphics (*.svg) and AutoCAD Drawing Exchange Format (*.dxf), can also be imported or exported."},{header:"Opening, Creating, Saving and Closing Shapes",slug:"opening-creating-saving-and-closing-shapes",content:"Users can click Load button or File->Shapes->Load menu item to open an ArcGIS shapefile (*.shp) as a Shapes. Creating a new Shapes can be done from menu File->Shapes->New and the pop-up dialog as shown below. Users can choose one shapes type from Point, Line and Polygon. The relationship between a ArcGIS shapefile (*.shp) and a same named dBase file (*.dbf) is also shown. Saving a Shapes can be done from the right click context menu Save or Save As. You can also close a Shapes from the menu and get a prompt dialog to save it."},{header:"Showing and Editing Shapes",slug:"showing-and-editing-shapes",content:"Double click a Shapes from the Data Tab will give you a map view (for maps and layers see 3.6). Toggle Action botton and right click a Shape in a Shapes layer and choose Edit Selected Shape then go to the Editing Mode. In this mode users can add/delete parts and add/delete points in a shape (for data structure of a shape see 2.2). The associated attributes table (*.dbf) of a Shapes can be accessed through right-clicking context menu Attributes->Table->Show (see the tutorial 2.1)."},{header:"Display Settings and Data Visualization",slug:"display-settings-and-data-visualization",content:"Users can change Shapes outline, fill, labels and other display settins from the Settings Panel. Some options can connect attribute data and give visualization functionalities (for example 2.1)."}]},{path:"/en/docs/3.3_raster_grids.html",title:"3.3 Raster Grids",pathLocale:"/en/",contents:[{header:"3.3 Raster Grids",slug:"_3-3-raster-grids",content:"MicroCity can open, create and edit SAGA Grid (*.sgrd) which is called Grid and maintained in the Data Tab of the Workspace Panel. Image files (*.bmp, *.gif, *.jpg, *.png, *.tif, *.pcx) can be opened as Grid as well. By using modules (see 3.7) other raster file formats, such like ESRI Arc/Info Grid (*.adf) and Surfer Grid (*.grd), can also be imported or exported."},{header:"Opening, Creating, Saving and Closing Grids",slug:"opening-creating-saving-and-closing-grids",content:`Users can click Load button or File->Grid->Load menu item to open a Grid. Creating new Grid can be done from menu File->Grid->New and the pop-up dialog: The above right figure is the data structure and definitions of a Grid. A Grid starts from its bottom left corner which has coordinate (xMin, yMin), contains NX*NY Square Cells. Each cell has its own Integer Coordinate (X, Y), in the range of (0, 0) to (XMax, YMax).
Saving Grid can be done from the right click context menu Save or Save As. You can also close a Grid from the menu and get a prompt dialog to save it.`},{header:"Showing and Editing Grids",slug:"showing-and-editing-grids",content:"Double click a Grid from the Data Tab will give you a map view (for maps and layers see 3.6). Toggle Action botton and select a range of cells in a Grid. Then the value of these cells can be edited in the Attributes Tab of the Settings Panel."},{header:"Display Settings and 3D View",slug:"display-settings-and-3d-view",content:"Users can show cell values, change color and set transparency of a Grid by using Settings Panel. Using button can creat a 3D surface of a Grid in which cell values are translated to elevation (see 3.6)."}]},{path:"/en/docs/3.4_3d_scenes.html",title:"3.4 3D Scenes",pathLocale:"/en/",contents:[{header:"3.4 3D Scenes",slug:"_3-4-3d-scenes",content:"MicroCity 3D Scene (*.m3d) is a data file format to store 3D scenes' information. Popular 3D file formats including 3D Studio Max (*.3ds), Wavefront OBJ (*.obj) and Stereolithography (*.stl) can be loaded as objects in a scene (see below) but not be stored in the .m3d file."},{header:"Opening, Creating, Saving and Closing 3D Scenes",slug:"opening-creating-saving-and-closing-3d-scenes",content:"Users can click Load button or File->Scene->Load menu item to open a Scene. Creating new Scene can be done from menu File->Scene->New and fill the pop-up dialog as shown below. After pressing Okay button an item will appear in the Data Tab of the Workspace Panel. Then Scene can be saved or closed through right-click menu:"},{header:"Showing and Editing 3D Scenes",slug:"showing-and-editing-3d-scenes",content:"Double click a Scene from the Data tab will give you a scene view. Left-mouse-dragging in a scene veiw will rotate the camera and right-mouse-dragging will translate the camera. Double-left-clicking a scene view can select objects and Double-right-clicking a scene view can popup a context menu (shown below). One can add objects, load objects and set objects, etc.. Note that the Rotation in the coordinate system should obey Left-hand rule. The illustration of the coordinate system and an example of the rotation around y-axis is shown below: The coordinate used in the position and rotation of an object is relative to its parent object. By default, the parent of a new object is null."},{header:"Display Settings",slug:"display-settings",content:"Users can change the background color, reference grid or other display options of a Scene by using Settings Panel."}]},{path:"/en/docs/3.5_tables.html",title:"3.5 Tables",pathLocale:"/en/",contents:[{header:"3.5 Tables",slug:"_3-5-tables",content:"Tabular files including dBase files (*.dbf), Text file (*.txt) and Comma Separated Values (*.csv) can be opened as Table and saved with MicroCity."},{header:"Opening, Creating, Saving and Closing Tables",slug:"opening-creating-saving-and-closing-tables",content:"Users can click Load button or File->Table->Load menu item to open a tabular file. Creating a new Table can be done from menu File->Table->New and the pop-up dialog as shown below. Saving a Table can be done from the right click context menu Save or Save As."},{header:"Showing and Editing Tables",slug:"showing-and-editing-tables",content:`Double click a Table from the Data Tab will give you a table view. Altering a table's stucture can be done by right click the table's head. If you click "Add Field" then, a dialog which guide you (as shown below). If you want insert a record to the table, you can right click the left numbers of the table and select a context menu item.`}]},{path:"/en/docs/3.6_maps_and_layers.html",title:"3.6 Maps and Layers",pathLocale:"/en/",contents:[{header:"3.6 Maps and Layers",slug:"_3-6-maps-and-layers",content:"In MicroCity, Shapes and Grids can be showed in Maps. Each map may contains multiple layers and each layer is corresponding to a Shapes or a Grid."},{header:"Opening, Creating, Saving, Printing and Closing Maps",slug:"opening-creating-saving-printing-and-closing-maps",content:"Because Maps are based on Shapes and Grids, they can not be saved or opened independently, but can be saved or opened along with a MicroCity Project (*.mprj). Creating a Map is by double clicking a Shapes or Grid from the Data Tab of the Workspace Panel. A Map window contains four coordinate bars which can be used to locate objects (see below). A Map can also be printed or closed from the context menu of the Maps Tab of the Workspace Panel."},{header:"Adding, Moving, Hiding and Closing Layers in a Map",slug:"adding-moving-hiding-and-closing-layers-in-a-map",content:"A Map can have multiple Layers, each of them represents a data item. One can add a Layer to a Map by double clicking a Shapes or a Grid from the Data Tab. A lower layer can be obscured by upper layers. One can move a layer by dragging, hide a layer by double clicking and close a layer through the menu (as shown below)."},{header:"Controlling Map Views",slug:"controlling-map-views",content:`When a data item or a layer is selected, this layer is called the active layer. One can toggle the Action button to select and edit an object in the active layer. By toggling the Zoom or Pan botton, the map can zoomed in, zoomed out or panned. If one lose in a map, he can use the Zoom to Full Extent button to get a full view of the map. Other zoom controlling buttons can be used to facilitate the map browsing.
The Synchronise button can be used if you want compare difference between two or more maps. The Ruler button can be used to meassure distances. Note that, by default, the unit of the distances measured is kilometer under the coordinate system of Earth. One can change the coordinate system to Non-Earth from the Settings Panel of the Map, and get Cartesian distance without unit.
One can create a 3D surface map by clicking 3D button, which need a appropriately sized Grid (see 3.3).`}]},{path:"/en/docs/3.7_modules.html",title:"3.7 Modules",pathLocale:"/en/",contents:[{header:"3.7 Modules",slug:"_3-7-modules",content:"The functionality of MicroCity can be extended by modules, one type of which is SAGA Module (*.dll). SAGA Modules contains many useful libraries for Shapes and Grids. Another type of Module is MicroCity Script (*.mcs), which can be edited and debugged with ScriptEditor (see 4.1)."},{header:"Loading, Closing and Executing Modules",slug:"loading-closing-and-executing-modules",content:"Modules can be loaded to MicroCity by clicking Load button or Modules->Load Module Library menu item. The Modules Tab of the Workspace Panel will display the loaded Libraries (each of which corresponding to a file) and their inside Modules . One can close or reload a Module Library from the context menu. Executing a moule has many ways: double clicking it, clicking the Execute button from the Settings Panel, or click the Execute context menu item. One can also Debug a MicroCity Script module by clicking the Debug context menu item, that needs the ScriptEditor running in the background. MicroCity can also capture runtime errors and pause the execution of modules."},{header:"Accelerating, Stopping the Execution of a Module",slug:"accelerating-stopping-the-execution-of-a-module",content:`MicroCity Script module is created with Lua language which is very fast. In some cases, if you want much more faster execution speed, you can click the Module Libraries in the Modules Tab of the Workspace Panel and switch the Script Running Mode in the Settings Panel from the Safe Mode to the Fast Mode. Then MicroCity will use LuaJIT to execute modules.
If a module is being executed, one can stop it by click the Execute button in the corresponding Settings. In Safe Mode the execution can be immediately stopped, but in Fast Mode the stopping is depend on the GetReady() function called in the script (see 4.2.`}]},{path:"/en/docs/4.1_si_overview.html",title:"4.1 SI Overview",pathLocale:"/en/",contents:[{header:"4.1 SI Overview",slug:"_4-1-si-overview",content:"MicroCity uses Modules (see 3.7) to extend its functionalities. One type of the modules is MicroCity Script (*.mcs) which can be edited and debugged in the ScriptEditor."},{header:"The Script Editor",slug:"the-script-editor",content:""},{header:"Coding and Debugging MicroCity Scripts",slug:"coding-and-debugging-microcity-scripts",content:"ScriptEditor is based on ZeroBrane. One can find detailed information there. For debugging, you should keep Script Editor being opened. Then right click the module from MicroCity and choose Debug item in the context menu (see 3.7). The execution can be indicated in the Code View of ScriptEditor. You can control the execution and watch variables with Debug Buttons."},{header:"The Lua Language and Embedded Functions",slug:"the-lua-language-and-embedded-functions",content:`MicroCity uses Lua 5.1 as its script language. One can find the reference manual there. MicroCity embeds many useful funtions in Lua, which can not only control user interfaces, manipulate data, but also can solve mathematical models and run simulations. You should read following chapters for more information.
Conventions in this reference:
There are four major data types in Lua can be passed though embedded functions as parameters, namely Number, Boolean, String and Object. The type Object includes builtin Lua objects, such as Table, Function adn Thread..., as well as MicroCity objects, such as Shapes, Grid, Table and Scene.... To clarify the parameter type in embedded functions, we use capitalization, quotation mark and semantic information to avoid ambiguities in function descriptions. A lowercase word of a paramter means a Number. Sometimes, to present an integer parameter, a letter 'i' followed by a word is used, like iField. Starting with the letter 'b' and followed by a word means a Boolean, like bShow. A quoted word means a String. A capitalized word means an Object or a keyword. Following is an example of a embedded function description.
AddParameter (Module, ParentNode, "Value", "id" [, default = 0])
In this case, the Module parameter should be a Module object. The ParentNode parameter should be a Node object, but it act as a parent Node. The "Value" parameter is a string, but it represent the builtin type Value in MicroCity, so this string can not be changed. The "id" parameter should be a user specified string. The default parameter is a number. The contents in a pair of '[' and ']' are optional. The character '|' among parameters means "or".
Encoding formats:
MicroCity uses ANSI encoding format to read and write data, such as shp, txt, csv and dbf. ScriptEditor and the embedded funtions use UTF-8 encoding format to read and write data, such as txt or csv.`}]},{path:"/en/docs/4.2_ui_control.html",title:"4.2 UI Control",pathLocale:"/en/",contents:[{header:"4.2 UI Control",slug:"_4-2-ui-control",content:'Microcity Script can be used to control some features appearing in user interfaces, which include moduels, data objects, messages and so on. There are some sample codes can be found in the "user_interface" folder of the Project Tab in ScriptEditor.'},{header:"Basic User Interfaces",slug:"basic-user-interfaces",content:`Print ("hello" [,...])
Prints values in the Messages Panel.
Note ("hello" [,...])
Notifies users and pauses the execution.
SetProcessText ("processing")
Sets a text at the bottom left corner of MicroCity.
SetProgress (position, range)
Sets the progress bar of position/range that locates at the bottom right conner of MicroCity.
Sleep (milliseconds)
Pauses the execution for milliseconds.
GetReady ()
MicroCity shares the same thread with the lua engine. Heavy calculations in lua will block the MicroCity interface. Use this function inside can let the MicroCity interface respond to user operations. Returns false if user cancel the current execution.
GetClickXY ()
Returns x,y where a user clicked at a Map View.
GetDragExtent ()
Returns bottom-left and top-right corner coordinate: Lx, By, Rx, Ty, which a user used mouse to drag a rectangle in a Map View.`},{header:"Data Objects",slug:"data-objects",content:`PATH
Internal global variable that holds a string of current working directory, such as "c:\\microcity".
Open (".\\\\shapes.shp" [, ".\\\\grid.sgrd" [, ".\\\\table.dbf" [, ".\\\\scene.m3d" , ...]]])
Opens and returns Shapes, Table, Grid and Scene object from current working directory or opened data.
Close (Shapes|Grid|Table|Scene|Network|RndEngine|LPModel)
Closes an opened or created Shapes, Table, Grid, Scene, Network, RndEngine or LPModel object.
Update (Shapes|Grid|Table [, bShow = ture])
Update current changes of Shapes, Grid or Table object in MicroCity. The bShow indicates whether to create a view of the object. Returns false if user cancel the current execution.
CreateMap ("name", Shapes1|Grid1 [, Shapes2|Grid2, ...])
Creates a Map View to show objects which can be arranged in layers by their order in the parameters.`},{header:"Modules and Parameters",slug:"modules-and-parameters",content:`AddModule ("Function" [, "name"]) This function can add a lua function as a module to current module library. The module's default name is the function's name. Returns a Module object.
AddParameter (Module, ParentNode, "Node", "id")
AddParameter (Module, ParentNode, "Value", "id" [, default = 0])
AddParameter (Module, ParentNode, "Range", "id" [, low = 0 [, high = 1]])
AddParameter (Module, ParentNode, "Check", "id" [, default = 0])
AddParameter (Module, ParentNode, "String", "id" [, "string" = "")
AddParameter (Module, ParentNode, "Choice", "id" [, "choice1|choice2|" [, choice = 1]])
AddParameter (Module, ParentNode, "File", "id" [, "c:\\\\default.txt" = ""])
AddParameter (Module, ParentNode, "Color", "id" [, "color" = "255 255 255")
AddParameter (Module, ParentNode, "Shapes", "id")
AddParameter (Module, ParentNode, "Grid", "id")
AddParameter (Module, ParentNode, "Scene", "id")
AddParameter (Module, ParentNode, "Table", "id")
AddParameter (Module, ParentNode, "Field", "id")
These functions can add a parameter to a module's settings panel. Returns corresponding values or an object. The ParentNode can be set to the first return of a AddParameter function. If "Field" is set at the third place, the parent_node can be set to a Table or Shapes object to get its attributes table's head.
GetParameter (Shapes|Table|Grid|Scene|Module, "id")
Returns the parameter specified by "id" from the object's settings panel.
SetParameter (Shapes|Table|Grid|Scene|Module, "id", Number|"String"|Object)
Sets the parameter specified by "id" in the object's settings panel. Returns true if succeed. Note that the choice parameter should start from 1. A parameter's "id" can be found in the parameter's helper text shown as below.`}]},{path:"/en/docs/4.3_shapes_and_tables.html",title:"4.3 Shapes and Tables",pathLocale:"/en/",contents:[{header:"4.3 Shapes and Tables",slug:"_4-3-shapes-and-tables",content:'Users can manipulate Shapes and Tables with MicroCity Script. For detailed data structure of Shapes, you can refer to previous chapter 2.2 and 3.2. Because Shapes can be treated as Tables with extra field with geographic data, some of embeded functions for tabular data manipulation can be used both in Shapes and Tables. Sample codes for this chapter can be found in the "shapes_samples" folder of the Project Tab in ScriptEditor.'},{header:"Tabular Data Manipulation",slug:"tabular-data-manipulation",content:`CreateShapes ("name", "Point|Line|Polygon")
Returns a Shapes object.
CreateTable ("Name")
Returns a Table object.
GetFieldCount (Shapes|Table)
Returns the number of fields in a Shapes or Table
GetField (Shapes|Table, iField)
Inputs the index (starts from 1) of a field and returns the field name and type ("Int", "Float", "Double" or "String).
AddField (Shapes|Table, "field1", "Int|Float|Double|String" [, "field2", "Int|Float|Double|String", ...])
Adds fields to a *Table or Shapes and returns booleans (true or false) by order.
DelField (Shapes|Table, iField)
Returns true if successfully delete a field.
GetRecCount (Shapes|Table)
Returns the total number of records in a Shapes or Table.
AddRecord (Shapes|Table)
Adds a record to a Shapes or Table and returns the index.
GetValue (Shapes|Table, "field_name", index1 [, index2, ...])
Retrieve values from a specified field and indexes of a Shapes or Table. Returns multiple values by the order of indexes.
SetValue (Shapes|Table, value, "field_name", index1 [, index2, ...])
Sets values for a specified field and indexes of a Shapes or Table.`},{header:"Geographic Data Manipulation",slug:"geographic-data-manipulation",content:`GetSelections (Shapes)
Returns selected shape objects from a Shapes.
GetShape (Shapes, index1 [, index2, ...])
Returns Shape objects from a Shapes by the order of indexes.
AddShape (Shapes, Shape)
Adds a Shape object to a Shapes and returns its index.
AddShape (Shapes [, x1, y1, x2, y2, ...])
Adds a Shape object to a Shapes which defined as points. Returns the Shape object and index.
DelShape (Shape|Shapes)
Deletes a Shape or Shapes object and returns ture if successful.
AddPoint (Shape, x, y [, iPart = 1])
Adds a point to a Shape and returns ture if successful.
InsPoint (Shape, x, y [, iPoint = 1 [, iPart = 1]])
Inserts a point to a Shape and returns ture if successful.
SetPoint (Shape, x, y [, iPoint = 1 [, iPart = 1]])
Sets a point coordinates in a Shape and returns ture if successful.
DelPoint (Shape, iPoint [, iPart=1])
Deletes a point at position iPoint from a Shape and returns ture if successful..
DelPart (Shape, iPart)
Deletes a part from a Shape and returns ture if successful.
GetPartCount (Shape)
Returns the number of parts in a Shape.
GetPointCount (Shape [, iPart])
Returns the number of points in a Shape.
GetPointXY (Shape [, iPoint [, iPart = 1]])
Returns all points' coordinates: x1, y1, x2, y2, ... from a Shape or a specified point's coordinate.
CopyShapeTo (TargetShapes, dx, dy, Shape1 [, Shape2, ...])
Copys Shape objects to a target Shapes with relative translation (dx, dy) and returns new Shape objects.
MoveShapeTo (dx, dy, Shape1 [, Shape2, ...])
Translates Shape objects to its relative position (dx, dy).
GetCenterXY (Shapes)
Returns the center coordinate (x, y) of a Shapes.
GetCenterXY (Shapes, index1 [, index2, ...])
Returns the center coordinates (x1, y1, x2, y2, ...) of Shape objects specified by indexes in a Shapes.
GetCenterXY (Shape1 [, Shape2, ...])
Returns the center coordinates (x1, y1, x2, y2, ...) of Shape objects.
GetDistance (x1, y1, x2, y2 [, x3, y3, ...])
Returns the total distance between every two pairs of coordinates (x, y).
GetShapeLen (Shape1 [, Shape2, ...])
Returns lengths of Shape objects.
GetShapeArea (Shape1 [, Shape2, ...])
Returns areas of Shape objects.
GetShapeType (Shape|Shapes)
Returns the type ("Point", "Line" or "Polygon") of the a Shapes or Shape object.
GetExtent (Shapes)
Returns the extent coordinates (Lx, By, Rx, Ty) of a Shapes's extent.
GetExtent (Shapes, index)
Returns the extent coordinates (Lx, By, Rx, Ty) of a Shape indexed in a Shapes.
GetExtent (Shape)
Returns the extent coordinates (Lx, By, Rx, Ty) of a Shape.
GetIntersection (ShapeA, ShapeB)
Returns a Shape (Point, Line or Polygon) object of the intersection of two Shapes.
GetValue (Shape, "field_name")
Returns the value of specified field of a Shape.
SetValue (Shape, value1, "field_name1" [, value2, "field_name2", ...])
Sets values in different fiedds for a Shape.
SetCoorSys ("Earth"|"Non-Earth")
Sets coordinate system. If using "Earth", distances, lenths and areas are calculated according to the earth ellipsoid coordinate system. By default the "Non-Earth" is used, which is cartesian coordinate system.`}]},{path:"/en/docs/4.4_grids.html",title:"4.4 Grids",pathLocale:"/en/",contents:[{header:"4.4 Grids",slug:"_4-4-grids",content:'Grids in MicroCity have simple structure (3.3) but efficient time and space utilization if applying algorithms on them. Sample codes for this chapter can be found in the "grid_samples" folder of the Project Tab in ScriptEditor.'},{header:"Cellular Data Manipulation",slug:"cellular-data-manipulation",content:`CreateGrid ("name", "Int|Float|Double", XMax, YMax [, CellSize = 1 [, xMin = 0 [, yMin = 0] [, init = 0]]]])
Returns a Grid object.
GetCellSize (Grid)
Returns the Cellsize value of a Grid.
GetGridMaxXY (Grid)
Returns XMax, YMax of a Grid.
ConvertToGridXY (Grid, x1, y1 [, x2, y2, ...])
Converts real coordinates to coordinates in a Grid. Returns X1, Y1, X2, Y2, ... .
ShapeToGrid (Grid, Shape, value)
Rasterizes a Shape in a Grid. The cell values will be set according to the covering area and the inputed value.
ShapeToGrid (Grid, Shapes, "field_name")
Rasterizes all Shape objects in a Shapes. The cell values will be set according to the covering area and the values of Shapes field.
GetValue (Grid, X1, Y1 [, X2, Y2, ...])
Returns cells' (specified by Grid coordinates) values: value1, value2, ... .
SetValue (Grid, value, X1, Y1 [, X2, Y2, ...])
Sets values for cells specified by Grid coordinates.
GetCenterXY (Grid)
Returns the center real coordinate (x, y) of a Grid.
GetCenterXY (Grid, X1, Y1 [, X2, Y2, ...])
Returns the real coordinates of cells' centers: x1, y1, x2, y2, ... .
GetExtent (Grid)
Returns the leftbottom and righttop corner of a Grid's extent: Lx, By, Rx, Ty.
GetExtent (Grid, X, Y)
Returns the leftbottom and righttop corner of a cell's extent: Lx, By, Rx, Ty.
GetFractalDim (Grid, X1, Y1, X2, Y2, fold [, MultiFractalQ = 0])
Calculates fractal dimension of the specified area in a Grid. Returns dimension, RSQ of linear regression, and the number of boxes in every fold.`}]},{path:"/en/docs/4.5_3d_scenes.html",title:"4.5 3D Scenes",pathLocale:"/en/",contents:[{header:"4.5 3D Scenes",slug:"_4-5-3d-scenes",content:'Scenes and inside 3D objects (3.4) can be scripted. Sample codes for this chapter can be found in the "3d_samples" folder of the Project Tab in ScriptEditor.'},{header:"3D Scene and Object Manipulation",slug:"_3d-scene-and-object-manipulation",content:`CreateScene ("Title" [, RotSpeed=1] [, TransSpeed=1])
Creates a new 3d scene and returns the object.
AddZipTo3DPath (Scene, "filename.zip")
Adds a zip file to the search directory and returns true if succeed. It is useful for collecting a large amount of files.
LoadSkybox (Scene, "top.jpg" ,"bottom.jpg" ,"left.jpg" ,"right.jpg" ,"front.jpg" ,"back.jpg")
Loads six image files as the skybox of a 3d scene.
LoadObject (Scene, "filename.3ds" [,shadow = false [, AnimationSpeed]])
Loads a 3d object from a file and returns the object.
AddLight (Scene, x, y, z, Radius [, r = 255, g = 255, b = 255])
Adds a light object and returns the object.
Add3DLabel(Scene, "label" [, width=10, height=10 [, r = 180, g = 180, b = 180 [, "font.xml"]]])
Adds a 3D label at (0,0,0) and returns the object.
Add3DLine (Scene, x1, y1, z1, x2, y2, z2 [, r = 0, g = 0, b = 0])
Adds a 3D line object frome (x1, y1, z1) to (x2, y2, z2) and retruns the object.
Add3DRect (Scene, length, width [, r = 180, g = 180, b = 180])
Adds a 3D rectangular object from (-length/2,0,-width/2) to (length/2,0,width/2) and returns the object.
Add3DBox (Scene, length, width, height [, r = 180, g = 180, b = 180 [, bShowEdge = true]])
Adds a 3D box object from (-length/2,-height/2,-width/2) to (length/2,height/2,width/2) and returns the object.
AddSphere (Scene, radius [, polycount = 16 [, r = 180, g = 180, b = 180]])
Adds a sphere at (0,0,0) and returns the object. If the radius parameter is less than 0, returns an invisible object.
GetTexture (Object)
Returns the texture files of a object: "filename1", "filename2", ... .
LoadTexture (Scene, Object, "filename1" [, "filename2", ...])
Loads texture files to an object.
SetPosition (Object, x, y, z [, absolute = false])
Sets the position of an object relative to its parent (or the absolute position to the scene).
GetPosition (Object [, absolute = false])
Gets the position of an object relative to its parent (or the absolute position to the scene).
SetRotation (Object, rx, ry, rz [, absolute = false])
Sets the rotation (left hand rule) of an object in degrees relative to its parent (or the absolute rotation to the scene).
GetRotation (Object [, absolute = false])
Gets the rotation (left hand rule) of an object in degrees relative to its parent (or the absolute rotation to the scene).
SetScale (Object, sx, sy, sz)
Sets the scale of an object.
GetScale (Object)
Gets the scale of an object.
SetParent (Object, Parent)
Attaches an object to another object as a child.
GetParent (Object)
Gets the parent of an object.
SetObject (Object "id" [,x, y, z, [,rx, ry, rz [,sx, sy, sz]]])
Sets the ID, position, rotation and scale of an object.
DelObject (Object)
Deletes an object.
SetCamera (Scene, x, y, z [,Tx, Ty, Tz])
Sets the position and target of the scene camera.
GetCamera (Scene)
Gets the camera object of a 3d scene and its position and targt.
GetSelections (Scene)
Returns selected objects from a 3d scene.
GetObjectID (Object1 [, Object2, ...])
Returns "id"s of objects.
SetObjectID (Object, "id")
Sets the id of an object.
GetObject (Scene, "id")
Finds an object by its id.`}]},{path:"/en/docs/4.6_networks.html",title:"4.6 Networks",pathLocale:"/en/",contents:[{header:"4.6 Networks",slug:"_4-6-networks",content:'GIS vector data (3.2) in MicroCity can be topologized to Networks and applied the Shortest Path Algorithm and User Equilibrium Traffic Assignment Algorithm. Sample codes for this chapter can be found in the "network_samples" folder of the Project Tab in ScriptEditor.'},{header:"Network Manipulation",slug:"network-manipulation",content:`CreateNetwork ()
Creates an empty network and returns the object.
CreateNetwork (UnTopoLines)
Creates a network from an untopologized "line" Shapes and returns three objects: Network, Nodes (Shapes) and Links (Shapes).
CreateNetwork (Nodes, Links)
Creates a Network object from topologized Nodes and Links Shapes. Returns the Network object.
InitNetwork (Network, Nodes, Links)
Initiates a Network from a Nodes and a Links Shapes. Returns true if succeed.
AddLink (Network, linkID|-1, oID|-1, dID|-1, impedance [, direction = 1 [, capacity = 1E+38]])
Adds a new link or update an existing link in the Network. Returns linkID, oID, dID, true/false for adding and true/false for updating.
AddLink (Network, Shapes|Table, index1 [, index2, ...])
Adds or updates links from the recordset of a Shapes or Table. Returns boolean values.
DelLink (Network, linkID)
Deletes a link from a Network. Returns a boolean value.
GetNearNodeID (Network, x, y [, radius=nil])
Gets the nearest Network nodes from a coordinate. Returns node ids.
GetNodeXY (Network, nodeID1 [, nodeID2, ...])
Returns the coordinates of nodes in a Network: x1, y1, x2, y2, ... .`},{header:"Algorithms",slug:"algorithms",content:`GenSTPTree (Network, startID [, endID])
Generates a Shortest Path Spanning Tree from a node. Returns a boolean value.
GetSTPPath (Network, endID, "NodeID"|"LinkID")
After calling GenSTPTree calls this function. Returns a Shortest Path indicated by a node or link id sequence: id1, id2 ,... .
GetSTPPath (Network, endID, "iNodeShp"|"iLinkShp")
After calling GenSTPTree calls this function. Returns a Shortest Path indicated by a node or link Shapes index sequence.
GetSTPPath (Network, endID, "NodeShp"|"LinkShp")
After calling GenSTPTree calls this function. Returns a Shortest Path indicated by a node or link Shape object sequence.
GetSTPLen (Network, endID)
After calling GenSTPTree call this function. Returns a Shortest Path Distance to a end node.
GetSTPLen (Network, startID, endID)
Gets a Shortest Path from a start node to an end node in a Network. Returns the distance.
GetSTPLen (Network, x1, y1, x2, y2)
Gets a Shortest Path from a start coordinate to an end coordinate in a Network. Returns the distance.
SetTrip (Network, oID, dID, amount)
Sets an amount of a trip from an origin to an destination.
SolveUE (Network [, rootTol = 1E-2 [, equlBrm = 1E-5 [, maxIter = 10000]]])
After calling SetTrip call this function. Performs the User Equilibium Traffic Assignment and returns a boolean value.
GetFlow (Network, linkID)
Returns the traffic flow of a specified link.
SetFlow (Network, linkID, flow)
Set the traffic flow of a specified link and return a boolean value.`}]},{path:"/en/docs/4.7_des_simulations.html",title:"4.7 Discrete Event Simulations",pathLocale:"/en/",contents:[{header:"4.7 Discrete Event Simulations",slug:"_4-7-discrete-event-simulations",content:'MicroCity has a inside simulation time counting and event scheduling mechanism. It provides several embedded Lua functions to facilitate creating Discrete Event Simulations, which is very useful for dynamic system analysis. Sample codes for this chapter can be found in the "simulation_samples" folder of the Project Tab in ScriptEditor.'},{header:"Random Number Generation",slug:"random-number-generation",content:`CreateRandEng (seed, "uniform_01")
Creates a binary distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "uniform_real" [, min = 0, max = 1])
Creates a uniform distributed real random generation engine from a seed and returns the object.
CreateRandEng (seed, "uniform_int" [, min = 0, max = 1])
Creates an uniform integer random generation engine from a seed and returns the object.
CreateRandEng (seed, "triangle" [, a = 0, b = 1, c = 2])
Creates a triangle distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "bernoulli" [, p = 0])
Creates a bernoulli distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "cauchy" [, median = 0, sigma = 1])
Creates a cauchy distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "exponential" [, lambda = 1])
Creates a exponential distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "geometric" [, p = 0])
Creates a geometric distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "normal" [, mean = 0, sigma = 1])
Creates a normal distributed random generation engine from a seed and returns the object.
CreateRandEng (seed, "lognormal" [, mean = 0, sigma = 1])
Creates a lognormal distributed random generation engine from a seed and returns the object.
GetNextRandom (Engine)
Gets a random number from a random generation engine.`},{header:"Simulation Control",slug:"simulation-control",content:`CreateEvent (time, Funcion [, arg1, arg2, ...])
Creates a future event from a Lua Function or a Lua Coroutine. Returns a Coroutine object.
ExecAllEvents ()
Calls this at last. It will execute all events as Lua Coroutines.
Delay ([relativeTime = 0])
Calls this function in a Lua Coroutine will let it first yield then resume it after the specified relative time. If the parameter relativeTime is not set, the current Coroutine will yield and won' be resumed automatically.
Resume ([time, ] Coroutine [, arg1, arg2, ...])
Resumes a yielded coroutine immediately or at a specified time.
GetSimTime ()
Returns the current simulation time.`}]},{path:"/en/docs/4.8_mixed_integer_programming.html",title:"4.8 Mixed Integer Programming",pathLocale:"/en/",contents:[{header:"4.8 Mixed Integer Programming",slug:"_4-8-mixed-integer-programming",content:'MicroCity employs the lpsolve to takle Mixed Integer Linear Programming problems. Developers can use embedded Lua functions to build and solve models. Sample codes for this chapter can be found in the "optimization_samples" folder of the Project Tab in ScriptEditor.'},{header:"Model Creation and Execution",slug:"model-creation-and-execution",content:`CreateLP ([rows = 0 , columns = 0])
Creates a Mixed Integer Linear Programming model and returns the LPModel object.
SetObjFunction (LPModel, rowTable, "MAX"|"MIN")
Sets the objective function of a LPModel with a Lua Table which stores coefficients of the decision variables.
AddConstraint (LPModel, rowTable, "<="|">="|"==", rhsValue)
Adds a constraint to a LPModel with a Lua Table which stores coefficients of the decision variables.
SetInteger (LPModel, index)
Sets a decision variable specified by the index as an integer variable.
SetBinary (LPModel, index)
Sets a decision variable of a LPModel specified by the index as a binary variable.
SetUnbounded (LPModel, index)
Sets a decision variable of a LPModel to be unbounded(+/- infinity).
SolveLP (LPModel [, timeoutSec = 60])
Solves a LPModel and returns 0 as success, -1 as invalid LP model, -2 as nomemory, 1 as suboptimal, 2 as infeasible, 3 as unbounded, 4 as degenerate, 5 as a numerical failure encountered, 6 as the user abort, 7 as a timeout error, 9 as the model could be solved by presolve, 10 as the B&B routine failed, 11 as the B&B was stopped because of a break-at-first, 12 as a feasible B&B solution was found, 13 as no feasible B&B solution found.
GetObjective (LPModel)
Returns the objective function value of a LPModel.
GetVariable (LPModel, index)
Returns the value of a decision variable specified by the index.
GetVariables (LPModel)
Returns all values of the decision variables of a LPModel.
GetDual (LPModel, index)
Returns the dual value of a decision variable specified by the index.
GetDuals (LPModel)
Returns all dual values of the decision variables of a LPModel.
ReadLP("fileName.mps")
Reads a LPModel from a file (*.lp, *.mps) and returns the LPModel if succeed.
WriteLP (LPModel, "fileName.mps")
Writes a LPModel to a file (*.lp, *.mps) and returns true if succeed.`}]},{path:"/en/docs/",title:"MicroCity Desktop Documents",pathLocale:"/en/",contents:[{header:"MicroCity Desktop Documents",slug:"microcity-desktop-documents",content:""},{header:"Contents",slug:"contents",content:`1 Introduction 1.1 What MicroCity can Do 2 Getting Started 2.1 Showing a World Map
2.2 Searching for Countries 3 User Interfaces 3.1 UI Overview
3.2 Vector Shapes
3.3 Raster Grids
3.4 3D Scenes
3.5 Tables
3.6 Maps and Layers
3.7 Modules 4 Scripting Interfaces 4.1 SI Overview
4.2 UI Control
4.3 Shapes and Tables
4.4 Grids
4.5 3D Scenes
4.6 Networks
4.7 Discrete Event Simulations
4.8 Mixed Integer Programming Statement: Part of the content of the documents on this website comes from MicroCity Desktop, and the copyright belongs to the original author.`}]},{path:"/en/notes/3d-objects.html",title:"3D Objects",pathLocale:"/en/",contents:[{header:"3D Objects",slug:"_3d-objects",content:"This section will introduce the objects and their control functions in a 3D scene."},{header:"Adding Objects",slug:"adding-objects",content:`To add objects to the scene, use the following function:
local obj = scene.addobj([type], {key1 = value1, key2 = value2, ...})`},{header:"Optional Object Properties",slug:"optional-object-properties",content:`Objects added to the scene typically support setting some of the following properties: Object Property
Meaning color
The color of the object. The format of the color can support built-in colors, hexadecimal, and RGB. Same as the background color of the scene opacity
Opacity hcolor
The color when the object is selected size
The size of the object. The default value is 1 length
The length of the object, commonly used for box width
The width of the object, commonly used for box height
The height of the object, commonly used for box radius
The size of the object's rounded corners segments
The number of segments, usually used to set the precision of the sphere drawn selectable
Whether the object can be selected name
The name of the object text
The text value of the object font
The font of the text vertices
The set of points that make up the corresponding object The following are the types of objects that can be added to the scene:`},{header:"Object Types",slug:"object-types",content:""},{header:"List of Object Types",slug:"list-of-object-types",content:`label: Text label
points: Set of points
polyline: Set of line segments
box: Cube
sphere: Sphere
polygon: Polygon
light: Light source
mesh: Face made up of points For the sake of brevity, the key properties of the optional objects shown in the example below only display the relevant attributes of the object. Other common properties can be added by referring to the Optional Object Properties.`},{header:"label",slug:"label",content:`label is a text label. The text of the label can be set in the text attribute.
local obj = scene.addobj('label', {text = "Hello World!"})`},{header:"points",slug:"points",content:`points is a collection of points. You can create a single point or multiple points. Each point has three-dimensional coordinates to determine its position in three-dimensional space. The number of points is determined by the vertices attribute.
Here is an example of creating a points object:
-- create a point at position (5,5,5)
scene.addobj("points", {vertices = {5,5,5}, size = 5}) -- create two points, the first at (0,0,0), the second at (5,5,5)
scene.addobj("points", {vertices = {0,0,0, 5,5,5}, size = 5})`},{header:"polyline",slug:"polyline",content:`polyline is a collection of line segments. When multiple points are input in the vertices attribute, line segments will be generated based on the order of the coordinates.
Therefore, although the same coordinates are used in the two examples below, the results are different because the order of the input coordinates is different.
scene.addobj("polyline", {vertices = {0,0,0, 4,6,7, -2,3,5}})
scene.addobj("polyline", {vertices = {0,0,0, -2,3,5, 4,6,7}}) polyline point order comparison polyline does not have a size attribute.`},{header:"box",slug:"box",content:`box is a cuboid. Its shape can be modified mainly through the length, width, and height attributes.
local obj = scene.addobj('box', {length = 3, width = 4, height = 5})
Important optional properties of the box object: Property
Meaning length
The length of the cuboid width
The width of the cuboid height
The height of the cuboid Based on the above three attributes, we can modify the shape of the rotating box in the default sample code.
-- Add the length, width, and height attributes (default to 1 if not added)
local obj = scene.addobj('box', {length = 3, width = 4, height = 5}) local x = 1
local y = 1
local z = 0
while scene.render() do x = x + 0.1 y = y + 0.1 obj:setrot(x, y, z)
end Boxes with different lengths, widths, and heights.`},{header:"sphere",slug:"sphere",content:`sphere is used to create a sphere object. Its size can be modified by the radius attribute, and its model quality can be set by setting the segments attribute. Refer to the example of the Earth in the built-in samples for more details.
local obj = scene.addobj('sphere', {radius=15, segments=360})
Optional attributes for sphere objects: Attribute
Meaning radius
The radius of the sphere. It can be used to control the size of the sphere. segments
The number of rendered surfaces of the sphere. The higher the value, the more detailed the sphere model will be. The impact of different segments on the same sphere`},{header:"polygon",slug:"polygon",content:`polygon is used to create a polygon object, mainly set through the vertices attribute.
local obj = scene.addobj("polygon", {vertices = {-1,-1,0, -1,1,-0, 1,1,0, 1,-1,0}}) Because the polygon in this example is a square, it looks no different from the box introduced above. However, when the shape is set to other types of polygons (such as triangles, pentagons, etc.), the meaning of the polygon can be reflected. Attribute
Meaning
Explanation vertices
The vertices of the polygon
You can set the three-dimensional coordinates of each point in turn in the vertices attribute. The third dimension coordinates do not have an impact but play a placeholder role. size
Volume
Since the third dimension coordinates do not have an impact, and the area is already determined by the vertices of the polygon, the size attribute controls the volume by controlling the third dimension coordinate values of each point. The impact of different size on the same polygon volume`},{header:"External model",slug:"external-model",content:`Reference external files. However, for MicroCityWeb, only the built-in files on the website can be referenced at present.
For example, in the built-in example, a box-type truck is generated in the view by referencing the internal file:
local obj = scene.addobj('/res/2axle.glb')
You can also reference an external model by referencing the URL of the file:
local obj = scene.addobj('https://microcityweb.gitee.io/res/agv.glb') If you have 3D model resources at hand, you can view them in 3D Viewer and export them as .glb models through this website.`},{header:"Light",slug:"light",content:"Set the direction of the light, and the optional parameter vertices is a three-dimensional vector that represents the direction of the light. Since a strong light source has already been set in the MicroCityWeb scene, this will not be discussed in detail here."},{header:"Mesh",slug:"mesh",content:"A face composed of multiple points, commonly found in referenced external models. Due to its limited application, it will not be introduced here."},{header:"Object Control Functions",slug:"object-control-functions",content:"Assuming the 3D object to be manipulated is obj."},{header:"getpos()",slug:"getpos",content:`Gets the position coordinates (x, y, z) of obj.
local x, y, z = obj:getpos()`},{header:"setpos()",slug:"setpos",content:`Sets the position coordinates of obj to (x, y, z).
obj:setpos(x, y, z)`},{header:"getrot()",slug:"getrot",content:`Gets the rotation angles (rx, ry, rz) of obj in the x, y, and z directions.
local rx, ry, rz = obj:getrot()`},{header:"setrot()",slug:"setrot",content:`Sets the rotation angles of obj in the x, y, and z directions to (rx, ry, rz).
obj:setrot(rx, ry, rz)`},{header:"getscale()",slug:"getscale",content:`Gets the scaling ratios (sx, sy, sz) of obj in the x, y, and z directions.
local sx, sy, sz = obj:getscale()`},{header:"setscale()",slug:"setscale",content:`Sets the scaling ratios of obj in the x, y, and z directions to (sx, sy, sz).
obj:setscale(sx, sy, sz)`},{header:"getchildren()",slug:"getchildren",content:`Gets the table of child objects of obj.
local children = obj:getchildren()`},{header:"setchildren()",slug:"setchildren",content:`Sets the table of child objects of obj to children_table.
obj:setchildren(children_table)`},{header:"getparent()",slug:"getparent",content:`Gets the parent object of obj.
local num = obj:getparent()`},{header:"setparent()",slug:"setparent",content:`Sets the parent object of obj to obj0.
obj:setparent(obj0)`},{header:"delete()",slug:"delete",content:`Delete obj.
obj:delete()`}]},{path:"/en/notes/3d-scene.html",title:"3D Scene",pathLocale:"/en/",contents:[{header:"3D Scene",slug:"_3d-scene",content:"This section introduces 3D scenes and their settings."},{header:"MicroCityWeb 3D Scene Coordinate System",slug:"microcityweb-3d-scene-coordinate-system",content:"The 3D scene coordinate system in MicroCityWeb follows the right-hand coordinate system, and the specific direction of each coordinate axis is shown in the following figure. Coordinate system in MicroCityWeb Note that the three-dimensional coordinate axes x, y, and z here are manually drawn to show the coordinate system in MicroCityWeb and do not directly exist in the three-dimensional scene."},{header:"Setting up a Scene",slug:"setting-up-a-scene",content:`Setting up a scene requires the use of the setenv function, with the specific usage as follows:
local s = scene.setenv({grid="plane|sphere|none", bgcolor="rgb(255, 255, 255)", rotspeed=1, transpeed=1, camtype="ortho|persp", clear=true})
It can be simplified as follows:
local s = scene.setenv({key1 = value1, key2 = value2, ...})
The variable s holds the returned environment object. The optional parameters of the function will be described in detail below.`},{header:"Optional Parameters of a Scene",slug:"optional-parameters-of-a-scene",content:""},{header:"Parameter List",slug:"parameter-list",content:`grid: background grid of the scene
bgcolor: background color of the scene
camtype: camera view
clear: whether to clear the scene
rotspeed & transpeed*: adjustment of mouse operation speed`},{header:"grid: Background grid of the scene",slug:"grid-background-grid-of-the-scene",content:`Optional values Value
Meaning "none"
default, no grid "plane"
flat grid "sphere"
spherical grid`},{header:"bgcolor: Background color of the scene",slug:"bgcolor-background-color-of-the-scene",content:`Optional value types: Value Type
Example Built-in colors
"black", "white", "gray", etc. Hexadecimal colors
"#ffffff", "#fff", "#000000", "#000", etc. Colors represented by RGB
"rgb(255, 255, 255)", "rgb(0, 0, 0)", etc. Example:
scene.setenv({bgcolor='gray'}) -- Sets the background color to the built-in color "gray"
scene.setenv({bgcolor='#eee'}) -- Sets the background color to the hexadecimal color "#eee"
scene.setenv({bgcolor='rgb(255, 255, 255)'}) -- Sets the background color to white`},{header:"camtype: Camera angle of view",slug:"camtype-camera-angle-of-view",content:`Optional values: Value
Meaning "ortho"
Orthographic. Equivalent to a projection onto the x and y plane. User's view is in two-dimensional space. "persp"
Perspective (default). User's view is in three-dimensional space.`},{header:"clear: Whether to clear the scene",slug:"clear-whether-to-clear-the-scene",content:"When the value is set to true, the scene is cleared. The setenv function does not clear the original scene by default, unless the value of the clear parameter is manually set to true."},{header:"rotspeed & transpeed",slug:"rotspeed-transpeed",content:`Value
Meaning rotspeed
Sets the speed of rotating a 3D object with the mouse. transpeed
Sets the speed of translating a 3D object with the mouse. These two parameters usually do not need to be set specially, and the default values can be used.`},{header:"Others",slug:"others",content:""},{header:"Regarding high-frequency setting scenarios",slug:"regarding-high-frequency-setting-scenarios",content:`2023/03/21: It has been found that setting the scene too frequently can cause excessive memory usage and browser crashes. Therefore, it is recommended to avoid calling the scene.setenv() function in a loop as much as possible.
If it is necessary to do so, make sure that the frequency of calls is relatively low. This allows the browser to have enough time for garbage collection, otherwise it may cause the browser to crash.`}]},{path:"/en/notes/",title:"Notes",pathLocale:"/en/",contents:[{header:"Notes",slug:"notes",content:""},{header:"General Knowledge",slug:"general-knowledge",content:`Quick Start with Lua Language
Versions of MicroCity
Time Advancement Methods
Object-oriented Programming
Regarding Tools`},{header:"MicroCity (Desktop Version)",slug:"microcity-desktop-version",content:`Visualization of Results
Operating Networks
Model Solving`},{header:"MicroCityWeb",slug:"microcityweb",content:`Introduction to User Interface
3D Scene
3D Objects
Discrete Event Simulation and Program Control
Mixed Integer Programming
Debugging`},{header:"Ideas",slug:"ideas",content:`Warehouse Simulation
General Drawing Code
Simulation Ideas for Port AGV Service Process The notes referenced in this page directory apply to the corresponding versions of MicroCity. Special thanks to Sun Zhuo (MicroCity author) for the guidance and assistance during the writing and organizing process. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/cy-simulation.html",title:"Port AGV Service Process 3D Simulation Approach",pathLocale:"/en/",contents:[{header:"Port AGV Service Process 3D Simulation Approach",slug:"port-agv-service-process-3d-simulation-approach",content:"This train of thought is for reference only. Simulating the process of a container terminal is a complex task that involves many factors and entities. This article mainly introduces the approach to simulate the process of AGV receiving services from the yard crane to accepting services from the quay crane using MicroCityWeb."},{header:"Implementing Yard Crane Handling of Containers",slug:"implementing-yard-crane-handling-of-containers",content:""},{header:"Overall Approach",slug:"overall-approach",content:"Implementing the handling of containers by the yard crane is the first step in simulating the yard. I plan to use an object-oriented approach for this part, abstracting the yard crane and the yard as objects."},{header:"Overall Structure",slug:"overall-structure",content:`The specific idea is to treat the yard as a data model that stores various data, such as container entities, coordinates of containers in corresponding positions (rows, columns, heights), etc. The yard crane is treated as an operator responsible for the yard crane's 3D animation and management of data in the yard object.
The benefit of doing this is to decouple the yard crane from the yard, making it easier to expand in the future. In addition, if the object's properties are well considered, multiple objects can be easily created in the same scene to simulate multiple yard cranes operating in the yard.`},{header:"Events and Tasks",slug:"events-and-tasks",content:"I plan to create task sequences for the main entity objects that require movement in the overall process. This allows for parallel operations of multiple yard cranes in the same scene, with each yard crane performing its own tasks without interfering with each other. In addition, a central control program is needed to control the execution of tasks at each time node and the 3D animation of the yard crane."},{header:"Business Process",slug:"business-process",content:"In this simulation, the main focus of the business process is the movement of containers. Therefore, the most important aspect is the transfer of ownership of containers. The process flow of container ownership transfer is shown in the following diagram: Container Object Process Flow"},{header:"Object Structure",slug:"object-structure",content:"The following are the structures of the main objects involved in this simulation."},{header:"Implementation Approach",slug:"implementation-approach",content:""},{header:"Yard Size",slug:"yard-size",content:`For the yard object, since its main function is to store container objects and related data (such as coordinates of corresponding positions), we need to determine the size of the yard. Therefore, determining the size of the yard is a necessary step. When creating the yard object, we need to determine the size of the yard, including the number of rows, columns, and height. This facilitates subsequent operations.
My approach is to first determine the area occupied by the yard and the number of container layers. Based on the relevant data, we can calculate the maximum number of rows and columns that can be used to place containers. Regarding the area occupied by the yard, it can be determined by inputting the coordinates of two points when creating the object. Based on the diagonal formed by connecting the two points, we can determine the area occupied by the yard.
As for the number of container layers, it can be determined by inputting a number when creating the object. Based on these two inputs, we can determine the size of the yard.`},{header:"Events and Tasks",slug:"events-and-tasks-1",content:`Since the yard crane is the main object that needs to be moved in this simulation, we only need to operate the yard crane during each loop of task execution.
Therefore, I plan to treat the task sequence of the yard crane as a queue. During each loop of task execution, we take out the first task from the object's task sequence and execute it. After execution, we check if the task completion condition is met. If so, we delete the task and move on to the next one. This ensures that the yard crane objects execute tasks in order during each loop of task execution.
The method for executing tasks is executeTask(dt), where the object executes tasks based on the duration dt. The executeTask(dt) function contains the logic for processing tasks, including task type determination, task execution, and task deletion.
If there are multiple yard cranes in the scene, simply add these objects to the list of objects executing tasks. During each loop of task execution, the main control program will iterate through this list of objects and execute tasks for each object. Tips
Note that although the task execution appears to be simultaneous in terms of time, it actually depends on the sequence position of the objects.
One example is: suppose two objects need to occupy position A at the same time. According to the order of the task sequence, the object that is executed first will occupy position A, while the object that is executed later will fail to occupy it, even though they are both trying to occupy position A at the same moment. Therefore, it is not strictly simultaneous execution here, but sequential execution according to the task sequence at the same time.`},{header:"Business Process",slug:"business-process-1",content:`The yard crane first obtains the coordinates of the corresponding position (row, column, height) of the container from the yard and moves the spreader to the designated position in the yard to grab the container. The ownership of the container is transferred from the yard (cy.containers) to the yard crane spreader (rmg.attached) (by removing the table reference, setting the value to nil).
The yard crane moves the container to the aisle and releases it there. In the same way, the ownership of the container is transferred from the yard crane spreader (rmg.attached) to the aisle (rmg.stash), indicating that the container can be picked up.
If there is a vehicle that takes away the container, the ownership of the container can be further transferred from the aisle of the yard crane (rmg.stash) to the vehicle.`},{header:"Results",slug:"results",content:""},{header:"Implementation of the Whole Process from AGV Arrival to Service",slug:"implementation-of-the-whole-process-from-agv-arrival-to-service",content:""},{header:"Problem Description",slug:"problem-description",content:"Implement the three-dimensional representation of the process above using event scheduling method."},{header:"What's New",slug:"what-s-new",content:`The implementation of the previous simulation serves as the foundation for this simulation. Compared to the previous simulation, the most significant improvement in this simulation is: Using the object-oriented programming paradigm to create objects of four types: yard crane, yard (data model), AGV, quay crane, and ship (data model), and implement the movement methods for the objects and their components. If you are not familiar with object-oriented programming, you can refer to General Knowledge - Object-Oriented Programming. Continuing with the idea of event-driven simulation, the overall control process is implemented to control multiple objects simultaneously at the same time (primarily achieved through the object's executeTask(dt) and maxStep() functions). In the object-oriented programming paradigm, executeTask(dt) and maxStep() can be seen as interfaces. The main program controls the objects by implementing these two interfaces. (Although Lua seems to lack this concept.)
Using task sequences to implement the flow of each object, achieving mutual waiting between the yard crane and AGV, and between the AGV and quay crane, and coordinating tasks between different objects.
Attempting to extend the flow from the yard to the AGV, and then to the quay crane and ship, implementing two-level queuing and waiting.`},{header:"Object Design",slug:"object-design",content:`Due to the large number of attributes and functions, the design of objects is presented in the form of a mind map. Tips
This section takes up a lot of space. You can also directly jump to the next section Overall Layout.`},{header:"Yard",slug:"yard",content:"The yard remains as the data model."},{header:"Yard Crane",slug:"yard-crane",content:""},{header:"AGV",slug:"agv",content:""},{header:"Quay Crane",slug:"quay-crane",content:"The code and structures involving the quay crane are derived mainly from the yard, so they will not be described in detail later."},{header:"Ship",slug:"ship",content:"The ship object also serves as a data model, designed similarly to the yard."},{header:"Overall Layout",slug:"overall-layout",content:""},{header:"Overall Process",slug:"overall-process",content:"Container Flow Process Compared to the previous simulation, this simulation goes further in terms of the process. It adds the flow of AGV arrival and queuing, as well as the service of the quay crane and container loading onto the ship."},{header:"Process Analysis",slug:"process-analysis",content:`With the introduction of AGVs, the flow between the yard crane, quay crane, and AGV has becomes more complex. First, the arrival of AGVs is random, which may cause queuing. Second, the arrival of AGVs triggers the flows of the yard crane and AGV, which in turn trigger the flow of the quay crane. Therefore, the flow of this simulation is a multi-level flow that needs to consider the coordination between multiple objects.
Especially in the process between AGV and RMG, there is a mutual waiting between AGV and RMG. When the AGV arrives, it needs to notify the RMG to extract the cargo. In the process of extraction by the RMG: The RMG needs to wait for the AGV to arrive at the designated position before it can move the cargo onto the AGV.
The AGV needs to wait for the RMG to grab the container and place it on the AGV before transferring the ownership of the container from the RMG to the AGV. Therefore, the process between the AGV and the RMG is a mutually waiting process. The specific process can be referred to in the diagram below. The process of the quay crane is similar to that of the RMG, which is also a mutually waiting process. The main points are: When the AGV arrives at the designated position, the quay crane may be serving other AGVs, so the AGV has to wait.
When the AGV just enters the service area of the quay crane, it notifies the quay crane to reach the designated position. If the quay crane arrives at the designated position first, it has to wait.`},{header:"Implementation Method",slug:"implementation-method",content:""},{header:"Implementation of Queuing Process",slug:"implementation-of-queuing-process",content:`For AGV queuing, I chose to use cellular automaton as the data model of parking spaces. The length of each parking space is:
LengthÂ ofÂ ParkingÂ Space=LengthÂ ofÂ 1Â ContainerÂ inÂ theÂ dataÂ model+GapÂ betweenÂ containers
\\text{Length of Parking Space} = \\text{Length of 1 Container in the data model} + \\text{Gap between containers}
LengthÂ ofÂ ParkingÂ Space=LengthÂ ofÂ 1Â ContainerÂ inÂ theÂ dataÂ model+GapÂ betweenÂ containers
Since the length of the AGV is slightly longer than that of 1 container, it needs to occupy the length of 2 parking spaces. When executing a task, the AGV checks if the space ahead is blocked, and if not, it moves forward. If the space ahead is the target bay, it moves forward and waits for the RMG operation, then continues to move forward in terms of cells until it leaves. The queuing principles for the RMG and quay crane are also the same. Diagram of AGV Cellular Automaton Queuing Model`},{header:"Implementation of Event Scheduling Method",slug:"implementation-of-event-scheduling-method",content:`In the previous simulation, I used a variable step size to advance the time for simulation. In this simulation, I used the event scheduling method to accurately advance the events to their occurrence time for execution.
You may have noticed that in the Object Design section, executeTask() and maxstep() are marked as (interface). This is because to calculate the accurate advancement time, I need to implement executeTask() and maxstep() methods in each object. The executeTask() method is used to execute the task, and the maxstep() method is used to calculate the time remaining for the current task to be completed and obtain the maximum advancement time based on that, and then compare it with the interval time dt obtained from the system execution to get the maximum advancement time.
I believe that the following diagram from the course can effectively represent how the event scheduling method is used for simulation and scene refreshing. The first row refers to the business process of simulation, and the Refresh part in the second row refers to refreshing the scene.`},{header:"Results",slug:"results-1",content:`Warning
The following parts contain animated GIFs, and the images have a large file size. Since this site is hosted on GitHub Pages, if you don't have a special network environment, the animated GIFs may load slowly or even fail to load. Tips
If you encounter moirÃ© patterns in the animated GIFs while directly viewing them, you can try opening them to enlarge the view and see if there is any improvement. RMG running process Quay crane running process Overall running process This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/debug.html",title:"Debugging",pathLocale:"/en/",contents:[{header:"Debugging",slug:"debugging",content:"This page introduces the functions and shortcuts related to debugging MicroCity Web."},{header:"Clear Output",slug:"clear-output",content:"You can enter commands by right-clicking the output area, and entering print() will clear the content of the output area."},{header:"Debugger Shortcuts",slug:"debugger-shortcuts",content:`During the debugging process, especially at breakpoints, you can use F9 (Step Over), F10 (Step Into), and F11 (Step Out) to control the program execution. F9 Step Over: Skip the current line and execute the next line
F10 Step Into: Enter the current line; if the current line is a function call, enter the function body
F11 Step Out: Step out of the current function and execute the next line of the function call`},{header:"Debug Commands",slug:"debug-commands",content:""},{header:"Watch Variables",slug:"watch-variables",content:`Use the debug.watch() command in the console to monitor variables.
For example, if you want to monitor the value of variable a during debugging, you can use the debug.watch('a') command. You can enter commands by right-clicking the output area`},{header:"Stack Tracing",slug:"stack-tracing",content:`Use the debug.traceback() function to print the current stack trace information.
function myFunction() -- Some code logic print(debug.traceback("Stack trace")) -- Other code logic
end function anotherFunction() myFunction()
end anotherFunction()
Output:
Stack trace
stack traceback:
[string "function myFunction() ..."]:3: in function 'myFunction'
[string "function myFunction() ..."]:8: in function 'anotherFunction'
[string "function myFunction() ..."]:11: in main chunk`},{header:"Running State",slug:"running-state",content:`debug.debug() enters Debug mode. It is often used to enter Debug mode while the program is running. If you want to enter Debug mode at startup, you can right-click on the top â–¶ï¸ button. See Introduction to the User Interface - Running State for more details.
debug.pause() pauses the program. The top run button â–¶ï¸ will light up, and the pause button â¸ï¸ will go out.`},{header:"Other Debugging Commands",slug:"other-debugging-commands",content:`Most of Lua's Debug functions are applicable to MicroCity Web. You can refer to: The Debug Library | Lua 5.4 Reference Manual
Lua Debugging | Runoob Tutorial`},{header:"File Saving",slug:"file-saving",content:`When saving files in MicroCity Web, you can choose to save them as .mw files and .lua files. .mw file: Packages the entire project, including the currently open code files and files in the virtual disk.
.lua file: Only saves the currently edited code file. It is commonly used for writing Lua scripts only and modifying custom .lua library files. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/event-scheduling.html",title:"Discrete Event Simulation and Program Control",pathLocale:"/en/",contents:[{header:"Discrete Event Simulation and Program Control",slug:"discrete-event-simulation-and-program-control",content:"This article mainly introduces how to implement discrete event simulation and program control in MicroCity Web."},{header:"Coroutine",slug:"coroutine",content:"MicroCity Web provides several coroutine-related functions, which facilitate the implementation of event scheduling. If you primarily use it for event scheduling and are not clear about the principles of event scheduling, you can read the Time-lapse Event Scheduling section to understand the relevant concepts."},{header:"coroutine.queue",slug:"coroutine-queue",content:`Add a function or coroutine to the coroutine queue for waiting execution.
coroutine.queue(rt, f|co [, parameter list...])
Parameters Parameter
Meaning rt
The time relative to the current queue, which must be greater than or equal to 0. In other words, it is the time for executing the input function or coroutine after rt. f/co
The function or coroutine. If it is a function, only the function name needs to be inputted.`},{header:"coroutine.qtime",slug:"coroutine-qtime",content:`Get the current queue time.
local time = coroutine.qtime()`},{header:"Example",slug:"example",content:`Two examples are provided here: Coroutines Adding Tasks: Using coroutines to add tasks and displaying the current queue time in the function.
Vehicle Movement: Using coroutines to implement scene refreshing based on real-world time.`},{header:"Coroutines Adding Tasks",slug:"coroutines-adding-tasks",content:`This example demonstrates how to use coroutines to add tasks and display the current queue time in the function.
function Show() print("Current time: ", coroutine.qtime())
end
function ShowShort() print("Current time short: ", coroutine.qtime())
end coroutine.queue(10, Show)
coroutine.queue(20, Show)
coroutine.queue(15, ShowShort)
coroutine.queue(5, Show) -- Result:
-- Current time: 5.0
-- Current time: 10.0
-- Current time short: 15.0
-- Current time: 20.0`},{header:"Vehicle Movement",slug:"vehicle-movement",content:`This example demonstrates how to use coroutines to implement scene refreshing based on real-world time.
scene.setenv({grid = 'plane'}) -- Set the scene grid background -- Vehicle
local car = scene.addobj('/res/2axle.glb')
car.speed = 1 -- Car speed -- Initial time
local t = os.clock()
local dt = 0 -- Refresh the time state t and dt (step according to CPU interval to synchronize with real time)
function refreshtime() dt = os.clock() - t t = os.clock()
end -- Coroutine updating scene
function update() if not scene.render() then return end -- Render the scene and check if the program is terminated coroutine.queue(dt, update) -- Add the next update based on CPU step time carmove() -- Move the car refreshtime() -- Calculate the current dt
end -- Vehicle movement
function carmove() print("Car moves at ", t) local x, y, z = car:getpos() car:setpos(x, y, z + dt * car.speed)
end -- Initial update (add the first update)
-- Because subsequent updates are involved in the function, the updates will automatically loop
coroutine.queue(dt, update)
Open in MicroCityWeb`},{header:"Random Numbers",slug:"random-numbers",content:""},{header:"Introduction to the Principle of Random Number Generation",slug:"introduction-to-the-principle-of-random-number-generation",content:`In a computer, the process of selecting random numbers is not truly random. In fact, everything we do in a computer is not truly random, and it can be proven that it is impossible to manufacture a computer that can truly generate random numbers. The random numbers we obtain are actually pseudo-random numbers.
So how are pseudo-random numbers generated? There is an algorithm that generates the next number in a sequence based on a given number. This algorithm is initialized with a seed, and then iterated to produce subsequent random number sequences. If the seed is the same, the generated random number sequences will also be the same.
Now, every time a different random sequence is needed, a seed is obtained by reading the computer's clock. The principle behind this is that since it is impossible to know the exact moment when a program is started, each program start can be considered as obtaining a random number to be used as a seed.
Therefore, it can be anticipated that the resulting random number sequence is unpredictable, because we do not know what the random number seed will be.`},{header:"Creating Random Number Seeds",slug:"creating-random-number-seeds",content:`local seed = math.randomseed(x [, dist])
Parameters Parameter
Meaning x
Random number seed, which will return different random numbers based on different input values. If different values are needed each time, the random number seed x can be set to the current time. dist
Random number distribution (optional parameter). If not set, it defaults to a uniform distribution. If this parameter is set, mu and sigma can also be set as parameters for the corresponding distribution. The dist parameter can be set with three types of distribution: 'normal': Normal distribution
'exponential': Exponential distribution
'poisson': Poisson distribution In addition, the parameters for these distributions can also be set, where the mu key represents the mean and the sigma key represents the variance.`},{header:"Example",slug:"example-1",content:`-- Create a random number seed for Poisson distribution
local seed = math.randomseed(os.time(), {distribution = "poisson", mu = "3"}) -- Poisson distribution with a mean of 3 -- Output random number
print(seed:random())`},{header:"Program Control",slug:"program-control",content:`The program control mentioned in this article mainly refers to how to use the buttons in the user interface to control the program's operation, including pausing, resuming, stopping, etc. Command Bar It mainly refers to the first 3 buttons in the command bar. Program control in MicroCity Web mainly refers to the pause, resume, and stop of 3D interface rendering implemented through the scene object, with specific functions as follows:
local state = scene.render()
Here, the return value of scene.render() is stored in the variable state, and the value of the state variable is either true or false, representing the program's running state as running or terminated (button 3 pressed in the command bar).
The pause of rendering of 3D objects is also achieved by calling scene.render(). If refreshing 3D objects is achieved by continuously calling the scene.render() function and the refresh interval is not controlled by os.sleep(), it is possible to pause the rendering at a certain state on the 3D interface. This is because if the movement speed of 3D objects is controlled by os.sleep(), clicking the pause button might happen during the os.sleep() process, causing the program to not respond immediately and thus making the pause button ineffective. Therefore, it is recommended to avoid using os.sleep() for controlling the motion speed of 3D objects, and instead control the advancement duration by adding other parameters to achieve the purpose of controlling the speed of 3D object movement. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/lp.html",title:"Model Solving",pathLocale:"/en/",contents:[{header:"Model Solving",slug:"model-solving",content:`In MicroCity, mathematical models can be solved. In this article, we will introduce the common process of solving mathematical models in MicroCity and provide some tips to help you better build models.
The detailed usage of all functions in the planning model can be found in the document 4.8 Mixed Integer Linear Programming. Tips
The content on this page is based on MicroCity Desktop version. If you are looking for a solution for mixed integer programming in MicroCity Web version, please refer to the corresponding Mixed Integer Programming section in the MicroCity Web notes.`},{header:"Creating Model Objects",slug:"creating-model-objects",content:`Create a planning model object and store it in the variable lp.
local lp = CreateLP() The mathematical model object created in the official documentation is stored in the variable LPModel, which has the same function as lp in this article.`},{header:"Writing Mathematical Models",slug:"writing-mathematical-models",content:`At this point, the object of the mathematical model has been created and stored in the variable lp, and further operations can be performed on it. A mathematical model generally consists of two parts: Objective Function
Constraint Equations Next, let's introduce how to create the objective function.`},{header:"Creating the Objective Function",slug:"creating-the-objective-function",content:`In MicroCity, SetObjectFunction() is used to set the objective function of the model object. It allows you to choose whether to optimize for maximum or minimum. The specific usage is as follows: Maximum
Minimum SetObjFunction(lp, coeff, "max") -- Optimize for maximum SetObjFunction(lp, coeff, "min") -- Optimize for minimum "min" and "max" are case-insensitive, so "MIN" and "MAX" can also be used.`},{header:"Parameter Description and Example",slug:"parameter-description-and-example",content:`Parameter
Description lp
Mathematical model object. Input the mathematical model into the function to set the objective function. coeff
Objective function coefficients, which is a table type variable. Used to determine the coefficients of the objective function in the model. "min" or "max"
Determine whether to optimize for the maximum or the minimum of the objective function. coeff is a coefficient list for the objective function, which is a table type variable. Suppose you want to minimize the function 4x1+12x2+18x34x_1+12x_2+18x_34x1â€‹+12x2â€‹+18x3â€‹, the procedure to add the objective function is as follows:
-- Suppose you have already created the model object and stored it in the variable lp -- 4*x1 + 12*x2 + 18*x3
local coeff = {4, 12, 18} -- Set the objective function: minimize
SetObjFunction(lp, coeff, "min")`},{header:"Adding Constraint Equations",slug:"adding-constraint-equations",content:`In MicroCity, the function for adding model constraints is AddConstraint(), used as follows: â‰¤
â‰¥
= -- Use symbols to express
AddConstraint(lp, cons, "<=", b) -- Alternatively, you can use abbreviations
AddConstraint(lp, cons, "le", b) -- Use symbols to express
AddConstraint(lp, cons, ">=", b) -- Alternatively, you can use abbreviations
AddConstraint(lp, cons, "ge", b) -- Use symbols to express
AddConstraint(lp, cons, "==", b) -- Or you can use abbreviations to express it AddConstraint(lp, cons, "eq", b)`},{header:"Parameter Description",slug:"parameter-description",content:`Parameter
Description lp
Mathematical model object. Input the mathematical model into the function to add constraints to it. cons
Constraint equation coefficients. Similar to cons in setting the objective function, it is also a table type variable used to determine the coefficients of each variable in the constraint equation. "<=" or ">=" or "==", or their corresponding alphabetic expressions
Determines the relationship between the constraint equation and the right-hand side. b
A number representing the right-hand side of the constraint equation. It can be a variable or a constant.`},{header:"Example",slug:"example",content:`The objective function 4x1+12x2+18x34x_1+12x_2+18x_34x1â€‹+12x2â€‹+18x3â€‹ has been set above. Suppose you want to add two constraint equations for this function:
{x1+3x3â‰¥32x2+2x3â‰¥5
\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\end{matrix}\\right. {x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5â€‹
Add corresponding constraint equations:
-- Add constraint: x1+3*x3â‰¥3
cons = { 1, 0, 3 }
AddConstraint(lp, cons, ">=", 3) -- Add constraint: 2*x2+2*x3â‰¥5
cons = { 0, 2, 2 }
AddConstraint(lp, cons, ">=", 5)
It is not difficult to notice that the number of coefficients is consistent with the number of variables in the objective function. Therefore, before programming the solution, you need to first determine the total number of variables and arrange the positions of each variable.`},{header:"Set Variable Types",slug:"set-variable-types",content:`MicroCity's mathematical programming supports integer programming. If no SetUnbounded() is set for the variables, the default value range for the variables is non-negative real numbers (â‰¥0). The following describes in detail how to set variable types.
You can set the integer variable or 0-1 variable for the i-th variable in the model. If the variable is not set to these types, the default variable is non-negative real number. Integer Variables
0-1 Variables SetInteger(lp, i) -- Integer variable SetBinary(lp, i) --0-1 variable To allow the value of the i-th variable to be negative (by default, it cannot be negative):
SetUnbounded(lp, i)`},{header:"Model Solving and Output",slug:"model-solving-and-output",content:""},{header:"Model Solving",slug:"model-solving-1",content:`Since both the objective function and the constraint equations have been added, solving the model is simple, just one step:
SolveLP(lp)
After executing this statement, the mathematical model stored in the variable lp is solved.`},{header:"Output",slug:"output",content:`After solving the problem, it still needs to be output to understand the result of the solution. The following are commonly used functions for outputting the solution result.
Obtain the objective function value:
GetObjective(lp)
Obtain the value of the i-th variable:
GetVariable(lp, i)`},{header:"SolveLP",slug:"solvelp",content:`The SolveLP() function also has output after the solution is obtained, the meaning of the output code is as follows: Output Code
Meaning 0
Success -1
Invalid LP Model -2
Out of Memory 1
Suboptimal 2
Infeasible 3
Unbounded 4
Degenerate 5
Numerical Error 6
User Termination 7
Timeout Error For the meaning of other return values, please refer to the documentation 4.8 Mixed Integer Linear Programming for the SolveLP() function.`},{header:"Model Solution Example",slug:"model-solution-example",content:`Here is a simple example of modeling and solving for reference. (Actually it just strings together the previous content)
Example:
minf=4x1+12x2+18x3s.t.{x1+3x3â‰¥32x2+2x3â‰¥5x1,x2,x3âˆˆN
minf=4x_1+12x_2+18x_3\\\\
s.t.\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\\\ x_1,x_2,x_3\\in N
\\end{matrix}\\right. minf=4x1â€‹+12x2â€‹+18x3â€‹s.t.â©â¨â§â€‹x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5x1â€‹,x2â€‹,x3â€‹âˆˆNâ€‹ N represents the set of natural numbers (non-negative integers) Script:
-- Create linear programming object
local lp = CreateLP() local n = 3 -- Set the number of objective functions -- Objective function: 4*x1 + 12*x2 + 18*x3
-- Set the coefficients of the objective function, and the objective function is minimized
local coeff = { 4, 12, 18 }
SetObjFunction(lp, coeff, "min") -- Add constraint 1: x1 + 3*x3 â‰¥ 3
cons = { 1, 0, 3 }
AddConstraint(lp, cons, ">=", 3) -- Add constraint 2: 2*x2 + 2*x3 â‰¥ 5
cons = { 0, 2, 2 }
AddConstraint(lp, cons, ">=", 5) -- Since SetUnbounded() is not set,
-- by default, all variables are non-negative,
-- so there is no need to add constraints for non-negative variables. -- Set all variables to integers
for i = 1, n do SetInteger(lp, i)
end -- Solve the model
SolveLP(lp) -- Output the objective function value
print("Objective function value:", GetObjective(lp)) -- Output the values of each variable
for i = 1, n do print("x", i, "=", GetVariable(lp, i))
end
Output:
Objective function value: 42
x1=0
x2=2
x3=1`},{header:"Some Techniques for Modeling",slug:"some-techniques-for-modeling",content:""},{header:"Linearization",slug:"linearization",content:`Sometimes we encounter modeling problems with multiple subscripts, such as the decision variable xijx_{ij}xijâ€‹, which needs to be linearized.
Let's assume that the shape of the decision variable itself is 3 rows and 4 columns, that is: Column 1
Column 2
Column 3
Column 4 x11x_{11}x11â€‹
x12x_{12}x12â€‹
x13x_{13}x13â€‹
x14x_{14}x14â€‹ x21x_{21}x21â€‹
x22x_{22}x22â€‹
x23x_{23}x23â€‹
x24x_{24}x24â€‹ x31x_{31}x31â€‹
x32x_{32}x32â€‹
x33x_{33}x33â€‹
x34x_{34}x34â€‹ Assuming that the objective function is to sum up these decision variables, which is F=âˆ‘i=13âˆ‘j=14xijF=\\sum_{i=1}^3\\sum_{j=1}^4x_{ij}F=âˆ‘i=13â€‹âˆ‘j=14â€‹xijâ€‹, if we want to input it into the objective function, we can linearize it as x11+x12+...+x14+x21+...+x24+x31+...+x34x_{11}+x_{12}+...+x_{14}+x_{21}+...+x_{24}+x_{31}+...+x_{34}x11â€‹+x12â€‹+...+x14â€‹+x21â€‹+...+x24â€‹+x31â€‹+...+x34â€‹.
Since there are only two dimensions, we can use two for loops to achieve this:
local cons = {}
for i = 1, 3 do -- the first dimension for j = 1, 4 do -- the second dimension cons[4 * (i - 1) + j] = 1 -- fill in the coefficients -- the idea of 4 * (i - 1) + j is similar to carrying end
end -- result:
-- cons has a length of 12, and all values are 1`},{header:"Example: Assignment Model",slug:"example-assignment-model",content:`Let's take a look at the specific usage and convenience of multidimensional linearization using an actual example.
Four people, A, B, C, and D, are assigned to deliver four types of goods, A, B, C, and D, with the corresponding delivery times shown in the table. If each person delivers only one type of goods, who should be assigned to deliver which type of goods to minimize the total time? Person\\Goods
A
B
C
D A
14
9
4
15 B
11
7
9
10 C
13
2
10
5 D
17
9
15
13 Let's assume that the numbers corresponding to goods A, B, C, D are 1, 2, 3, 4 respectively, and xij=1x_{ij}=1xijâ€‹=1 represents person i delivering goods j, and xij=0x_{ij}=0xijâ€‹=0 represents person i not delivering goods j.
The mathematical model of the above problem can be represented as
minZ=âˆ‘i=14âˆ‘j=14cijxijs.t.{âˆ‘j=14xij=1,i=1,2,...,4âˆ‘i=14xij=1,j=1,2,...,4xij=0,1
minZ=\\sum_{i=1}^4\\sum_{j=1}^4c_{ij}x_{ij}\\\\
s.t.\\left\\{\\begin{matrix} \\sum_{j=1}^4x_{ij}=1, i=1,2,...,4 \\\\ \\sum_{i=1}^4x_{ij}=1, j=1,2,...,4 \\\\ x_{ij}=0,1
\\end{matrix}\\right. minZ=i=1âˆ‘4â€‹j=1âˆ‘4â€‹cijâ€‹xijâ€‹s.t.â©â¨â§â€‹âˆ‘j=14â€‹xijâ€‹=1,i=1,2,...,4âˆ‘i=14â€‹xijâ€‹=1,j=1,2,...,4xijâ€‹=0,1â€‹
Solution code:
-- efficiency matrix
local cost = { { 14, 9, 4, 15 }, { 11, 7, 9, 10 }, { 13, 2, 10, 5 }, { 17, 9, 15, 13 }
} local lp = CreateLP() -- create the objective function
local coeff = {}
for i = 1, 4 do for j = 1, 4 do -- it is easy to convert a two-dimensional array to a one-dimensional array here coeff[4 * (i - 1) + j] = cost[i][j] end
end SetObjFunction(lp, coeff, "min") -- add constraints
for k = 1, 4 do -- control the value of the i dimension local cons = {} for i = 1, 4 do for j = 1, 4 do if i == k then -- sum up j, check i cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end AddConstraint(lp, cons, "==", 1)
end
for k = 1, 4 do -- Control the value of the jth dimension
local cons = {}
for i = 1, 4 do
for j = 1, 4 do
if j == k then -- Sum i and check j
cons[4 * (i - 1) + j] = 1
else
cons[4 * (i - 1) + j] = 0
end
end
end
AddConstraint(lp, cons, "==", 1)
end
-- Solve the model
SolveLP(lp)
-- Output the objective function value
print("Objective function value:", GetObjective(lp))
-- Output the decision variables
for i = 1, 4 do -- First dimension
for j = 1, 4 do -- Second dimension
local x = GetVariable(lp, 4 * (i - 1) + j)
if x ~= 0 then
print("x[", i, "][", j, "]=", x)
end
end
end Output
Objective function value: 29
x[1][3]=1
x[2][1]=1
x[3][4]=1
x[4][2]=1
| Result | Person | Item |
| ---------- | :---: | :------: |
| $x_{13}=1$ | A | C |
| $x_{21}=1$ | B | A |
| $x_{34}=1$ | C | D |
| $x_{42}=1$ | D | B | ### Handling Intermediate Variables
Sometimes there may be intermediate variables in the model that need to have corresponding positions in the matrix in order to be solved, but these intermediate variables do not participate in the calculation of the objective function value. **You can set the coefficients of these intermediate variables to 0 at their corresponding positions.** Let $x_1, x_2, x_3, x_4$ be the decision variables and $y_1, y_2$ be the intermediate variables. The objective function is:
$$
z = \\sum_{i=1}^4 x_i
$$
Then the coefficients of the objective function can be set as:
\`\`\`lua
local fcons = {1, 1, 1, 1, 0, 0}
After that, you can proceed with the general process ğŸ˜ This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/lua.html",title:"Quick Start with Lua Language",pathLocale:"/en/",contents:[{header:"Quick Start with Lua Language",slug:"quick-start-with-lua-language",content:"Since MicroCity uses the Lua scripting language, it is necessary to familiarize yourself with the basic usage of Lua before starting to write scripts with MicroCity. This article introduces the commonly used syntax for writing Lua scripts in MicroCity, which can help you quickly understand the overall approach to writing MicroCity scripts based on concepts from other programming languages."},{header:"Variable and Function Definition",slug:"variable-and-function-definition",content:`Lua automatically recognizes variable types, so there is no need to define variable types before variable names. You can assign values directly.
a = 1.5
b = "string"
c = {} -- c is a table, explained below
Function definition
function add(a, b) return a + b
end
Above is a simple definition of the add() function, which aims to add the two input variables and return the result.
Variables can be global or local, and functions are the same. Here is how to define local variables and functions.
-- Define a local function
local function show(msg) print(msg)
end -- Define a local variable
local a = 1
If there is a conflict between locally defined content (function or variable) and globally defined content, the locally defined content takes precedence. When such a conflict exists, the content you are operating on is the local content.
If there is no explicit need to manipulate global variables, it is recommended to define variables as local variables as much as possible. This practice may reduce the occurrence of bugs and is a safer approach.`},{header:"Condition",slug:"condition",content:`It's all about if, and there are several specific forms of implementation: Normal form if condition then print("condition==true")
end Form with else if condition then print("condition==true")
else print("condition==false")
end Form with elseif if number > 0 then print("number>0")
elseif number < 0 then print("number<0")
else print("number==0")
end
In Lua, the equality operator is ==, and the inequality operator is ~=. You can apply these operators to conditional expressions. Here is a simple example:
print(1==1) -- true
print(1~=1) -- false`},{header:"Loop",slug:"loop",content:"Here are two most commonly used loops: for and while."},{header:"for",slug:"for",content:`The simplest form
-- Output numbers from 1 to 10, a total of 10 numbers
for i = 1,10 do print(i)
end
If you are familiar with C or C-like languages, the corresponding form of the above code is as follows:
for(int i=1; i<=10; i++){ printf("%d\\n",i);
}
Taking step size into consideration
-- Output numbers from 10 to 1, a total of 10 numbers with a step size of -1
for i = 10,1,-1 do print(i)
end When the step size is negative, it is important to note that the starting and ending numbers should be in reverse order. Generic loop
You can directly traverse all elements in a table.
i is the index of the table element, starting from 1; v is the value of the table element.
a = {4,7,9}
for i,v in ipairs(a) do print("index=",i,"\\tvalue=",v)
end ipairs is used for arrays (guessing i stands for integer), and pairs is used for objects. Since arrays are also objects, pairs can be used for arrays as well.`},{header:"while",slug:"while",content:`There is only one commonly used method for while.
local condition = true
while condition do print("while==true") condition = false
end
Similar to C-like languages. As long as condition is true, while will continue to run. When condition is set to false, the while loop will end.`},{header:"Loop Operators",slug:"loop-operators",content:`Just like in other languages, the break keyword is used to exit a loop.
In Lua, there is no continue, only break. However, the continue functionality can be achieved by using the if + break structure.`},{header:"Lua's Small Feature: Tables",slug:"lua-s-small-feature-tables",content:`Although Lua refers to its arrays as tables, I think this data structure is more similar to Python sets or JSON, as it can store anything without any structural constraints.
collection = {{"a", 1, 2}, "abc", {2, 3}}
To find the length of an array, simply prepend # before the array name.
list = {1, 2, 3, 4, 5}
for i=1,#list do print(list[i])
end
In Lua, array (table) indices start from 1, unlike C-like languages where they start from 0. Taking the previously defined collection as an example:
-- collection = {{"a", 1, 2}, "abc", {2, 3}}
print(collection[1][1]) -- a
print(collection[2]) -- abc
print(collection[3][2]) -- 3`},{header:"Indexing",slug:"indexing",content:`Lua table indexing is very flexible and can be done with numbers, strings, or even other types of data.
Here are some simple examples:
local list = {} -- Indexing with numbers
list[1] = "a" -- Indexing with strings
list["b"] = 2
list.message = "hello world" -- Equivalent to list["message"] = "hello world" print(list[1]) -- a
print(list["b"]) -- 2
print(list.message) -- hello world`},{header:"Adding Elements",slug:"adding-elements",content:`Adding to a specific position
table.insert(table, pos, value) -- Inserts an element at a specific position (pos)
Or
table.insert(table, value) -- Appends an element at the end
Example
list = {1, 2, 3, 4, 5}
table.insert(list, 6)
-- {1, 2, 3, 4, 5, 6}`},{header:"Removing Elements",slug:"removing-elements",content:`table.remove(table, pos) -- Removes an element at a specific position
Example
list = {1, 2, 3, 4, 5}
table.remove(list, 2)
-- {1, 3, 4, 5}`},{header:"Sorting a Table",slug:"sorting-a-table",content:""},{header:"Default Sorting Method",slug:"default-sorting-method",content:`You can use a function to sort a list, and the simplest usage is as follows:
table.sort(list) -- Sorts the list in ascending order
Here is an example:
-- Function: Print List
function PrintList(list) -- Output the list local listStr = "" for i = 1, #list do listStr = listStr .. list[i] .. " " end print(listStr)
end local list = { 3, 7, 2, 5, 4 } -- Original list PrintList(list) -- Output the original list
table.sort(list) -- Sort the list
PrintList(list) -- Output the sorted list -- Result:
-- 3 7 2 5 4 (Original list)
-- 2 3 4 5 7 (Sorted list)`},{header:"Custom Sorting Method",slug:"custom-sorting-method",content:`The table.sort function can also use a custom sorting rule, but this rule needs to be written in a function.
table.sort(list, function(a, b))
The function(a, b) is the custom sorting rule, which requires returning a boolean value (true or false) in the end. a and b are any two items in the list, and if the function returns true, then a comes before b, otherwise b comes before a.
Below are two examples for reference.`},{header:"Example 1: Changing the code above to output in descending order",slug:"example-1-changing-the-code-above-to-output-in-descending-order",content:`-- The PrintList() function is omitted here, with the same code as above local list = { 3, 7, 2, 5, 4 } -- Original list PrintList(list) -- Output the original list
table.sort(list, function(a, b) -- Sort the list return a > b -- Sort in descending order, if a > b, then a comes before b
end)
PrintList(list) -- Output the sorted list -- Output:
-- 3 7 2 5 4 (Original list)
-- 7 5 4 3 2 (Sorted list)`},{header:"Example 2: Sorting in a two-dimensional array",slug:"example-2-sorting-in-a-two-dimensional-array",content:`-- Function: Print the list
function PrintList(list) -- Output the list local listStr = "" for i = 1, #list do listStr = listStr .. "\\n" .. list[i][1] .. ", " .. list[i][2] end print(listStr)
end -- Original list
local list = { { 3, 5 }, { 7, 6 }, { 2, 2 }, { 5, 1 }, { 4, 3 } } PrintList(list) -- Output the original list -- Sort in descending order based on the first dimension of each item in the list
table.sort(list, function(a, b) return a[1] > b[1]
end)
PrintList(list) -- Output the sorted list -- Sort in descending order based on the second dimension of each item in the list
table.sort(list, function(a, b) return a[2] > b[2] end)
PrintList(list) -- Output the sorted list -- Output:
-- Original list:
-- 3, 5
-- 7, 6
-- 2, 2
-- 5, 1
-- 4, 3 -- Sorted based on the first dimension:
-- 7, 6
-- 5, 1
-- 4, 3
-- 3, 5
-- 2, 2 -- Sorted based on the second dimension:
-- 7, 6
-- 3, 5
-- 4, 3
-- 2, 2
-- 5, 1`},{header:"Reference of table",slug:"reference-of-table",content:`When there is no deep copy of a table, and it is directly copied, the newly obtained list2 is equivalent to a reference to the original list1, known as shallow copy. When you modify the elements in list2 obtained from shallow copy, the elements in list1 will also change because the two tables are referenced.
The above example code also follows this principle. Below is a new example to highlight this characteristic.`},{header:"Example: Shallow Copy",slug:"example-shallow-copy",content:`function PrintList(list) -- Output the list local listStr = "" for i = 1, #list do listStr = listStr .. list[i] .. " " end print(listStr)
end list1 = { 1, 2, 3, 4, 5 }
PrintList(list1)
-- 1 2 3 4 5 list2 = list1
PrintList(list2)
-- 1 2 3 4 5 -- Modify the second element in list2
list2[2] = 10
PrintList(list2)
-- 1 10 3 4 5 PrintList(list1)
-- 1 10 3 4 5`},{header:"Example: Deep Copy",slug:"example-deep-copy",content:`And what if you want to create a completely new list list2? Then you need to copy each element in the table one by one, also known as deep copy.
-- PrintList function code remains the same as above list1 = { 1, 2, 3, 4, 5 }
PrintList(list1)
-- 1 2 3 4 5 list2 = {} -- Create a new empty list -- Copy elements from list1 to list2
for index, value in pairs(list1) do table.insert(list2, value)
end
PrintList(list2)
-- 1 2 3 4 5 -- Modify the 2nd element of list2
list2[2] = 10
PrintList(list2)
-- 1 10 3 4 5 PrintList(list1)
-- 1 2 3 4 5 (no changes occurred)
In this example, modifying the elements in the deep copy list2 does not affect the original list1. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/mip.html",title:"Mixed integer programming",pathLocale:"/en/",contents:[{header:"Mixed integer programming",slug:"mixed-integer-programming",content:`Mixed-Integer Programming (MIP) is a powerful mathematical optimization technique used to solve problems where some of the decision variables are required to be integers. This article provides a step-by-step guide on creating and solving MIP models using Lua programming language in the context of MicroCity Web. Translate info
This section is translated with assistance from ChatGPT, and the translation may not be accurate. If you have any questions, please leave remark below.`},{header:"Creating a Mixed-Integer Programming Model",slug:"creating-a-mixed-integer-programming-model",content:`Creating an integer programming model object.
local mip = math.newmip() -- Assign the created model object to mip`},{header:"Setting the Objective Function",slug:"setting-the-objective-function",content:`In MicroCity Web, the first line of the model is the objective function, added using the mip:addrow() function.
You can choose to maximize or minimize the objective function. The usage is as follows: Maximize
Minimize mip:addrow(coeff, 'max') -- Maximize the objective function mip:addrow(coeff, 'min') -- Minimize the objective function`},{header:"Parameter Description and Examples",slug:"parameter-description-and-examples",content:`Parameter
Purpose mip
Mathematical model object. Sets the objective function for the model coeff
Coefficients of the objective function, a table variable. Determines the coefficients of the objective function in the model. "min" or "max"
Determines whether to minimize or maximize the objective function. coeff is a list of coefficients for the objective function, a table variable. Suppose you want to minimize the function
4x1+12x2+18x3
4x_1+12x_2+18x_3
4x1â€‹+12x2â€‹+18x3â€‹
the approach to adding the objective function is as follows:
-- Assuming you have already created the model object and stored it in the variable mip
-- Set the objective function to 4*x1 + 12*x2 + 18*x3, minimize
mip:addrow({4, 12, 18}, "min")`},{header:"Adding Constraints",slug:"adding-constraints",content:""},{header:"Adding Constraint Equations",slug:"adding-constraint-equations",content:`In MicroCity Web, use mip:addrow() to add the remaining constraint equations. The usage is as follows: â‰¥
= mip:addrow(cons, ">=", b) mip:addrow(cons, "==", b)`},{header:"Parameter Description",slug:"parameter-description",content:`Parameter
Purpose mip
The integer programming model object created at the beginning cons
Coefficients of the constraint equation. Like cons in setting the objective function, it's a table variable. Determines the coefficients of the variables in the constraint equation. "<=" or ">=" or "=="
Determines the relationship between the constraint equation and the right-hand side. b
The right-hand side of the constraint equation.`},{header:"Example",slug:"example",content:`The objective function has been set to 4x1+12x2+18x34x_1+12x_2+18x_34x1â€‹+12x2â€‹+18x3â€‹. Suppose you want to add two constraint equations for this function:
{x1+3x3â‰¥32x2+2x3â‰¥5
\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\end{matrix}\\right. {x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5â€‹
Add the corresponding constraint equations:
-- Add constraint: x1 + 3*x3 â‰¥ 3
mip:addrow({ 1, 0, 3 }, ">=", 3) -- Add constraint: 2*x2 + 2*x3 â‰¥ 5
mip:addrow({ 0, 2, 2 }, ">=", 5)
It can be noticed that the number of coefficients is the same as the number of variables in the objective function. Therefore, before programming, it is necessary to determine the total number of variables and arrange the positions of each variable.`},{header:"Setting Variable Types",slug:"setting-variable-types",content:`MicroCity's mathematical programming supports integer programming. The default variable range is non-negative real numbers (â‰¥0). Below is a detailed method for setting variable types.
You can set the i-th variable in the model as an integer variable or a 0-1 variable. If you don't set the variable to these types, it defaults to a non-negative real number. Integer Variable
0-1 Variable -- Set the first variable (first column, col 1) as an integer variable
mip:addrow('c1', 'int') -- Set the second variable (second column, col 2) as a 0-1 variable
mip:addrow('c2', 'bin')`},{header:"Model Solution and Output",slug:"model-solution-and-output",content:""},{header:"Model Solution",slug:"model-solution",content:`Since the objective function and constraint equations have been added, solving the model is straightforward:
mip:solve()
After executing this statement, the mathematical model stored in the variable mip is solved ğŸ‰`},{header:"Output",slug:"output",content:`After solving, you still need to output; otherwise, you won't know the results. Below are some commonly used functions for outputting the solution.
Get the value of the objective function:
mip['obj']
Get the value of the i-th variable:
mip['c'..i]
Here is a simple example from modeling to solving for reference. (It's just putting the pieces together)
Example:
minf=4x1+12x2+18x3s.t.{x1+3x3â‰¥32x2+2x3â‰¥5x1,x2,x3âˆˆN
minf=4x_1+12x_2+18x_3\\\\
s.t.\\left\\{\\begin{matrix} x_1+3x_3\\ge3 \\\\ 2x_2+2x_3\\ge5 \\\\ x_1,x_2,x_3\\in N
\\end{matrix}\\right. minf=4x1â€‹+12x2â€‹+18x3â€‹s.t.â©â¨â§â€‹x1â€‹+3x3â€‹â‰¥32x2â€‹+2x3â€‹â‰¥5x1â€‹,x2â€‹,x3â€‹âˆˆNâ€‹ N represents the set of natural numbers (non-negative integers) Script
local mip = math.newmip() -- Set objective functio
mip:addrow({4, 12, 18}, "min") -- Add constraints
mip:addrow({ 1, 0, 3 }, ">=", 3) -- x1 + 3*x3 â‰¥ 3
mip:addrow({ 0, 2, 2 }, ">=", 5) -- 2*x2 + 2*x3 â‰¥ 5 -- Set all variables as integers
for i = 1, 3 do mip:addrow('c'..i, 'int')
end -- Solve the model
mip:solve() -- Output the value of the objective function
print("Objective function value:", mip['obj']) -- Output the value of each variable
for i = 1, 3 do print("x"..i.."=",mip['c'..i])
end
Output
Objective function value: 42.0
x1= 0.0
x2= 2.0
x3= 1.0 Online Execution
Check this example in MicroCityWeb`},{header:"Some Modeling Techniques",slug:"some-modeling-techniques",content:""},{header:"Linearization",slug:"linearization",content:`Sometimes we encounter modeling problems with multiple subscripts, such as decision variables xijx_{ij}xijâ€‹, where iii and jjj are indices. In such cases, linearization encoding is necessary.
Suppose the decision variable itself has a shape of 3 rows and 4 columns, i.e.: Col 1
Col 2
Col 3
Col 4 x11x_{11}x11â€‹
x12x_{12}x12â€‹
x13x_{13}x13â€‹
x14x_{14}x14â€‹ x21x_{21}x21â€‹
x22x_{22}x22â€‹
x23x_{23}x23â€‹
x24x_{24}x24â€‹ x31x_{31}x31â€‹
x32x_{32}x32â€‹
x33x_{33}x33â€‹
x34x_{34}x34â€‹ Suppose the objective function wants to sum these decision variables, i.e. F=âˆ‘i=13âˆ‘j=14xijF=\\sum_{i=1}^3\\sum_{j=1}^4x_{ij}F=âˆ‘i=13â€‹âˆ‘j=14â€‹xijâ€‹. If you want to input this into the objective function, you can linearize it as x11+x12+...+x14+x21+...+x24+x31+...+x34x_{11}+x_{12}+...+x_{14}+x_{21}+...+x_{24}+x_{31}+...+x_{34}x11â€‹+x12â€‹+...+x14â€‹+x21â€‹+...+x24â€‹+x31â€‹+...+x34â€‹.
Since there are only two dimensions, you can use two for loops to achieve this:
local cons = {}
for i = 1, 3 do -- First dimension for j = 1, 4 do -- Second dimension cons[4 * (i - 1) + j] = 1 -- Fill in the coefficient -- The idea here is similar to carrying in arithmetic end
end`},{header:"Example: Assignment Model",slug:"example-assignment-model",content:`Now let's look at the specific usage of multi-dimensional linearization and its convenience using a practical example.
People A, B, C, and D deliver goods A, B, C, and D, respectively. The required time is shown in the table below. If each person delivers only one type of goods, which person should be assigned to deliver which type of goods to minimize the total time? Person\\Item
A
B
C
D A
14
9
4
15 B
11
7
9
10 C
13
2
10
5 D
17
9
15
13 Assuming goods A, B, C, D correspond to indices 1, 2, 3, 4, respectively, let xij=1x_{ij}=1xijâ€‹=1 represent person i delivering goods j, and xij=0x_{ij}=0xijâ€‹=0 represent person i not delivering goods j.
The mathematical model for the above problem can be represented as
minZ=âˆ‘i=14âˆ‘j=14cijxijs.t.{âˆ‘j=14xij=1,i=1,2,...,4âˆ‘i=14xij=1,j=1,2,...,4xij=0,1
minZ=\\sum_{i=1}^4\\sum_{j=1}^4c_{ij}x_{ij}\\\\
s.t.\\left\\{\\begin{matrix} \\sum_{j=1}^4x_{ij}=1, i=1,2,...,4 \\\\ \\sum_{i=1}^4x_{ij}=1, j=1,2,...,4 \\\\ x_{ij}=0,1
\\end{matrix}\\right. minZ=i=1âˆ‘4â€‹j=1âˆ‘4â€‹cijâ€‹xijâ€‹s.t.â©â¨â§â€‹âˆ‘j=14â€‹xijâ€‹=1,i=1,2,...,4âˆ‘i=14â€‹xijâ€‹=1,j=1,2,...,4xijâ€‹=0,1â€‹
Solution code
-- Efficiency matrix
local cost = { {14, 9, 4, 15}, {11, 7, 9, 10}, {13, 2, 10, 5}, {17, 9, 15, 13}
} local mip = math.newmip() -- Create the objective function
local coeff = {}
for i = 1, 4 do for j = 1, 4 do -- Easily convert the 2D array to a 1D array here coeff[4 * (i - 1) + j] = cost[i][j] end
end mip:addrow(coeff, "min") -- Add constraints
for k = 1, 4 do -- Control the value of the first dimension local cons = {} for i = 1, 4 do for j = 1, 4 do if i == k then -- Sum for j, check i cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end mip:addrow(cons, "==", 1)
end for k = 1, 4 do -- Control the value of the second dimension local cons = {} for i = 1, 4 do for j = 1, 4 do if j == k then -- Sum for i, check j cons[4 * (i - 1) + j] = 1 else cons[4 * (i - 1) + j] = 0 end end end mip:addrow(cons, "==", 1)
end -- Solve the model
mip:solve() -- Output the value of the objective function
print("Objective function value:", mip['obj']) -- Output the decision variables
for i = 1, 4 do -- First dimension for j = 1, 4 do -- Second dimension local x = mip['c' .. 4 * (i - 1) + j] if x ~= 0 then print("x[" .. i .. "][" .. j .. "]=", x) end end
end
Output
Objective function value: 29.0
x[1][3]= 1.0
x[2][1]= 1.0
x[3][4]= 1.0
x[4][2]= 1.0 Online Execution
Check this example in MicroCityWeb Result
Person
Item x13=1x_{13}=1x13â€‹=1
A
C x21=1x_{21}=1x21â€‹=1
B
A x34=1x_{34}=1x34â€‹=1
C
D x42=1x_{42}=1x42â€‹=1
D
B`},{header:"Handling Intermediate Variables",slug:"handling-intermediate-variables",content:`Sometimes, there are intermediate variables in a model that must have corresponding positions in the matrix to be solved, and these intermediate variables do not participate in the calculation of the objective function value. The coefficients of the intermediate variables at their corresponding positions can be set to 0.
Suppose x1,x2,x3,x4x_1, x_2, x_3, x_4x1â€‹,x2â€‹,x3â€‹,x4â€‹ are decision variables, and y1,y2y_1, y_2y1â€‹,y2â€‹ are intermediate variables. The objective function is:
z=âˆ‘i=14xi
z=\\sum_{i=1}^4x_i
z=i=1âˆ‘4â€‹xiâ€‹
The coefficients of the objective function can be set as follows:
local fcons = {1, 1, 1, 1, 0, 0}
-- The first 4 elements correspond to decision variables,
-- and the last 2 elements correspond to intermediate variables
Afterward, you can proceed with the general process ğŸ˜`}]},{path:"/en/notes/network.html",title:"Operating Networks",pathLocale:"/en/",contents:[{header:"Operating Networks",slug:"operating-networks",content:""},{header:"Network Topology",slug:"network-topology",content:`Network topology, in simple terms, refers to a network with nodes and connections between them. If we think of connections as roads, then you need to solve the following problems: Is this road one-way or two-way?
Where does the road start? Where does it end? In general, each road in a network diagram is considered to be one-way. If a two-way road is needed, you simply need to add a road in the opposite direction. Like this: This way, each road has a direction. It is common to use the symbol O for the starting point and the symbol D for the destination point. Using O and D, the direction of each road can be clearly described.
For the example in the above diagram, the road at the top has O=1, D=2, so the direction is described as from 1 to 2; the road at the bottom has O=2, D=1, so the direction is described as from 2 to 1.`},{header:"Building Network Topology using Functions",slug:"building-network-topology-using-functions",content:`MicroCity can handle networks, and the specific usage of all functions can be found in the reference document: 4.6 Networks
Here are some simple methods for creating network objects in MicroCity:
local network = CreateNetwork() Create an empty network object and return it. network is the returned empty network object.
After creating the object, you can use functions like AddLink and DelLink to create connections in the network object. See the reference document for specific usage.
local network, nodes, links = CreateNetwork(Lines)
Here, Lines is a vector graphic object of type Line. In this usage, the CreateNetwork() function in MicroCity can directly add starting points and endpoints to the road connections and automatically label the O and D points in the returned links object.
In other words, you only need to provide the network connections, and the remaining work of topology can be automatically completed by the function. I believe this may be the most commonly used method for creating network diagrams and conducting topology.`},{header:"Simple Example of Network Topology",slug:"simple-example-of-network-topology",content:`-- Open the connection layer
Shapes = Open("Shapes.shp") -- Create network topology
network, network_nodes, network_links = CreateNetwork(Shapes) -- Create a layer to store the topologized network nodes
Nodes = CreateShapes("Nodes", "point")
-- Copy the network nodes obtained from topoization to the layer
AddField(Nodes, "ID", "int")
for i = 1, GetRecCount(network_nodes) do CopyShapeTo(Nodes, 0, 0, GetShape(network_nodes, i))
end -- Create a layer to store the topologized network connections
Links = CreateShapes("Links", "line")
-- Copy the original attribute fields from the network connections to the layer
for i = 1, GetFieldCount(Shapes) do AddField(Links, GetField(Shapes, i))
end
-- Add attribute fields for the connections, and corresponding data will be added later using functions
AddField(Links, "ID", "int")
AddField(Links, "O", "int")
AddField(Links, "D", "int")
AddField(Links, "IMPEDANCE", "double")
AddField(Links, "DIRECTION", "int")
AddField(Links, "CAPACITY", "double")
-- Copy the network lines obtained from topoization to the layer (including corresponding data)
for i = 1, GetRecCount(network_links) do CopyShapeTo(Links, 0, 0, GetShape(network_links, i))
end -- Update the layers
Update(Nodes)
Update(Links) The example is modified from the built-in editor of MicroCity. Although the network connection was established at the beginning, it is possible that during the topology process, the nodes on the connection may overlap, causing the continuous connection to be divided into multiple segments. Therefore, the resulting Links layer may be different from the input layer. The topology nodes Nodes obtained from the topology process correspond to the resulting links Links, so it is recommended to use the topological processing result of the Links layer as the connection between network nodes.`},{header:"Pitfall: Creating Network Objects",slug:"pitfall-creating-network-objects",content:`If you need to create a network again using the CreateNetwork(Nodes, Links) function, you need to retain the attributes added during the topological process, otherwise there will be errors in network initialization:
AddField(Links, "ID", "int")
AddField(Links, "O", "int")
AddField(Links, "D", "int")
AddField(Links, "IMPEDANCE", "double") -- impedance
AddField(Links, "DIRECTION", "int") -- direction
AddField(Links, "CAPACITY", "double") -- capacity
If you are only doing a one-time topology of the network and will not use the topologically processed network to create a network object again, you still need to create the above attributes first. The topologically processed data is not filled in according to the attribute names, but according to their positions.
If only O and D attributes are created, the ID data will be filled in the O attribute, and the O data will be filled in the D attribute. If only the ID, O, and D attributes are created in the order mentioned above, the data will be filled correctly due to the data order being filled based on their positions.`},{header:"CopyShapeTo Function",slug:"copyshapeto-function",content:`The CopyShapeTo() function is used in the topological process to copy a Shape object to the corresponding position in the Shapes layer and perform position transformation in the Shapes layer based on the input dx and dy. Here, dx and dy represent the displacements in the x and y directions (referred to as deltax and deltay).
CopyShapeTo(TargetShapes, dx, dy, Shape1 [, Shape2, ...])
Based on the usage of the function, it also supports copying to multiple layers and then performing the transformation. If you only want to copy the shape to the corresponding position of the corresponding layer without transformation, you can set dx and dy to 0, like this:
CopyShapeTo(TargetShapes, 0, 0, Shape1 [, Shape2, ...])
For the specific usage of the CopyShapeTo() function, please refer to 4.3 Vector Graphics and Tables`},{header:"Using the Network Topology Algorithm",slug:"using-the-network-topology-algorithm",content:"After performing the network topology, you can use the built-in functions to solve many problems, such as generating a minimum spanning tree, finding the shortest path, or calculating the shortest distance. This article will take the calculation of the shortest path and its length as an example to explain the process and pitfalls of calculating the shortest path."},{header:"Calculating the Shortest Path and Its Length",slug:"calculating-the-shortest-path-and-its-length",content:"To calculate the shortest path, it is necessary to determine which two points in the network the shortest path is between. Here, startID and endID represent the starting point and the endpoint, respectively. Let's assume that you have already created a network object and stored it in a variable named Network. If you don't know how to create a network graph, you can refer to the Network Topology process described above."},{header:"Creating a Minimum Spanning Tree",slug:"creating-a-minimum-spanning-tree",content:`Step 1: First, create a minimum spanning tree with startID as the starting point. Theoretically, after creating a minimum spanning tree with the starting point, you can obtain the shortest distance from the starting point to any point on the network. You can use the GenSTPTree() function to create a minimum spanning tree.
GenSTPTree(Network, startID [, endID])
The endID here is not necessary, but if it is available, you can provide it to the function. In other words, you have two ways to accomplish this:
GenSTPTree(Network, startID) -- Method 1
GenSTPTree(Network, startID, endID) -- Method 2 (recommended)
It is generally believed that the more complete the information provided, the better the execution effect. Since you already know endID before calculating the shortest path, it is recommended to provide it to the function. The usage of this function with brackets has been explained here, and this notation will be used directly in the following text. Step 2, obtain the information corresponding to the shortest path. As mentioned earlier, the shortest route between two points can only be determined after the starting point and the destination point are determined. Since the minimum spanning tree was created using the starting point startID earlier, now we only need to provide the destination point endID in order to obtain the shortest path and its length. The following explains the methods to obtain the shortest path length and the shortest path using the Network object.`},{header:"Obtaining the Shortest Path Length",slug:"obtaining-the-shortest-path-length",content:`MicroCity's documentation provides three ways to obtain the shortest path.
The first method is used when the shortest path spanning tree has already been calculated and the information for the starting point has been inputted. Therefore, now only the information for the destination point needs to be provided (even if it has been provided already). The function requires a network object Network and the endpoint endID is used as follows:
local len = GetSTPLen(Network, endID)
The second method calculates the shortest path length between two points on the network by providing the starting point startID and the destination point endID. This usage does not require generating the shortest path spanning tree before calculating the shortest path and can be used directly. The Network parameter represents the network object and is used as follows:
local len = GetSTPLen(Network, startID, endID)
The third method calculates the shortest path length between two points on the network by providing the xy coordinates of the starting and destination points. This usage also does not require generating the shortest path spanning tree before calculating the shortest path and can be used directly. The coordinates of the starting point are set as x1 and y1, the coordinates of the destination point are set as x2 and y2, and the Network parameter represents the network object and is used as follows:
local len = GetSTPLen(Network, x1, y1, x2, y2)`},{header:"Obtaining the Shortest Path",slug:"obtaining-the-shortest-path",content:`MicroCity's documentation provides three pieces of information that can be obtained, namely: The sequence of point or line IDs
The sequence of point or line indices
The sequence of point or line shapes. For detailed usage of the functions, please refer to 4.6 Networks - Algorithms. Here, only the second method, which returns the sequence of point or line indices, will be used as an example.
To return the sequence of points:
GetSTPPath (Network, endID, "iNodeShp")
To return the sequence of lines:
GetSTPPath (Network, endID, "iLinkShp")
This way, the sequence of point or line indices can be obtained.`},{header:"Pitfall: Sequences",slug:"pitfall-sequences",content:`In Getting Started with Lua, we introduced sets in Lua, which provide rich features to assist in code writing. However, we have not heard of sequences. A sequence is something like this:
local x, y = GetCenterXY(Shapes) -- using this function temporarily
Here, x and y form a sequence. Here's another scenario:
GetDistance (x1, y1, x2, y2 [, x3, y3, ...]) -- using another function here temporarily
In this case, the more points that are inputted, the more return values there will be. If four points are inputted, it can be handled like this:
-- Normal case
d1, d2, d3, d4 = GetDistance(x1, y1, x2, y2, x3, y3, x4, y4) -- Only the first two return values can be kept
d1, d2 = GetDistance(x1, y1, x2, y2, x3, y3, x4, y4) -- Of course, only one return value can be kept as well
d1 = GetDistance(x1, y1, x2, y2, x3, y3, x4, y4)
The number of input parameters and output parameters in the above function are related. If n points are inputted as parameters, n distances will be returned. However, for the network topology, when returning the shortest path, the returned values are always parameter sequences, and I don't know how many parameters the function will give me; and when there are too many output parameters, it is also not feasible to manually create many variables to store these parameters.
-- Wrong approach:
local indexList = GetSTPPath(Network, endID, "iLinkShp")
-- The GetSTPPath() function does not return a table
-- The indexList obtained here is only the index of the first Link, which is a numerical value.
Since the left side of the equal sign cannot be changed, let's make changes on the right side. Do you remember how to define a simplest table?
local list = {1, 2, 3, 4, 5}
The [to_be_replace[x]] on the right side can actually be seen as a sequence. So, as long as you add parentheses to the return value of a function, you can pick them all up ( â€¢Ì€ Ï‰ â€¢Ì )âœ§
local indexList = { GetSTPPath(Network, endID, "iLinkShp") }
The indexList obtained using the above method is a variable of table type. Then, you can start performing various operations on the collection ğŸ˜‹ This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/oop.html",title:"Object-Oriented Programming",pathLocale:"/en/",contents:[{header:"Object-Oriented Programming",slug:"object-oriented-programming",content:`Object-Oriented Programming (OOP) is a programming paradigm that abstracts real-world entities into objects in the program world. Objects communicate with each other through message passing, forming the functionality of a program. According to online sources, OOP has three main characteristics: encapsulation, inheritance, and polymorphism. However, in this simulation, encapsulation is the most frequently used, while the opportunities for inheritance and polymorphism are rare. Additionally, I haven't implemented object message passing in MicroCity yet. If I do, I will update this article accordingly. Therefore, the following mainly introduces how to use encapsulation in Lua code for MicroCity. Tips
The code examples in this article are applicable to MicroCityWeb and may not necessarily work for the desktop version of MicroCity. Furthermore, this article is based on personal insights and does not guarantee absolute correctness in terms of concepts.`},{header:"Basic Concepts of Object-Oriented Programming",slug:"basic-concepts-of-object-oriented-programming",content:""},{header:"Classes and Objects",slug:"classes-and-objects",content:`In simple terms, a class is a template for objects, and an object is an instance of a class.
A class is a fundamental concept in object-oriented programming that represents a category of things. The concept of a class can be understood as a category of objectsâ€”such as AGVs, shelves, and gantry cranes. You can think of a class as a template for a category of things, and objects are specific instances created based on this template.
A good example is the mentioned shelf. A shelf is a class, and a specific shelf is an object. The shelf class contains various attributes, such as the shelf's location and the items it holds. Different shelf objects created from the shelf class belong to the shelf class, such as Shelf 1, Shelf 2, etc. Although their attributes may differ, they are all objects of the shelf class.`},{header:"Class Attributes and Methods",slug:"class-attributes-and-methods",content:"In MicroCity simulation, based on my personal experience, classes usually have attributes but not necessarily methods. Continuing with the example of a shelf mentioned earlier, attributes are the characteristics of a class, such as the location of the shelf and the items on the shelf. Methods represent the behaviors of a class and are usually implemented with functions, such as an AGV lifting or placing a shelf, an AGV moving, or driving a shelf."},{header:"Advantages and Disadvantages of Using Object-Oriented Programming in Simulation",slug:"advantages-and-disadvantages-of-using-object-oriented-programming-in-simulation",content:""},{header:"Advantages",slug:"advantages",content:`In MicroCity, when dealing with scenarios involving the movement of multiple objects of the same type and playing animations of object movements (such as AGVs, shelves, and gantry cranes), a considerable amount of coordinate calculations and position settings are required. If each object needs to be implemented individually, the code for modifying the coordinate of each object will become very long, making it difficult to maintain. By using the object-oriented programming paradigm, data processing code can be encapsulated into individual objects, making the code more readable and maintainable.
Furthermore, if multiple objects of the same type need to be created in a scene, each object may have different parameters. By encapsulating using object-oriented methods, each object's parameters can be encapsulated within the objects themselves. When the simulation process or scale becomes more complex, the reusability of the code can be increased.
For simulations, the most important aspect is understanding the business process and business logic. Using object-oriented programming can make the simulation's business process and logic more clear, improve code readability, and increase maintainability. Furthermore, when it is necessary to modify the business logic of a class of objects, you only need to enter the class and make the modification. For example, modifying the scheduling algorithm for all gantry cranes in a port only needs to be done once because all gantry cranes share the same scheduling algorithm.
Based on personal experience, when using object-oriented methods to encapsulate objects, it is mostly intended to create a generic object and then create multiple objects of the same type in subsequent simulations automatically or manually, with different parameters for each object. This increases code reusability and improves code readability, providing convenience for future maintenance and modifications, and lays a foundation for large-scale simulations.`},{header:"Disadvantages",slug:"disadvantages",content:"If the simulation is small in scale and involves simple operations with a small codebase, it is not recommended to use object-oriented methods for code encapsulation. Using object-oriented methods will increase the number of lines of code, and may make the code appear more complex than the original problem. (Of course, there will be no consequences if you still choose to use it, except that it may look strange.) Specifically, you can refer to the provided code examples in the following sections and notice that most of the code is dedicated to describing classes and their business logic, while the code for the business process is simple and occupies a small proportion."},{header:"Implementation of Object-Oriented Programming in Lua",slug:"implementation-of-object-oriented-programming-in-lua",content:"In Lua, the concept of object-oriented programming is typically implemented using tables. A table is a data structure in Lua that can represent arrays, dictionaries, objects, etc. In object-oriented programming, tables can be used to represent objects."},{header:"Example",slug:"example",content:`Since the objects created in MicroCity are tables, we can encapsulate the object's attributes directly in a table and return that table when creating an object.
Here's an example:
-- The function will return an AGV object
function AGV() -- Create a 3D object of an AGV in MicroCity local agv = scene.addobj('/res/agv.glb') -- Set the properties of the object agv.position = {0, 0, 0} -- Set the position of the object agv.speed = 1 -- Set the speed of the object function agv:move(dx, dy, dz) agv.position = {agv.position[1] + dx, agv.position[2] + dy, agv.position[3] + dz} -- Modify the object's coordinates agv:setpos(agv.position[1], agv.position[2], agv.position[3]) -- Set the object's position scene.render() -- Render the scene (Not recommended to call here, just for demonstration purposes) end return agv -- Return the object
end -- Object usage
local obj = AGV() -- Create an object
obj:move(1, 0, 0) -- Move the object 1 unit in the x direction
Or you can choose to encapsulate the object within a table and return that table after creating the object.
-- The function will return an AGV object
function AGV() -- Set the object's properties directly in the table to be returned local agv = { object = scene.addobj('/res/agv.glb'), position = {0, 0, 0}, speed = 1 } function agv:move(dx, dy, dz) agv.position = {agv.position[1] + dx, agv.position[2] + dy, agv.position[3] + dz} -- Modify the object's coordinates agv.object:setpos(agv.position[1], agv.position[2], agv.position[3]) -- Set the object's position scene.render() -- Render the scene (Not recommended to call here, just for demonstration purposes) end return agv -- Return the object
end -- Object usage
local agv = AGV() -- Create an object
agv:move(1, 0, 0) -- Move the object 1 unit in the x direction
There is also another method to create objects using setmetatable, this belongs to advanced usage, but I feel like it is not used very often. However, it seems like this method can be used to achieve class inheritance, if you are interested, you can search for it yourself. Here is the code implementation of the shelf class that I wrote for an earlier assignment as a reference. (Now I feel like this class is not written very well ğŸ˜‚, for example, x and y can be replaced with pos = {x, y}, and x_origin and y_origin can be replaced with origin = {x, y}).
-- Shelf
Shelf = { x = 1, y = 1, cargo = {"box"}, -- Items on the shelf x_origin = 1, -- Shelf's original x coordinate y_origin = 1 -- Shelf's original y coordinate
} function Shelf:New(x, y) local self = {} setmetatable(self, { __index = Shelf }) self.__index = self self.x = x self.y = y -- Set the original coordinates self.x_origin = x self.y_origin = y return self
end`},{header:"Types of Classes",slug:"types-of-classes",content:`Here, I would like to summarize the main types of classes that I have created. 3D entity classes: These classes mainly control the movement of 3D entities, such as AGVs and cranes. Most of them have physical entities that need to be moved. Some even include sub-objects, such as crane objects that have hoists, ropes, and cranes as sub-objects.
Data model classes: These classes represent various entities in a system, such as yards, shelves, and goods. For example, a yard class contains data about the yard's dimensions, the goods in the yard, and the containers in the yard. It should be noted that I do not strictly categorize these types, as certain classes may possess the characteristics of multiple types. For instance, an AGV class also includes data about the AGV's position and speed, while a shelf class merely stores the shelf model. The movement of the shelf model is controlled by the AGV, and the more important function of the shelf class is to record the information of the goods on the shelf. Therefore, I consider these types as rough distinctions, and the specific implementation should be based on the actual business processes and requirements. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/plots.html",title:"General Drawing Code",pathLocale:"/en/",contents:[{header:"General Drawing Code",slug:"general-drawing-code",content:`This section provides some well-written drawing objects that can be directly used when visualizing data. Info
All open source code on this page follows the MIT license and can be used freely. However, please retain the copyright information when publicly released.`},{header:"Importing Library Files",slug:"importing-library-files",content:`First, let's introduce how to use library files. "Library files" refer to pre-packaged drawing functions, and there are three methods to import files into MicroCity Web for use.`},{header:"Method 1: Code-Based Import",slug:"method-1-code-based-import",content:`ğŸ‘ It is recommended to use this method to import library files, so that you can ensure that the latest version of the library is used.
Taking the import of Histogram and Subplot as an example, the code to import the library files is as follows:
print('Downloading dependencies to the virtual disk...')
-- Download the histogram code to the virtual disk
os.upload('https://www.zhhuu.top/ModelResource/libs/Histogram.lua')
-- Download the subplot code to the virtual disk
os.upload('https://www.zhhuu.top/ModelResource/libs/Subplot.lua')
print('Download completed')`},{header:"Method 2: Download Code Files and Import",slug:"method-2-download-code-files-and-import",content:`Go to the Code File Download section to download the required library files, then import the file into MicroCity Web, and finally reference the file to use it.
Taking the import of a histogram as an example, the code to import is as follows:
require("Histogram") -- Import the histogram`},{header:"Method 3: Copying the Code",slug:"method-3-copying-the-code",content:"Unless you need to modify the function's functionality or logic, it is not recommended to do so. The code for each function is available in the Code section."},{header:"Histogram",slug:"histogram",content:`A histogram is generally used to display the frequency or frequency distribution of each data value in a dataset.
It divides the data into several intervals (or "bins") with a certain interval, then draws a bar chart of the frequency (or frequency) on the vertical axis for each interval, reflecting the distribution of the data.
Here is an example of a histogram drawn using a histogram object (function).`},{header:"Importing the Histogram",slug:"importing-the-histogram",content:`First, import the code for the histogram. For specific import methods, please refer to Importing Library Files.
The filename for the histogram is Histogram.lua, and the code to import the histogram is:
require("Histogram") -- Import the histogram`},{header:"Creating a Histogram Object",slug:"creating-a-histogram-object",content:`Create a histogram object:
local plot = Histogram(list) -- list represents the dataset
You can also set the properties of the graph when creating the object.
local plot = Histogram(list, {range={40,90,0,100}, scale={10, 50}, fdisp=function(x) return (x/n*100).."%" end})
Setting the properties is not necessary and can be done based on your needs. In this example, only the range, scale, and fdisp properties are set.`},{header:"Setting Histogram Properties",slug:"setting-histogram-properties",content:`The example provided above demonstrates setting histogram properties. Based on the code, more properties can be set. Please refer to the table below for more details: Attribute Value
Function
Example origin
Set the origin point of the graph (bottom left corner)
origin = {-50, -50}, sets the origin point of the graph at the position (-50, -50) size
Set the length of the graph's x and y axes, which can be understood as the size of the graph
size = {100, 100}, sets the x and y axes length of the graph to 100 scale
Set the scale of the x and y coordinate axes
scale = {3, 2}, sets the scale of the x and y axes of the graph to 3 and 2 respectively axislabel
Set the labels of the x and y axes
axislabel = {"x", "y"}, sets the labels of the x and y axes of the graph to "x" and "y" respectively range
Set the display range of the x and y coordinate axes
range = {0, 10, 0, 20}, sets the range of the x axis to [0,10] and the y axis to [0,20] filled
Set whether to fill the bar chart
filled = false, sets the bar chart to hollow. The default style is filled fdisp
Set the display function of the data label, which returns the quantity by default. Setting the display function of the data label will also affect the display of the y-axis scale
fdisp = function(v) return (v/n*100).."%" end, sets the data label to be displayed as a percentage (assuming n is the sample size)`},{header:"Advanced Usage of Histogram",slug:"advanced-usage-of-histogram",content:"ğŸ“ˆ Dynamically Refreshing Data Graph Modify the data in the graph. Here we take adding data to the graph as an example, where rnd is the added data. The value of plot.data can also be modified directly. table.insert(plot.data, rnd) Refresh the graph plot:refresh()"},{header:"Example",slug:"example",content:""},{header:"Basic Usage Example: Drawing a Poisson Distribution",slug:"basic-usage-example-drawing-a-poisson-distribution",content:`require("Histogram") -- Import the Histogram library local seed = math.randomseed(1, { distribution = "poisson", mu = "3"
})
local list = {seed:random()} -- Static drawing
for i = #list, 400 do table.insert(list, seed:random())
end local histplot = Histogram(list, { range = {0, 10, 0, 50}, scale = {1, 5}
})
scene.render()`},{header:"Advanced Usage Example: Dynamically Refreshing the Poisson Distribution Graph",slug:"advanced-usage-example-dynamically-refreshing-the-poisson-distribution-graph",content:`This is an example of drawing a Poisson distribution and dynamically refreshing the data graph. Assuming that the Histogram object has been imported and the scene is set to display in 2D.
require("Histogram") -- Import the Histogram library local seed = math.randomseed(1, { distribution = "poisson", mu = "3"
})
local list = {seed:random()} local histplot = Histogram(list, { range = {0, 10, 0, 50}, scale = {1, 8}
})
scene.render() -- Dynamically drawing
local count = 1
while count < 1000 and scene.render() do local rnd = seed:random() table.insert(histplot.data, rnd) histplot:refresh() count = count + 1
end
scene.render()`},{header:"Subplot",slug:"subplot",content:"A Subplot is used to solve the positioning and sizing issues when placing multiple graphs in a single interface. The name is borrowed from MATLAB."},{header:"Importing Subplots",slug:"importing-subplots",content:`First, import the code for subplots. The specific import method can be found in Importing Library Files.
The filename of the subplot is Subplot.lua, and it is referenced as follows:
require("Subplot") --referencing the subplot`},{header:"Subplot Attribute Settings",slug:"subplot-attribute-settings",content:`Here we will provide a detailed explanation of the attributes of the subplot. Setting the attributes is not mandatory and can be done based on your needs. Attribute
Function
Example span
Sets the spacing between subplots
span=10, sets the spacing between subplots in all four directions to 10 diag
Sets the position and size of the subplot by specifying the coordinates of the two diagonal points
diag = {-80, -70, 80, 70}, sets the diagonal range of the subplot from coordinates (-80,-70) to (80,70)`},{header:"Reading Subplot Values",slug:"reading-subplot-values",content:`After creating the subplot with the specified attributes, or modifying the subplot attributes and refreshing, you can read the calculated values of the subplot to obtain the original positions and sizes of each subplot in the Subplot module. You can mainly read these values using the following attributes. Note
Here, it is assumed that the subplot object is stored in the subplot variable after creating it. Calculated Attribute
Meaning
Example originpt
The original position of each subplot in the Subplot object
You can obtain the original position of the subplot in the ith row and jth column using subplot.originpt[i][j][1] and subplot.originpt[i][j][2] psize
The size of each subplot in the Subplot object
You can obtain the width and height of the subplot in the subplot using subplot.psize[1] and subplot.psize[2] respectively. (Assuming that all subplots have the same size)`},{header:"Example",slug:"example-1",content:`Here is an example of drawing the display range of the subplots. It is assumed that the Subplot module has already been imported, and the scene has been set to display in 2D.
In this example, the display range of each subplot in a 2-row, 3-column subplot is drawn as a rectangle. The range of each subplot is represented by four gray points, and the position of each subplot is represented by a blue rectangle.
require("Subplot") --import the subplot code local subplot = Subplot(2, 3, {span = 10}) -- Drawing the boundary points of the Subplot object
local lb = scene.addobj("points",{size = 10, vertices={subplot.diag[1],subplot.diag[2],0}})
local lt = scene.addobj("points",{size = 10, vertices={subplot.diag[1],subplot.diag[4],0}})
local rb = scene.addobj("points",{size = 10, vertices={subplot.diag[3],subplot.diag[4],0}})
local rt = scene.addobj("points",{size = 10, vertices={subplot.diag[3],subplot.diag[2],0}})
-- Drawing Range
for i = 1, subplot.row do
for j = 1, subplot.col do
scene.addobj("polyline", {size = 8, color = "blue",
vertices={
subplot.originpt[i][j][1]+subplot.psize[1], subplot.originpt[i][j][2], 0,
subplot.originpt[i][j][1], subplot.originpt[i][j][2], 0,
subplot.originpt[i][j][1], subplot.originpt[i][j][2]+subplot.psize[2], 0,
subplot.originpt[i][j][1]+subplot.psize[1], subplot.originpt[i][j][2]+subplot.psize[2], 0,
subplot.originpt[i][j][1]+subplot.psize[1], subplot.originpt[i][j][2], 0,
}
})
end
end
scene.render()`},{header:"Code",slug:"code",content:"You can remove the scene.setenv code at the beginning of the script, depending on the combination of your code. The scene.render() in the code is to refresh the image when dynamically drawing."},{header:"Code File Download",slug:"code-file-download",content:`Please find the list of code files in ModelResource/libs Name
Link Histogram
ModelResource/libs/Histogram.lua Subplot
ModelResource/libs/Subplot.lua ğŸ”—The links in the table above point to the GitHub repository. You can view the code directly on GitHub or download the files to your local machine for use. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/timelapse.html",title:"Advancement of Simulation Time",pathLocale:"/en/",contents:[{header:"Advancement of Simulation Time",slug:"advancement-of-simulation-time",content:"The advancement of time in simulation refers to how the simulation time is progressed during the simulation process."},{header:"Classification of Time Advancement Methods",slug:"classification-of-time-advancement-methods",content:`There are three main types of commonly used methods for advancing simulation time: Event Scheduling Method: The event scheduling method is an event-based simulation method that progresses time by sorting the events in the simulation system and executing activities in the order of their occurrence.
Fixed Increment Advancement Method: The fixed increment advancement method refers to fixing a time increment during the simulation process. After setting the initial time, the simulation progresses by incrementing the time based on the set increment.
Activity Event Scanning Method: For systems with high uncertainty, time advancement is achieved by scanning the events occurring in the system and executing the corresponding activities. This method may be more difficult to implement and can result in inaccurate time advancement (with errors), which could be due to my insufficient expertise. ğŸ˜¥`},{header:"Example",slug:"example",content:""},{header:"Event Scheduling Method",slug:"event-scheduling-method",content:`The event scheduling method is an event-based simulation method that progresses time by sorting the events in the simulation system and executing activities in the order of their occurrence. During the simulation process, the simulation system progresses time to the next event and executes the corresponding activities based on the current simulation time and remaining events.
The event scheduling method can be divided into the following three main steps, which are also the main steps of the control program for event scheduling: Time Scanning: Determines the next event occurrence time and advances the simulation clock to that moment.
Event Identification: Accurately identifies the event to occur.
Event Execution: Accurately executes the event that occurs. The basic principle flowchart of the event scheduling method is as follows:
For the specific implementation of the event scheduling method in MicroCityWeb, please refer to Discrete Event Simulation and Program Control - Coroutines.`},{header:"Fixed Increment Advancement Method",slug:"fixed-increment-advancement-method",content:"The fixed increment advancement method refers to progressing time by a fixed step length starting from the initial time during the simulation process. Within each step length, if no event occurs, the simulation clock advances by a unit of time T. If there are several events within the step, they are executed in order, and these events are considered to have occurred at the end of the step. Example Problem"},{header:"Code Flow Example",slug:"code-flow-example",content:`while scene.render() do t = t + dt if t % cycle ~= work_time then d = d + v * dt print("Time after departure:", t, "hours") else print("Time after departure:", t, "hours, resting") end car:setpos(CastToLine(d)) -- linear trajectory os.sleep(200)
end This is the main code flow and cannot be directly used. The last part of Simulation Idea for Automatic Warehouse mentions the improvement space and implements the global simulation clock, ultimately achieving the time advancement method. It also implements non-fixed increment advancement, as detailed in the following section.`},{header:"Change from Event Scheduling to Main Clock Advancement in Automatic Warehouse Simulation",slug:"change-from-event-scheduling-to-main-clock-advancement-in-automatic-warehouse-simulation",content:`Specifically, the following changes were made based on the original: Most os.sleep() related to the event scheduling method were removed. Due to the simplicity of the simulation process, the event scheduling method related to cargo loading and unloading was retained to optimize resource utilization.
A global simulation clock was set to change the mindset of the Agv:Move() function from "executing tasks and refreshing the scene with a fixed step length" to "monitoring changes in simulation clock duration, executing tasks based on the duration changes, and refreshing the scene".
Added simulation speed adjustment. From the above changes, it can be seen that the core of the simulation shifted from event tasks to the simulation clock. The part of scene refresh utilized os.clock().`},{header:"Non-Fixed Increment Advancement Method",slug:"non-fixed-increment-advancement-method",content:`Here is a simple example about the time advancement method and the os.clock() function, modified from the built-in cube rotation example in MicroCityWeb. In this example, os.clock() is used to calculate CPU running time, in order to achieve a certain ratio between simulated time and real-world time. The specific ratio can be adjusted by the simspeed (simulation speed) parameter.
local obj = scene.addobj('box') -- Initial position
local x = 1
local y = 1
local z = 0 local rx, ry = 0.1, 0.1 -- rotation speeds in the x and y directions
local simspeed = 10 -- simulation speed local t = 0 -- global simulation clock
local t0 = os.clock() -- record the start of the simulation time
while scene.render() do local dt = os.clock() - t0 -- calculate the time difference since the last recorded time t = t + dt -- simulate the corresponding length of time that has passed on the simulation clock -- Set the rotation position of the cube at this moment x = x + rx * dt * simspeed y = y + ry * dt * simspeed obj:setrot(x, y, z) t0 = os.clock() -- record the simulation time
end
Related information: When the simulation speed simspeed is set to 1, it indicates that the simulation clock is running at the same speed as the real-world clock. simspeed can be considered as an acceleration factor.
dt represents the time difference between two recorded times, and the time step in the simulation is calculated based on dt*simspeed.
Info
It should be noted that the value of the time increment dt is generally not the same in each loop cycle, and its specific value generally depends on the computer's processing power. Tips
Sometimes there may not be much time-consuming operation between two recorded times, and the calculated value of dt may be 0. Generally, there is a scene.render() between two time recordings, which usually ensures that a non-zero time difference can be calculated between the two samples. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/tools.html",title:"Tools",pathLocale:"/en/",contents:[{header:"Tools",slug:"tools",content:"Tools that may come in handy"},{header:"Third-party Tools",slug:"third-party-tools",content:`Including software, websites, etc. MapShaper Map editor. It can edit .geojson files and export them as .shp files.
Three.js Editor Online 3D object editor for Three.js.`},{header:"External Functions",slug:"external-functions",content:"Some external functions for MicroCity Web"},{header:"Instructions",slug:"instructions",content:`It is recommended to import functions online to ensure the use of the latest version of functions. You can also choose to download them locally and then upload for use.
Online import example
print('Downloading dependency library to virtual disk...')
os.upload('https://www.zhhuu.top/ModelResource/libs/file_name.lua')
print('Download complete')`},{header:"Importing functions",slug:"importing-functions",content:`If the function file name is abc.lua, importing the function completes the process.
require("abc")`},{header:"Function List",slug:"function-list",content:`Mostly homemade functions.
Since the files are all hosted on GitHub Pages, online importing might be slower. You can opt to download them locally and then upload for use.
The list of code files provided on this site is shown in ModelResource/libs, and the list below are all files from the ModelResource repository. Name
Description
Link Histogram
Used to draw histograms
ModelResource/libs/Histogram.lua Subplot
Draw subplots when drawing multiple graphs
ModelResource/libs/Subplot.lua tablestr
Convert table to string
ModelResource/libs/tablestr.lua setpoint
Set display points at specified coordinates
ModelResource/libs/setpoint.lua ğŸ”¨ Continuously updating... This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/versions.html",title:"Version Information of MicroCity",pathLocale:"/en/",contents:[{header:"Version Information of MicroCity",slug:"version-information-of-microcity",content:"MicroCity is a simple and fast spatial planning and modeling software, which can be used for mathematical model construction, solving, and simulation experiments, especially suitable for the field of digital modeling in logistics. Initially, MicroCity was only available as a Desktop version that could only run on the Windows operating system. Later, there was a demand for cross-platform use, so MicroCity Web version was introduced, which can run well on browsers with the Chromium kernel."},{header:"MicroCity",slug:"microcity",content:""},{header:"MicroCityWeb",slug:"microcityweb",content:`ğŸ¯Visit MicroCity Web ğŸ“Download (Offline Version)
MicroCity Web does not require any installation, just use a modern browser (such as Google Chrome, Microsoft Edge) to access its website. Although running on a browser may cause some performance loss compared to the desktop version, it allows users to use the software on almost any operating system, such as computer systems Windows, MacOS, Linux, and mobile/tablet systems Android, etc.
Even with the release of MicroCity Web, you can still continue to use the previously developed Desktop version of MicroCity. However, the desktop version will no longer be updated with new features, all new functions and improvements will be delivered continuously to MicroCity Web, in order to provide the best user experience and avoid version control issues. If you want to experience the latest features and improvements, it is necessary to switch to MicroCity Web.
The MicroCity Web version also provides an offline version bundled for export using the browser (see above ğŸ”—link). Warning
However, due to updates in the Chromium browser kernel, some older system versions may not be supported (such as Windows versions below 8.1, 32-bit Windows operating systems, etc.)`},{header:"Compatibility",slug:"compatibility",content:`MicroCity Web version uses Lua 5.4 as the scripting language. You can enter the command print(_VERSION) in the MicroCity Web runtime environment or editor to view the Lua version used.
Due to the use of experimental JavaScript functions, there may be compatibility issues when running MicroCity Web in the following browser kernels: Browsers with Safari kernel, such as most browsers on iOS, iPad OS (due to Apple's mandatory use of Safari browser kernel), Safari browser on MacOS
FireFox browser Compatibility issues encountered during testing on 2023/9/29 and some technical details: iOS and iPad OS: Unable to open local files (due to the use of showOpenFilePicker() method) FireFox: Unable to open local files (due to the use of showOpenFilePicker() method)`},{header:"Additional Information",slug:"additional-information",content:`For the impact of the showOpenFilePicker() method, please refer to MDN Web Docs | showOpenFilePicker().
The author of this note was in the process of writing when MicroCity Web was being used for the first time in an educational environment. It can now operate properly and simulate certain functions. The author's relevant learning experiences are as follows: MicroCity Desktop: Logistics Information Management
MicroCity Web: Logistics System Simulation The content of this note is for reference only. If there are any deviations in the content due to the passage of time, corrections to the content of this site are welcome via Pull Request on GitHub ğŸ¥³. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/visualization.html",title:"Visualization of Results",pathLocale:"/en/",contents:[{header:"Visualization of Results",slug:"visualization-of-results",content:"This article introduces various methods for visualizing computational results. This includes changing the color of the content, changing the size of shapes, and changing the attribute labels displayed for elements."},{header:"Changing Shape Color",slug:"changing-shape-color",content:`In the graphic properties box located at the bottom left corner of the program interface, the type of color displayed can be changed by modifying the Type attribute under the Colors section. There are 3 options available: Unique Symbol: Specifies a specific color for all graphics in the same layer, which will not be discussed further here.
Lookup Table: Displays the corresponding color based on a numerical query from a table.
Graduated Color: Sets a gradient color based on the numerical values in the table.`},{header:"Lookup Table - Changing Color Based on Table Values",slug:"lookup-table-changing-color-based-on-table-values",content:"By changing the Type attribute to Lookup Table, the color of the graphics can be modified based on the values in the table, achieving the effect of selecting specific graphics. In this example, the Attribute of Lookup Table is changed to SELECT in order to control the color of lines based on the values in the SELECT column of the table (as shown in the above image of attribute settings). When the value is 0, the color is displayed as black, and when the value is 1, the color is displayed as red. The values in the SELECT column of the table and the specific settings in the Lookup Table are shown in the following images. The final effect achieved is shown below."},{header:"Graduated Color - Displaying Gradient Color Based on Values",slug:"graduated-color-displaying-gradient-color-based-on-values",content:"By changing the Type attribute to Graduated Color, different colors can be displayed based on the varying numerical values in the table, achieving the effect of displaying a gradient color. In this example, a gradient color is displayed based on the population size of each country. It can be observed that China has a large population, hence the color displayed is red, while India also has a significant population, resulting in an orange color. Other regions have smaller populations, but differences can still be discerned through the colors. The Colors attribute under Graduated Color can also be adjusted with other color schemes. The settings interface is shown in the following image, but each individual setting will not be listed here. If interested, the manual can be referred to for example 2.1 Showing a World Map to manually experiment with changing this attribute."},{header:"Changing the Display Size of Shapes and Labels",slug:"changing-the-display-size-of-shapes-and-labels",content:""},{header:"Selection of Reference System",slug:"selection-of-reference-system",content:`There are 2 reference systems for displaying the size of content: one based on the map and one based on the screen. In this case, both the size of shapes and the display of labels are set to the same reference system.
When content is displayed based on the map, the size of the content will be synchronized and scaled according to the size of the map, as shown in the following images: (Enlarging the content based on the map) (Shrinking the content based on the map) When content is displayed based on the screen, the size of the content remains relatively consistent regardless of the map scaling, as shown in the following image: (Enlarging the content based on the screen)
Translate into English: (Shrunk with the screen as the reference system) Therefore, when drawing, the reference system should be selected according to the purpose of the drawing. If you need to draw shapes with a specific size or label with a specific size on a map, such as drawing a circle with a radius of 10 km, you should use the map as the reference system.
If you only need labels and graphics to be displayed clearly at any size, you can choose the screen as the reference system.`},{header:"Application examples of reference system",slug:"application-examples-of-reference-system",content:"Draw dots in the picture, set the radius of the circle to be the same as the size of the circle, and set the center of the circle to be the center of each green dot. The size of the gray circle represents the coverage range of each green dot. In the picture, the gray circle is drawn for each green dot with a radius of 16, representing the coverage range of each green dot. These gray circles are stored in a layer called Range.shp, and the layer type is Points."},{header:"Setting the reference system",slug:"setting-the-reference-system",content:`The size reference system for graphics and labels can be set in the bottom left corner of the program interface. The two positions marked in the picture can adjust the size reference system for graphics and the size reference system for labels respectively. Setting the size reference system for graphics: Adjust the size reference system for graphics under the Size column in the Size relates to... section. Adjust the Default Size to adjust the size of the graphics relative to the coordinate system.
Setting the size reference system for labels: Adjust the size reference system for labels under the Labels column in the Size relates to... section. Adjust the Default Size to adjust the size of the labels relative to the coordinate system.`},{header:"Changing the displayed labels",slug:"changing-the-displayed-labels",content:""},{header:"Manually changing the displayed labels",slug:"manually-changing-the-displayed-labels",content:`The size reference system for graphics and labels can be set in the bottom left corner of the program interface. The labels displayed in the picture above are ID. If you need to change it to other columns in the table, you can change the Attribute property under the Labels column to achieve it.
The position to be changed is shown in the picture. If you need to display the value in the corresponding MSG column in the table, you only need to change the Attribute property value under the Labels column to MSG. However, every time the graphics are changed and the Update() function is executed, the label will be hidden. If the script to be executed contains the Update() function for this layer, there is no need to manually reconfigure the displayed labels after each script execution. The displayed labels can be automatically selected through the script.`},{header:"Automatically changing the displayed labels",slug:"automatically-changing-the-displayed-labels",content:`The value of an attribute can be changed using the SetParameter() function. Taking the Attribute property under the Labels column in the picture above as an example, you can see that its ID is LABEL_ATTRIB and its type is Choice in the bottom bar. It should be noted that when the type is Choice, the parameter values are numbered starting from 1 and the numbering corresponds to the contents of the drop-down menu in order. After clicking on this property, you can see that MSG is in the second position. Since the numbering in Lua usually starts from 1, the number for ID here corresponds to 1, and the number for MSG corresponds to 2. The object to be operated on is MSG, so the function needs to fill in the parameter value of type Choice as 2.
Now that all the required parameters have been obtained, the SetParameter() function can be used to change the displayed labels.
-- transports is the graphic layer
SetParameter(transports, "LABEL_ATTRIB", 2) The SetParameter() function needs to be executed after the Update() function, otherwise the effect will be overwritten by the Update() function. Now let's take a closer look at the specific usage of the SetParameter() function:
SetParameter(Shapes|Table|Grid|Scene|Module, "id", Number|"String"|Object) Parameter
Meaning Parameter1
The input object, which can be Shapes, Table, Grid, Scene, or Module Parameter2
The id corresponding to the attribute. In the previous context, it is LABEL_ATTRIB Parameter3
If you need to change the attribute value, it only accepts three types: Number, String, and Object The introduction of the SetParameter() function can be found in the 4.2 User Interface Control document, please refer to it.`},{header:"Using Raster Grids",slug:"using-raster-grids",content:`Raster grids can also be used for visualization, and I believe the most common application of raster grids is to draw heat maps. The generation of a heat map is mainly achieved by modifying the value of each cell on the raster grid. If you are not familiar with the specific structure of raster grids, you can refer to the 3.3 Raster Grids document. For controlling raster grids using scripts, you can refer to the 4.4 Grids document.
One scenario of using raster grids to draw heat maps is plotting price maps. When plotting a price map, we can iterate through each grid point on the raster grid, calculate the sum of distances from that grid point to each warehouse, and set the value of that grid point to this sum. This way, we can obtain a heat map. This method helps us visualize the distribution of prices and discover the trends and patterns of prices. This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/warehouse-simulation.html",title:"Ideas for Warehouse Automation Simulation",pathLocale:"/en/",contents:[{header:"Ideas for Warehouse Automation Simulation",slug:"ideas-for-warehouse-automation-simulation",content:"The ideas in this article are for reference only and it is recommended to make appropriate improvements."},{header:"Specific Problem: Warehouse Simulation based on Cellular Automata",slug:"specific-problem-warehouse-simulation-based-on-cellular-automata",content:`In this problem, the locations of inbound and outbound can be changed, and the forklift is an AGV.
In other words, this is actually a cellular automata simulation of a mobile rack warehouse. The AGV can pass through the bottom of the rack, move to the bottom of the rack, lift the rack, and transport it to the inbound/outbound point.`},{header:"Basic Assumptions",slug:"basic-assumptions",content:`All items on the racks are the same.
Only one item is placed on each rack. Therefore, outbound and inbound can be considered as completely opposite processes, so here we only need to discuss the outbound case in detail. It is assumed that there is already an item on the rack by default.`},{header:"Overall Implementation Idea",slug:"overall-implementation-idea",content:`Assign (x,y)(x, y)(x,y) coordinates to each cell in the entire 3Ã—33\\times33Ã—3 warehouse to facilitate subsequent movement operations.
With AGV as the core, operate the racks. When the AGV is in the lifted state and moves the rack, you only need to synchronize the coordinate position of the rack with the position of the AGV to achieve the effect of AGV moving the rack.`},{header:"Business Process",slug:"business-process",content:"Randomly generate the order list according to the required quantity, and the AGV moves the racks to the outbound point in order based on the order list."},{header:"Business Logic",slug:"business-logic",content:`When performing outbound, the AGV first finds the nearest rack and moves to the position of that rack, lifts the rack. For the rack (AGV), set the destination for movement and calculate the difference in Manhattan distance. Before each movement, determine the direction of rack movement (xxx or yyy direction) by checking for obstacles.
If both directions are blocked, prioritize the yyy direction (as specified) and recursively move away the obstacles in this direction to make space for the rack to move. If there is no space in the yyy direction, then move in the xxx direction.`},{header:"Process Optimization: About the Old Method and the New Method",slug:"process-optimization-about-the-old-method-and-the-new-method",content:`Both of these methods are viable, but the new method optimizes for specific scenarios by reducing the number of steps through obstacle prediction. See the problem in the figure below:
Old Method: No Obstacle Prediction (Inbound and outbound points are at position x=3,y=3x=3,y=3x=3,y=3) ğŸ‘‰ After the AGV completes the outbound operation for the first rack and moves towards the second rack, it finds that the first rack blocks the way, so it goes back to move the first rack away, and then proceeds to do the outbound operation for the second rack.
New Method: Obstacle Prediction (Inbound and outbound points are at position x=3,y=3x=3,y=3x=3,y=3) ğŸ‘‰ After the AGV completes the outbound operation for the first rack, it checks if other racks need to be moved before it can reach the inbound/outbound point. If necessary, it moves the obstructed racks and then proceeds to do the outbound operation for the next rack. Info
In line with the principle of minimizing the occupation of the inbound/outbound points, when there is an empty space, the AGV will move the rack at the inbound/outbound point. Therefore, some seemingly redundant operations are not without comprehensive considerations. Optimal layout schemes for different numbers of racks (animated graphics)
The case with 8 racks has already been shown above. Here, we only show the cases with 5 and 7 racks from the table. For other cases, please refer to the appendix.`},{header:"Collection and Analysis of Simulation Data",slug:"collection-and-analysis-of-simulation-data",content:""},{header:"Maximum Inbound/Outbound Efficiency",slug:"maximum-inbound-outbound-efficiency",content:`The simulation results are shown in the figure below, representing the layout of racks with the best efficiency for the same number of racks. Optimal rack layout: For the same number of racks, the layout with the minimum number of operations (ticks) to retrieve all items. Explanation of the Layout Diagram White: No rack is placed.
Light gray: Rack, but the AGV is initially positioned below this rack.
Gray: Rack. Explanation of the Table Rack Quantity: Number of racks in the layout diagram.
Old Ticks: Number of operations to retrieve items using the old method (no obstacle prediction).
New Ticks: Number of operations to retrieve items using the new method (with obstacle prediction). The new method will be explained later.
Highlighted in yellow: Scheme with the minimum number of operations (minimum ticks) in the same layout.`},{header:"Maximum Space Utilization",slug:"maximum-space-utilization",content:`If all positions are filled with racks, it will not be possible to access all racks. Therefore, the method with the highest space utilization is to place 8 racks.
Color Indications Green: Rack with items.
Purple: Rack without items.
Light purple: Rack lifted by the AGV.
Dark purple: AGV below this rack, but the rack is not lifted.
Dark gray: Inbound/outbound points. Sometimes, when the refresh rate is too fast, it may not be possible to see the rack being lifted by the AGV. The entry and exit points are located at position x=2, y=3.`},{header:"Innovations",slug:"innovations",content:`Additional consideration for different types of goods.
Each simulation generates demand based on the random arrangement of goods on the shelves.
Object-oriented programming. Using an object-oriented approach helps in abstracting the problem and improving the flow of the process. Good naming conventions make the program's logic and flow clear, ensuring that you won't forget everything after a night's sleep ğŸ˜‚ Different types of goods are represented by different colors. The meaning of AGV state colors, empty shelf colors, and entry/exit point colors remains the same. Purple: Shelf without goods
Light purple: Shelf lifted by AGV
Dark purple: AGV is positioned beneath the shelf but hasn't lifted it
Dark gray: Entry/exit point Example with 5 shelves: Example with 8 shelves:`},{header:"Simulation Enhancement: 3D Automated Warehouse Simulation",slug:"simulation-enhancement-3d-automated-warehouse-simulation",content:"In this part, the question has slightly changed. The requirement is to add a third dimension to the cellular automaton warehouse simulation and create a simulation of an automated warehouse. The specific requirement is shown in the image above."},{header:"Overall Approach",slug:"overall-approach",content:""},{header:"Adding the Third Dimension",slug:"adding-the-third-dimension",content:`Based on the core of the Cellular Automaton-based Warehouse Simulation, the part of the simulation that uses cellular automata will be rewritten as an internal data table to serve as an internal data model, monitoring and controlling the state of the entire simulation process.
Since the Cellular Automaton-based Warehouse Simulation uses an object-oriented approach to encapsulate objects, and object methods are extensively used in building the business logic and flow, only the object methods need to be rewritten (e.g., Agv:Move(dx, dy)) to achieve the transition from cellular automaton simulation to 3D automated warehouse simulation. If the overall program structure is well-designed, applying "object-oriented" techniques will significantly improve maintainability and reduce the difficulty of migration. The AGV and shelf models can be directly reused. For the goods, you only need to set the relative height list from the shelves to achieve automatic placement of goods at the specified height. Tips
If you need to reuse existing models, or if you want to upload models to the repository maintained by the author of this document, please refer to the documentation on 3D Objects - External Models.`},{header:"Significant Fluctuation in the Demand for Inbound and Outbound Goods",slug:"significant-fluctuation-in-the-demand-for-inbound-and-outbound-goods",content:`According to the requirements, there are basically only two scenarios: 3 shelves and 6 shelves.
Since the number of shelves is limited and the Cellular Automaton-based Warehouse Simulation has obtained the best layout for warehouse performance, the corresponding optimal layouts for the respective number of shelves can be directly reused. In this problem, only the placement of goods in fixed shelf layouts needs to be considered.
For the case of 3 shelves, the optimal layout is a symmetrical configuration in terms of height, with a distance of 1 from the entry/exit point. Therefore, only one scenario needs to be simulated, and the data collected from it.
For the case of 6 shelves, three scenarios were selected for multiple simulations to obtain the average, maximum, and minimum Ticks consumed by each scenario for inbound and outbound operations. Ticks represents the number of times the AGV moves and serves as a unit of operation time. Further improvements are mentioned in the following section: Areas for Enhancement. Based on the above analysis, since there are limited scenarios, the best layout for goods can be determined by simulating the placement of goods at various positions, randomizing the types of demanded goods while keeping the total demand constant, and analyzing the obtained data.`},{header:"Enhancements",slug:"enhancements",content:`During testing, it was found that the original strategy of moving shelves was not reasonable. Therefore, the shelf movement strategy was improved.
Old Strategy: Find the shelf closest to the AGV that contains the requested goods and move it to the entry/exit point. As seen in the animation, the AGV has moved the shelf containing the required goods (represented by blue blocks) to the entry/exit point. However, because the AGV moves the shelf adjacent to the one with the requested goods, it doesn't perform the outbound operation on the goods already at the entry/exit point.
New Strategy: Find the shelf closest to the entry/exit point that contains the requested goods and move it to the entry/exit point. By changing the strategy, the aforementioned issue has been resolved.`},{header:"Innovation",slug:"innovation",content:`Due to the large number of tests, the main process is written into a function for adaptive improvement, achieving automatic simulation tests for all cases and outputting data. The following figure is an example of running the automatic simulation test. Code for the automatic simulation test process, for reference only:
-- Batch test
local cargo_ubs = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} -- Test demands (upper limit) sequence local output_string_list = {} -- List of test result strings
for k, v in ipairs(cargo_ubs) do local test_result = {} -- Test result sequence for this demand upper limit cargo_ub = v -- Set the quantity upper limit for j = 1, test_count do scene.setenv({ grid = 'plane', clear = true }) -- Clear the scene print("Test (", j, "/", test_count, "): Demand quantity is", cargo_ub) local tick = ModelRun() -- Run the simulation model and return the test result table.insert(test_result, tick) -- Insert the test result into the test result sequence end local output_string = "" print("Test result sequence for demand quantity", cargo_ub, ":") for i = 1, #test_result do -- Output the test result sequence to the list string output_string = output_string .. test_result[i] .. "\\t" end print(output_string) table.insert(output_string_list, output_string)
end -- Output the list of test results
for i, str in ipairs(output_string_list) do print("Test result sequence for demand quantity", cargo_ubs[i], ":", str)
end
A bug was discovered during the automatic simulation test process, as described in the following text.`},{header:"Shelf Layout Scheme",slug:"shelf-layout-scheme",content:`Color Legend Light Blue: Inbound and outbound points
White: Empty space
Dark Blue, Red, Yellow: Colors corresponding to 3 types of goods Assumptions Each shelf contains 2 items of the same type
Random demand for goods, no preference for type
Only one item is taken out at a time`},{header:"Simulation Results and Analysis",slug:"simulation-results-and-analysis",content:"Simulate and test each quantity scenario in the layout scheme for each item 30 times, and calculate the maximum, minimum, and average values of the results for each scenario. The final conclusion is that in the case of 6 shelves, Layout Scheme 2 performs the best."},{header:"Scheme 3: 3 shelves",slug:"scheme-3-3-shelves",content:""},{header:"Scheme 6",slug:"scheme-6",content:'Trend in Average Ticks for Scheme 6 Optimal layout scheme for Scheme 6: Scheme 2 Trend graph of "Demand Quantity - Shortest Average Service Time" for each sub-scheme should also be plotted. Taking Scheme 6-1 as an example, the x-axis represents the quantity of goods demanded, and the y-axis represents the shortest average service time (Ticks).'},{header:"Improvement Space",slug:"improvement-space",content:`Since the specific execution time of the event is not given in the title, and the time unit is not specified, we only measure the number of operations on the shelves as the time cost. In other words, the time is calculated afterwards, and I think most of the students might have the same idea at this point. Although there is no problem with the final result, the idea can be changed to adapt to later studies.
The current approach is task-driven. Although it can obtain the correct result, it does not make use of simulation time. This approach does not have any issues when controlling only one entity. However, when dealing with multiple entities simultaneously, the current approach cannot handle the situation where multiple entities complete tasks at the same time, and can only achieve the situation where multiple entities complete tasks one after another. The specific process of the current approach is as follows:
Since the time advance method is used, the simulation world has its own time. For us, we can control the simulation speed by multiplying a multiplier on the simulation time, which is the simulation speed. In addition, this approach is more flexible in supporting multiple objects. The specific process is as follows:
This way, the simulation is changed to be time-centric, and the progress of all entities in the scene can be refreshed directly when refreshing the task execution progress. Since the simulation is time-centric, it is necessary to set the rate/time of various operations to ensure the accuracy of time calculation. In MicroCityWeb, there are some techniques that can be used for time advance simulation.`},{header:"Update simulation time with system time",slug:"update-simulation-time-with-system-time",content:`The os.clock() function can get the current system time (in seconds, but in decimal). With this function, synchronization between simulation time and real time can be achieved. Usage examples can be found in Time Lapse (Chinese only).
Since time is the core of the entire simulation, it is necessary to specify the time required for operations that were not previously defined. In the improved part, the additional time required for the following operations is considered: Time required for goods to enter and leave the storage
Time required for the AGV to lift and lower the shelves This post is translated using ChatGPT, please feedback if any omissions.`}]},{path:"/en/notes/web-ui.html",title:"User Interface Overview",pathLocale:"/en/",contents:[{header:"User Interface Overview",slug:"user-interface-overview",content:"The overall interface of MicroCity Web is shown in the following image. This article will provide a detailed introduction to the user interface (UI) operations of MicroCity Web."},{header:"Overview of Interface Sections",slug:"overview-of-interface-sections",content:`In general, the interface of MicroCity Web can be divided into 4 sections. Top - Blue Section: Executes various operations on code and files
Left - Green Section: Code editor
Right - Red Section: View area
Bottom - Yellow Section: Output information, recognizes program running status Below, we will provide a detailed explanation of the usage and features of these sections.`},{header:"Blue Section - Commands",slug:"blue-section-commands",content:`The content of this section is shown in the following image, and there are a total of 9 available buttons. Their specific functions are as follows: Program Control Run/Debug
Pause Execution
Stop Execution/Force Stop Code Editing Show Editor / Hide Editor
Open Sample Code
Open Local Code File / Upload File to Virtual Disk
Save Code / Download Others Share
View Help Documentation`},{header:"Program Control",slug:"program-control",content:"The first three buttons are mainly used to control program execution. Their specific functions are as follows: Run/Debug: Left-clicking will run the code in the left side Code Editor of the webpage; Right-clicking will start debugging the code. Pause Execution: If the program is running, clicking this button will pause the program execution (if supported by the program). Stop Execution/Force Stop: If the program is running, left-clicking this button will stop the program execution. In some cases where left-clicking fails to stop the script, right-clicking can forcibly terminate its execution."},{header:"Code Editing",slug:"code-editing",content:`Buttons numbered 4 to 7 are mainly related to code editing. Show Editor / Hide Editor: If the left-side code editor is open, clicking this button will close it. If it is closed, clicking this button will open it again. If you right-click, the editor can expand to full screen. Open Sample Code: This button loads built-in code (imports built-in models), such as cube, truck, earth, world map, etc. The specific models will be discussed in detail when introducing the Canvas area. List of built-in codes Open Local Code File / Upload File to Virtual Disk
Left-clicking: This opens a file dialog where you can select a code file (.lua) on your local machine. After selecting a file, its contents will be automatically imported into the left-side code editor.
Right-clicking: You can choose one or more files to upload to MicroCity Web. Right-clicking the "Save" button (â‘¦) allows you to view the list of uploaded files. Save Code / Download
Left-clicking: When you save a file for the first time, clicking the save button will prompt a save file dialog where you can choose the save location and enter a file name. If you have previously saved the file locally, and you have made modifications and want to save the changes, simply click the save button to directly save the changes to the previously saved file. Tips
In the new version of MicroCity Web, the code and uploaded files are packaged as .mw files.
For more information, please refer to File Saving | Debugging Related. Right-clicking: You can view the list of files uploaded to the virtual disk and download them to your local machine by clicking on a file in the list.`},{header:"Others",slug:"others",content:"Share: After clicking this button, a dialog will pop up asking for a password. Afterwards, you will receive a link that anyone can use to access your shared content. If you enter a password in the pop-up dialog box, when others open the link, they can only run your program code and observe the running result, without being able to view your code (unless you inform them of the password); if you do not enter a password, others can not only run your code to view the running result, but also view the code you wrote. View the help documentation."},{header:"Green area: Code Editor",slug:"green-area-code-editor",content:"The integrated code editor on the left side of MicroCity Web is based on AceEditor, so it also has some features of AceEditor."},{header:"Keyboard shortcuts",slug:"keyboard-shortcuts",content:`Below are some common shortcuts to help you edit code more effectively.
Most commonly used: Ctrl+Z: Undo Line operations: Ctrl+D: Delete a line
Ctrl+Shift+D: Duplicate a line
Alt+â†‘: Move the line of code up
Alt+â†“: Move the line of code down Search content: Ctrl+K: Find the next occurrence of the selected content in the code Code indentation: Ctrl+[: Increase code indentation
Ctrl+]: Decrease code indentation Modify values: Ctrl+Shift+â†‘: Increment the value of the number before the cursor
Ctrl+Shift+â†“: Decrement the value of the number before the cursor`},{header:"Red area: Canvas",slug:"red-area-canvas",content:'You can import scenes from built-in code, see Command Area - Code Editing After importing scene code, you need to click the "Run" button to load the scene. Built-in car model Built-in earth model'},{header:"Scene operations",slug:"scene-operations",content:`Operations on scenes, including perspective movement and rotation, need to be performed in the canvas area. Therefore, the basic operations in the canvas area are explained below. Zoom in/out on the scene: Scroll up the mouse wheel to zoom in and scroll down to zoom out.
Pan: Hold down the right mouse button and drag.
Rotate Scene rotation: Hold down the left mouse button and drag to rotate from your perspective.
Object rotation: Click on the object, and after the color of the object changes, hold down the left mouse button and drag to rotate around the object as the center. The above operations apply to both 2D and 3D objects.`},{header:"Yellow area: Code Output",slug:"yellow-area-code-output",content:`After opening MicroCity Web, the code output area is as follows. Clicking on the code output area will cause the entire area to move up, allowing you to see more historical output information. Speaking of the information output in this area, the code output area will display the following information: Script output: The left side shows the output of the script, including the output time and script output content.
Script running status: The first line on the right side indicates the running status of the script. state:ready indicates that the script is ready to start running (not running), state:running indicates that the script is running.
MicroCityWeb version: Indicates the current version of MicroCityWeb being used. If it differs from the known version, you can force refresh to load the latest version.`},{header:"Notes",slug:"notes",content:"Disable Auto-Translate: If your operating system language is not English and your browser has auto-translate enabled, you need to manually disable it, otherwise code execution will result in errors. This post is translated using ChatGPT, please feedback if any omissions."}]},{path:"/404.html",title:"",pathLocale:"/",contents:[]}],V="update-vuepress-plugin-full-text-search2-search-index";var C=b(F),q=j(()=>{const e=new Map;for(const t of C.value)e.set(t.path,t);return e});import.meta.webpackHot&&(__VUE_HMR_RUNTIME__[V]=e=>{C.value=e});function W(e){const t=b([]);let s=null;return L(e,()=>{s&&clearTimeout(s),s=setTimeout(i,100)}),t;function i(){const c=e.value.toLowerCase().trim();if(!c){t.value=[];return}const a=new Map,n=new Set;for(const o of C.value)for(const r of B(o,c)){n.add(r.parentPageTitle);let l=a.get(r.parentPageTitle);l||(l=[],a.set(r.parentPageTitle,l)),l.push(r)}const d=[...n].sort((o,r)=>{const l=a.get(o);return a.get(r).length-l.length});t.value=[...a].flatMap(([,o])=>o).sort((o,r)=>o.parentPagePriority-r.parentPagePriority||d.indexOf(o.parentPageTitle)-d.indexOf(r.parentPageTitle)||o.priority-r.priority)}}function*B(e,t){const s=S(e.title,t);if(s){yield{path:e.path,parentPageTitle:v(e),title:e.title,display:s,page:e,content:null,parentPagePriority:1,priority:1};return}for(const i of e.contents){const c=S(i.header,t);if(c){yield{path:e.path+(i.slug?`#${i.slug}`:""),parentPageTitle:v(e),title:e.title,display:c,page:e,content:null,parentPagePriority:10,priority:2};continue}const a=S(i.content,t);a&&(yield{path:e.path+(i.slug?`#${i.slug}`:""),parentPageTitle:v(e),title:e.title,display:[{type:"header",str:`${i.header}
`},...a],page:e,content:null,parentPagePriority:10,priority:10})}}function v(e){const t=e.path.split("/");let s="/";return t[1]&&(s=`/${t[1]}/`),(q.value.get(s)||e).title}function S(e,t){const s=[];let i=0;const c=e.toLowerCase().replace(/\s/gu," ");let a=0,n=c.indexOf(t,a);if(n<0)return null;for(;n>=0;){const o=n+t.length;if(d(e.slice(a,n),"normal"),d(e.slice(n,o),"highlight"),a=o,n=c.indexOf(t,a),i>100)break}return d(e.slice(a),"normal"),s.filter(o=>o.str);function d(o,r){let l=o;r==="normal"&&l.length>100&&i===0&&(l=`â€¦ ${l.slice(-10)}`);let m=!1;if(i+l.length>100){if(s.some(g=>g.type==="ellipsis"))return;l=l.slice(0,Math.max(100-i,1)),m=!0}s.push({type:r,str:l}),i+=l.length,m&&(s.push({type:"ellipsis",str:" â€¦"}),i+=2)}}var H={"/":{placeholder:"æœç´¢"},"/en/":{placeholder:"Search"}};const U=H,Y=I({name:"SearchBox",props:{locales:{type:Object,required:!1,default:()=>U}},setup(e){const{locales:t}=D(e),s=b(""),i=b(!1),c=b(-1),a=W(s),n=j(()=>s.value&&i.value&&a.value.length),d=_(),o=O(),r=j(()=>t.value[o.value]??{});function l(){if(!n.value)return;let h=c.value-1;h<0&&(h=a.value.length-1),g(h)}function m(){if(!n.value)return;let h=c.value+1;h>=a.value.length&&(h=0),g(h)}function g(h){c.value=h}function P(){c.value=-1}function A(h){if(!n.value)return;const k=a.value[h];k&&d.push(k.path)}return{query:s,focused:i,focusIndex:c,suggestions:a,activeSuggestion:n,onUp:l,onDown:m,focus:g,unfocus:P,go:A,locale:r}}}),X={class:"search-box",role:"search"},$=["placeholder"],Z=["onMousedown","onMouseenter"],Q=["href"],J={key:0,class:"parent-page-title"},K={class:"suggestion-row"},ee={class:"page-title"},te={class:"suggestion-content"};function ne(e,t,s,i,c,a){return u(),p("div",X,[N(f("input",{ref:"input","onUpdate:modelValue":t[0]||(t[0]=n=>e.query=n),"aria-label":"Search",class:y({focused:e.focused}),placeholder:e.locale.placeholder??"Search",autocomplete:"off",spellcheck:"false",onFocus:t[1]||(t[1]=()=>e.focused=!0),onBlur:t[2]||(t[2]=()=>e.focused=!1),onKeyup:[t[3]||(t[3]=x(n=>e.go(e.focusIndex),["enter"])),t[4]||(t[4]=x((...n)=>e.onUp&&e.onUp(...n),["up"])),t[5]||(t[5]=x((...n)=>e.onDown&&e.onDown(...n),["down"]))]},null,42,$),[[R,e.query]]),e.activeSuggestion?(u(),p("ul",{key:0,class:"suggestions",onMouseleave:t[7]||(t[7]=(...n)=>e.unfocus&&e.unfocus(...n))},[(u(!0),p(T,null,M(e.suggestions,(n,d)=>(u(),p("li",{key:d,class:y(["suggestion",{focused:d===e.focusIndex}]),onMousedown:o=>e.go(d),onMouseenter:o=>e.focus(d)},[f("a",{href:n.path,onClick:t[6]||(t[6]=E(()=>{},["prevent"]))},[n.parentPageTitle&&(!e.suggestions[d-1]||e.suggestions[d-1].parentPageTitle!==n.parentPageTitle)?(u(),p("div",J,w(n.parentPageTitle),1)):G("",!0),f("div",K,[f("div",ee,w(n.title||n.path),1),f("div",te,[(u(!0),p(T,null,M(n.display,(o,r)=>(u(),p("span",{key:r,class:y(o.type)},w(o.str),3))),128))])])],8,Q)],42,Z))),128))],32)):G("",!0)])}const ie=z(Y,[["render",ne],["__scopeId","data-v-fd6cd4d5"],["__file","SearchBox.vue"]]);export{ie as default};
